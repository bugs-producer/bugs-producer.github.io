<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>maven打包</title>
      <link href="2021/06/10/maven-da-bao/"/>
      <url>2021/06/10/maven-da-bao/</url>
      
        <content type="html"><![CDATA[<h2 id="1-打包问题"><a href="#1-打包问题" class="headerlink" title="1.打包问题"></a>1.打包问题</h2><p>项目结构如下：</p><p>parent（父类工程）</p><p>| - - - - - common（通用工具类子工程）</p><p>| - - - - - projectA（springboot子工程，依赖common工程）</p><p>pom.xml</p><p>问题描述：</p><p>通过parent父工程进行Maven install，parent父工程和common子工程打包成功，projectA子工程打包失败并报错</p><p>[ERROR] Failed to execute goal org.apache.maven.plugins:maven-compiler-plugin:3.1:compile (default-compile) on project projectA: Compilation failure<br>[ERROR] /xxxx.java:[14,36] 程序包com.xxx.xxx.utils不存在</p><p>解决办法：</p><p>在common子工程下的pom.xml，添加以下配置</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>build</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>plugins</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>plugin</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-boot-maven-plugin<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>configuration</span><span class="token punctuation">&gt;</span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>classifier</span><span class="token punctuation">&gt;</span></span>exec<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>classifier</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>configuration</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>plugin</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>plugins</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>build</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>原因分析：</p><p>common也是SpringBoot工程，SpringBoot工程打包编译时，会生成两种jar包，一种是普通的jar，另一种是可执行jar。</p><p>默认情况下，这两种jar的名称相同，在不做配置的情况下，普通的jar先生成，可执行jar后生成，造成可执行jar会覆盖普通的jar。而projectA工程无法依赖common工程的可执行jar，所以编译失败：程序包xxx不存在。</p>]]></content>
      
      
      <categories>
          
          <category> maven </category>
          
      </categories>
      
      
        <tags>
            
            <tag> maven </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux基础</title>
      <link href="2021/06/10/linux-ji-chu/"/>
      <url>2021/06/10/linux-ji-chu/</url>
      
        <content type="html"><![CDATA[<h2 id="1-命令1"><a href="#1-命令1" class="headerlink" title="1.命令1"></a>1.命令1</h2><h3 id="1-重命名文件夹"><a href="#1-重命名文件夹" class="headerlink" title="1. 重命名文件夹"></a>1. 重命名文件夹</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">mv souce target # 直接使用mv就好了，在本地相当于覆盖地改了<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="2-查看当前路径"><a href="#2-查看当前路径" class="headerlink" title="2. 查看当前路径"></a>2. 查看当前路径</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">pwd-L 如果 PWD 环境变量包含了不包含文件名 .（点表示当前目录）或 ..（点点表示父目录）的当前目录的绝对路径名，则显示 PWD 环境变量的值。否则，-L 标志与 -P 标志一样运行。 -P 显示当前目录的绝对路径名。与 -P 标志一起显示的绝对路径不包含在路径名的绝对路径中涉及到符号链接类型的文件的名称。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-修改环境变量"><a href="#3-修改环境变量" class="headerlink" title="3. 修改环境变量"></a>3. 修改环境变量</h3><p>使用export命令直接修改PATH的值，配置MySQL进入环境变量的方法:</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">export PATH=/home/uusama/mysql/bin:$PATH#或者把PATH放在前面export PATH=$PATH:/home/uusama/mysql/bin<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>注意事项：</p><ul><li>生效时间：立即生效</li><li>生效期限：当前终端有效，窗口关闭后无效</li><li>生效范围：仅对当前用户有效</li><li>配置的环境变量中不要忘了加上原来的配置，即$PATH部分，避免覆盖原来配置</li></ul><h4 id="Linux环境变量配置方法二：vim-bashrc"><a href="#Linux环境变量配置方法二：vim-bashrc" class="headerlink" title="Linux环境变量配置方法二：vim ~/.bashrc"></a>Linux环境变量配置方法二：vim ~/.bashrc</h4><p>通过修改用户目录下的~/.bashrc文件进行配置：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">vim ~/.bashrc# 在最后一行加上export PATH=$PATH:/home/uusama/mysql/bin<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>注意事项：</p><ul><li>生效时间：使用相同的用户打开新的终端时生效，或者手动source ~/.bashrc生效</li><li>生效期限：永久有效</li><li>生效范围：仅对当前用户有效</li><li>如果有后续的环境变量加载文件覆盖了PATH定义，则可能不生效</li></ul><h4 id="Linux环境变量配置方法三：vim-bash-profile"><a href="#Linux环境变量配置方法三：vim-bash-profile" class="headerlink" title="Linux环境变量配置方法三：vim ~/.bash_profile"></a>Linux环境变量配置方法三：vim ~/.bash_profile</h4><p>和修改~/.bashrc文件类似，也是要在文件最后加上新的路径即可：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">vim ~/.bash_profile# 在最后一行加上export PATH=$PATH:/home/uusama/mysql/bin<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>注意事项：</p><ul><li>生效时间：使用相同的用户打开新的终端时生效，或者手动source ~/.bash_profile生效</li><li>生效期限：永久有效</li><li>生效范围：仅对当前用户有效</li><li>如果没有<del>/.bash_profile文件，则可以编辑</del>/.profile文件或者新建一个</li></ul><h4 id="Linux环境变量配置方法四：vim-etc-bashrc"><a href="#Linux环境变量配置方法四：vim-etc-bashrc" class="headerlink" title="Linux环境变量配置方法四：vim /etc/bashrc"></a>Linux环境变量配置方法四：vim /etc/bashrc</h4><p>该方法是修改系统配置，需要管理员权限（如root）或者对该文件的写入权限：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"># 如果/etc/bashrc文件不可编辑，需要修改为可编辑chmod -v u+w /etc/bashrcvim /etc/bashrc# 在最后一行加上export PATH=$PATH:/home/uusama/mysql/bin<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意事项：</p><ul><li>生效时间：新开终端生效，或者手动source /etc/bashrc生效</li><li>生效期限：永久有效</li><li>生效范围：对所有用户有效</li></ul><h4 id="Linux环境变量配置方法五：vim-etc-profile"><a href="#Linux环境变量配置方法五：vim-etc-profile" class="headerlink" title="Linux环境变量配置方法五：vim /etc/profile"></a>Linux环境变量配置方法五：vim /etc/profile</h4><p>该方法修改系统配置，需要管理员权限或者对该文件的写入权限，和vim /etc/bashrc类似：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"># 如果/etc/profile文件不可编辑，需要修改为可编辑chmod -v u+w /etc/profilevim /etc/profile# 在最后一行加上export PATH=$PATH:/home/uusama/mysql/bin<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意事项：</p><ul><li>生效时间：新开终端生效，或者手动source /etc/profile生效</li><li>生效期限：永久有效</li><li>生效范围：对所有用户有效</li></ul><h4 id="Linux环境变量配置方法六：vim-etc-environment"><a href="#Linux环境变量配置方法六：vim-etc-environment" class="headerlink" title="Linux环境变量配置方法六：vim /etc/environment"></a>Linux环境变量配置方法六：vim /etc/environment</h4><p>该方法是修改系统环境配置文件，需要管理员权限或者对该文件的写入权限：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"># 如果/etc/bashrc文件不可编辑，需要修改为可编辑chmod -v u+w /etc/environmentvim /etc/profile# 在最后一行加上export PATH=$PATH:/home/uusama/mysql/bin<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意事项：</p><ul><li>生效时间：新开终端生效，或者手动source /etc/environment生效</li><li>生效期限：永久有效</li><li>生效范围：对所有用户有效</li></ul><h4 id="Linux环境变量加载原理解析"><a href="#Linux环境变量加载原理解析" class="headerlink" title="Linux环境变量加载原理解析"></a>Linux环境变量加载原理解析</h4><p>上面列出了环境变量的各种配置方法，那么Linux是如何加载这些配置的呢？是以什么样的顺序加载的呢？</p><p>特定的加载顺序会导致相同名称的环境变量定义被覆盖或者不生效。</p><p>环境变量的分类</p><p>环境变量可以简单的分成用户自定义的环境变量以及系统级别的环境变量。</p><ul><li>用户级别环境变量定义文件：~/.bashrc、~/.profile（部分系统为：~/.bash_profile）</li><li>系统级别环境变量定义文件：/etc/bashrc、/etc/profile(部分系统为：/etc/bash_profile）、/etc/environment</li></ul><p>另外在用户环境变量中，系统会首先读取<del>/.bash_profile（或者</del>/.profile）文件，如果没有该文件则读取<del>/.bash_login，根据这些文件中内容再去读取</del>/.bashrc。</p><h4 id="测试Linux环境变量加载顺序的方法"><a href="#测试Linux环境变量加载顺序的方法" class="headerlink" title="测试Linux环境变量加载顺序的方法"></a>测试Linux环境变量加载顺序的方法</h4><p>为了测试各个不同文件的环境变量加载顺序，我们在每个环境变量定义文件中的第一行都定义相同的环境变量UU_ORDER，该变量的值为本身的值连接上当前文件名称。</p><p>需要修改的文件如下：</p><pre class="line-numbers language-none"><code class="language-none">/etc/environment/etc/profile/etc/profile.d/test.sh，新建文件，没有文件夹可略过/etc/bashrc，或者/etc/bash.bashrc~/.bash_profile，或者~/.profile~/.bashrc<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在每个文件中的第一行都加上下面这句代码，并相应的把冒号后的内容修改为当前文件的绝对文件名。</p><pre class="line-numbers language-none"><code class="language-none">export UU_ORDER="$UU_ORDER:~/.bash_profile"<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>修改完之后保存，新开一个窗口，然后echo $UU_ORDER观察变量的值：</p><pre class="line-numbers language-none"><code class="language-none">uusama@ubuntu:~$ echo $UU_ORDER$UU_ORDER:/etc/environment:/etc/profile:/etc/bash.bashrc:/etc/profile.d/test.sh:~/.profile:~/.bashrc<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>可以推测出Linux加载环境变量的顺序如下：</p><pre class="line-numbers language-none"><code class="language-none">/etc/environment/etc/profile/etc/bash.bashrc/etc/profile.d/test.sh~/.profile~/.bashrc<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Linux环境变量文件加载详解"><a href="#Linux环境变量文件加载详解" class="headerlink" title="Linux环境变量文件加载详解"></a>Linux环境变量文件加载详解</h4><p>由上面的测试可容易得出Linux加载环境变量的顺序如下，：</p><p>系统环境变量 -&gt; 用户自定义环境变量 /etc/environment -&gt; /etc/profile -&gt; ~/.profile</p><p>打开/etc/profile文件你会发现，该文件的代码中会加载/etc/bash.bashrc文件，然后检查/etc/profile.d/目录下的.sh文件并加载。</p><pre class="line-numbers language-none"><code class="language-none"># /etc/profile: system-wide .profile file for the Bourne shell (sh(1))# and Bourne compatible shells (bash(1), ksh(1), ash(1), ...).if [ "$PS1" ]; then  if [ "$BASH" ] &amp;&amp; [ "$BASH" != "/bin/sh" ]; then    # The file bash.bashrc already sets the default PS1.    # PS1='h:w$ '    if [ -f /etc/bash.bashrc ]; then      . /etc/bash.bashrc    fi  else    if [ "`id -u`" -eq 0 ]; then      PS1='# '    else      PS1='$ '    fi  fifiif [ -d /etc/profile.d ]; then  for i in /etc/profile.d/*.sh; do    if [ -r $i ]; then      . $i    fi  done  unset ifi<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其次再打开<del>/.profile文件，会发现该文件中加载了</del>/.bashrc文件。</p><pre class="line-numbers language-none"><code class="language-none"># if running bashif [ -n "$BASH_VERSION" ]; then    # include .bashrc if it exists    if [ -f "$HOME/.bashrc" ]; then . "$HOME/.bashrc"    fifi# set PATH so it includes user's private bin directoriesPATH="$HOME/bin:$HOME/.local/bin:$PATH"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从~/.profile文件中代码不难发现，/.profile文件只在用户登录的时候读取一次，而/.bashrc会在每次运行Shell脚本的时候读取一次。</p><h4 id="一些小技巧"><a href="#一些小技巧" class="headerlink" title="一些小技巧"></a>一些小技巧</h4><p>可以自定义一个环境变量文件，比如在某个项目下定义uusama.profile，在这个文件中使用export定义一系列变量，然后在~/.profile文件后面加上：sourc uusama.profile，这样你每次登陆都可以在Shell脚本中使用自己定义的一系列变量。</p><p>也可以使用alias命令定义一些命令的别名，比如alias rm=”rm -i”（双引号必须），并把这个代码加入到~/.profile中，这样你每次使用rm命令的时候，都相当于使用rm -i命令，非常方便。</p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql基础</title>
      <link href="2021/06/10/mysql-ji-chu/"/>
      <url>2021/06/10/mysql-ji-chu/</url>
      
        <content type="html"><![CDATA[<h2 id="1-安装"><a href="#1-安装" class="headerlink" title="1.安装"></a>1.安装</h2><h3 id="1-1-centos-mysql-5-7"><a href="#1-1-centos-mysql-5-7" class="headerlink" title="1.1 centos mysql 5.7"></a>1.1 centos mysql 5.7</h3><blockquote><p>CentOS 7的默认yum仓库中并没有MySQL5.7，我们需要手动添加，好在MySQL官方提供了仓库的地址，所以我们能够比较简单地安装MySQL。</p><p>本文我们将介绍CentOS 7下MySQL5.7的安装。</p></blockquote><ol><li>添加Mysql5.7仓库</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">rpm</span> -ivh https://dev.mysql.com/get/mysql57-community-release-el7-11.noarch.rpm<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol><li>确认Mysql仓库成功添加</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> yum repolist all <span class="token operator">|</span> <span class="token function">grep</span> mysql <span class="token operator">|</span> <span class="token function">grep</span> enabled<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果展示像下面,则表示成功添加仓库:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">mysql-connectors-community/x86_64  MySQL Connectors Community    enabled:     <span class="token number">51</span>mysql-tools-community/x86_64       MySQL Tools Community         enabled:     <span class="token number">63</span>mysql57-community/x86_64           MySQL <span class="token number">5.7</span> Community Server    enabled:    <span class="token number">267</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ol><li>开始安装Mysql5.7</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> yum -y <span class="token function">install</span> mysql-community-server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol><li><p>启动Mysql</p><ol><li>启动</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> systemctl start mysqld<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol><li>设置系统启动时自动启动</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> systemctl <span class="token builtin class-name">enable</span> mysqld<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol><li>查看启动状态</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> systemctl status mysqld<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>Mysql的安全设置</p><p>CentOS上的root默认密码可以在文件/var/log/mysqld.log找到，通过下面命令可以打印出来</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">cat</span> /var/log/mysqld.log <span class="token operator">|</span> <span class="token function">grep</span> -i <span class="token string">'temporary password'</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>执行下面命令进行安全设置，这个命令会进行设置root密码设置，移除匿名用户，禁止root用户远程连接等</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">mysql_secure_installation<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>设置数据库编码为utf8</p><ol><li>打开配置文件</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">vim</span> /etc/my.cnf<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol><li>在[mysqld]，[client]，[mysql]节点下添加编码设置</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>client<span class="token punctuation">]</span>default-character-set<span class="token operator">=</span>utf8<span class="token punctuation">[</span>mysql<span class="token punctuation">]</span>default-character-set<span class="token operator">=</span>utf8<span class="token punctuation">[</span>mysqld<span class="token punctuation">]</span>collation-server <span class="token operator">=</span> utf8_unicode_ciinit-connect<span class="token operator">=</span><span class="token string">'SET NAMES utf8'</span>character-set-server <span class="token operator">=</span> utf8<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li>重启Mysql即可</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> systemctl restart mysqld<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol><h4 id="1-1-2-更改用户名和密码"><a href="#1-1-2-更改用户名和密码" class="headerlink" title="1.1.2 更改用户名和密码"></a>1.1.2 更改用户名和密码</h4><p>1、修改 <code>/etc/my.cnf</code>，在 [mysqld] 小节下添加一行：<code>skip-grant-tables=1</code></p><p>这一行配置让 mysqld 启动时不对密码进行验证</p><p>2、重启 mysqld 服务：<code>systemctl restart mysqld</code></p><p>3、使用 root 用户登录到 <code>mysql：mysql -u root</code></p><p>注释：当看到密码输入时直接按return</p><p>添加新密码</p><p>1、切换到mysql数据库，更新 user 表：</p><p><code>use mysql</code></p><p><code>update user set authentication_string = password('新密码'), password_expired = 'N', password_last_changed = now() where user = 'root';</code></p><p>在之前的版本中，密码字段的字段名是 password，5.7版本改为了 <code>authentication_string</code></p><p>恢复使用root密码</p><p>1、退出 mysql，编辑 <code>/etc/my.cnf </code>文件，删除 skip-grant-tables=1 的内容</p><p>2、重启 mysqld 服务，再用新密码登录即可</p><h2 id="2-备份和恢复"><a href="#2-备份和恢复" class="headerlink" title="2. 备份和恢复"></a>2. 备份和恢复</h2><p><strong>备份方法</strong></p><pre class="line-numbers language-none"><code class="language-none">mysqldump -uroot -p000 db table &gt; db.sql<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>还原方法</strong></p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">mysql -uroot -p000 &lt; db.sql #直接恢复整个数据库mysql -uroot -p000 db_tencent_health_data &lt; t_doctor_20210607.sql #在这个数据库中建立这张表<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p> 参考： </p><p>1.拷备文件      :  (保证数据库没有写操作(可以给表上锁定))直接拷贝文件不能移植到其它机器上，除非你正在拷贝的表使用MyISAM存储格式<br>2.mysqldump   :  mysqldump生成能够移植到其它机器的文本文件 </p><p>例:<br>备份整个数据库   –&gt;   mysqldump db1 &gt;/backup/db1.20060725<br>压缩备份        –&gt;   mysqldump db1 | gzip &gt;/backup/db1.20060725<br>分表备份        –&gt;   mysqldump db1 tab1 tab2 &gt;/backup/db1_tab1_tab2.sql<br>直接远程备份     –&gt;   mysqladmin -h boa.snake.net create db1<br>              –&gt;   mysqldump db1 | mysql -h boa.snake.net db1 </p><p>复制备份表      –&gt;   cp tab.*   backup/ </p><p>恢复<br>用最新的备份文件重装数据库。如果你用mysqldump产生的文件，将它作为mysql的输入。如果你用直接从数据库拷贝来的文件，将它们直接拷回数据库目录，然而，此时你需要在拷贝文件之前关闭数据库，然后重启它。  </p>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mybatis-plus</title>
      <link href="2021/06/07/mybatis-plus/"/>
      <url>2021/06/07/mybatis-plus/</url>
      
        <content type="html"><![CDATA[<h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1. 介绍"></a>1. 介绍</h2><p>官方地址：<a href="https://baomidou.com/">MyBatis-Plus (baomidou.com)</a></p><h2 id="2-依赖"><a href="#2-依赖" class="headerlink" title="2. 依赖"></a>2. 依赖</h2><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>com.baomidou<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>mybatis-plus-boot-starter<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>3.3.1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-注解"><a href="#3-注解" class="headerlink" title="3.注解"></a>3.注解</h2><h3 id="3-1-TableId"><a href="#3-1-TableId" class="headerlink" title="3.1 @TableId"></a>3.1 @TableId</h3><p>设置主键映射。value设置映射。</p><p>type 设置主键的生成策略。</p><table><thead><tr><th>值</th><th>描述</th></tr></thead><tbody><tr><td>AUTO</td><td>数据库自增</td></tr><tr><td>NONE</td><td>MP set主键，雪花算法实现</td></tr><tr><td>INPUT</td><td>需要开发者手动赋值</td></tr><tr><td>ASSIGN_ID</td><td>MP分配ID，Long、Integer、String</td></tr><tr><td>ASSIGN_UUID</td><td>分配UUID，String</td></tr></tbody></table><p>INPUT 如果开发者手动没有赋值，则数据库通过自增的方式给主键赋值，如果开发者手动赋值，则存入该值。</p><p>AUTO默认就是数据库自增，开发者无需赋值。</p><p>ASSIGN_ID MP 自动赋值，雪花算法。</p><p>ASSIGN_UUID 主键的数据类型必须是String，自动生成UUID进行赋值。</p><h3 id="3-2-TableField"><a href="#3-2-TableField" class="headerlink" title="3.2 @TableField"></a>3.2 @TableField</h3><p>设置类中属性与表中名字映射。</p><ul><li>exist</li></ul><p>是否为数据库字段。false，告诉mybatisplus查的时候不要把这个字段带上。</p><ul><li>fill</li></ul><p>表示是否自动填充，将对象存入数据库的时候，由MyBatis Plus自动给某些字段赋值，create_time、update_time。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@TableField</span><span class="token punctuation">(</span>fill <span class="token operator">=</span> <span class="token class-name">FieldFill</span><span class="token punctuation">.</span>INSERT<span class="token punctuation">)</span><span class="token keyword">private</span> <span class="token class-name">Date</span> createTime<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Component</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyMetaObjectHandler</span> <span class="token keyword">implements</span> <span class="token class-name">MetaObjectHandler</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">insertFill</span><span class="token punctuation">(</span><span class="token class-name">MetaObject</span> metaObject<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setFieldValByName</span><span class="token punctuation">(</span><span class="token string">"crateTime"</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> metaObject<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>        <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">updateFill</span><span class="token punctuation">(</span><span class="token class-name">MetaObject</span> metaObject<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-3-TableName"><a href="#3-3-TableName" class="headerlink" title="3.3 @TableName"></a>3.3 @TableName</h3><p>设置类名字与表中名字映射</p><h3 id="3-4-Version"><a href="#3-4-Version" class="headerlink" title="3.4 @Version"></a>3.4 @Version</h3><p>标记<strong>乐观锁</strong>，通过version字段来保证数据的安全性，当修改数据的时候会以version作为条件，当条件成立的时候，才会修改成功。</p><p>version=1。 这样当多个线程修改的时候保证修改的成功。(主要是修改操作)</p><p>线程1：update … set version = 2 where version = 1</p><p>线程2：update … set version = 2 where version = 1</p><p>1、数据库表添加version字段，默认为1。</p><p>2、实体类添加version成员变量，并且添加@Version注解</p><p>3、添加配置类，Version字段会自动找这个配置类</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyBatisPlusConfig</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> <span class="token class-name">OptimisticLockerIntegerceptor</span> <span class="token function">optimisticLockerIntegerceptor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">OptimisticLockerInterceptor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-5-EnumValue"><a href="#3-5-EnumValue" class="headerlink" title="3.5 @EnumValue"></a>3.5 @EnumValue</h3><ol><li>添加配置文件中信息</li></ol><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">mybatis-plus</span><span class="token punctuation">:</span><span class="token key atrule">type-enums-package</span><span class="token punctuation">:</span>com.southwind.mybatisplus.enums//自己的类名<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ol start="2"><li>添加注解类</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">enum</span> <span class="token class-name">StatusEnum</span> <span class="token punctuation">{</span>    <span class="token function">WORK</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"上班"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">REST</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token string">"休息"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">StatusEnum</span><span class="token punctuation">(</span><span class="token class-name">Integer</span> code<span class="token punctuation">,</span> <span class="token class-name">String</span> msg<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>code <span class="token operator">=</span> code<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>msg <span class="token operator">=</span> msg<span class="token punctuation">;</span>    <span class="token punctuation">}</span>        <span class="token annotation punctuation">@EnumValue</span>    <span class="token keyword">private</span> <span class="token class-name">Integer</span> code<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> msg<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以将数据库中的1映射成上班，0休息。</p><p>第二种实现方式：</p><p>实现接口IEnun</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">enum</span> <span class="token class-name">AgeEnum</span> <span class="token keyword">implements</span> <span class="token class-name">IEnum</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>    <span class="token function">ONE</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"一岁"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">TWO</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">"两岁"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">THREE</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token string">"三岁"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">Integer</span> code<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">Integer</span> msg<span class="token punctuation">;</span>    <span class="token class-name">AgeEnum</span> <span class="token punctuation">(</span><span class="token class-name">Integer</span> code<span class="token punctuation">,</span> <span class="token class-name">String</span> msg<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>code <span class="token operator">=</span> code<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>msg <span class="token operator">=</span> msg<span class="token punctuation">;</span>    <span class="token punctuation">}</span>        <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token class-name">Integer</span> <span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>code<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-6-TableLogic"><a href="#3-6-TableLogic" class="headerlink" title="3.6 TableLogic"></a>3.6 TableLogic</h3><ol><li>实体类中添加映射逻辑删除。</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@TableLogic</span><span class="token keyword">private</span> <span class="token class-name">Integer</span> deleted<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>2、配置文件中</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">mybatis-plus</span><span class="token punctuation">:</span><span class="token key atrule">global-config</span><span class="token punctuation">:</span><span class="token key atrule">db-donfig</span><span class="token punctuation">:</span><span class="token key atrule">logic-not-delete-value</span><span class="token punctuation">:</span> <span class="token number">0</span><span class="token key atrule">logic-delete-value</span> <span class="token punctuation">:</span> <span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4-CRUD"><a href="#4-CRUD" class="headerlink" title="4. CRUD"></a>4. CRUD</h2><h3 id="4-1-查询"><a href="#4-1-查询" class="headerlink" title="4.1 查询"></a>4.1 查询</h3><h2 id="5-自动生成"><a href="#5-自动生成" class="headerlink" title="5. 自动生成"></a>5. 自动生成</h2><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>com.baomidou<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>mybatis-plus-generator<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>3.4.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.apache.velocity<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>velocity<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>1.7<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li><p>自动生成器的包和velocity都需要，因为自动生成器根据velocity模板导入的。</p></li><li><p>启动类</p></li></ol><h2 id="6-自定义SQL、多表关联"><a href="#6-自定义SQL、多表关联" class="headerlink" title="6. 自定义SQL、多表关联"></a>6. 自定义SQL、多表关联</h2><h3 id="7-SpringBoot-Mybatis-Plus-打包直接发布"><a href="#7-SpringBoot-Mybatis-Plus-打包直接发布" class="headerlink" title="7. SpringBoot + Mybatis Plus 打包直接发布"></a>7. SpringBoot + Mybatis Plus 打包直接发布</h3>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> mybatis plus </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2021/05/24/mybatis/"/>
      <url>2021/05/24/mybatis/</url>
      
        <content type="html"><![CDATA[<h1 id="Mybatis"><a href="#Mybatis" class="headerlink" title="Mybatis"></a>Mybatis</h1><h2 id="1-配置maven"><a href="#1-配置maven" class="headerlink" title="1. 配置maven"></a>1. 配置maven</h2><h3 id="1-1-下载地址"><a href="#1-1-下载地址" class="headerlink" title="1.1 下载地址"></a>1.1 下载地址</h3><p><a href="http://maven.apache.org/download.html">maven 官网下载地址</a></p><p>参考环境配置 </p><p><a href="https://www.cnblogs.com/telwanggs/p/10820701.html">https://www.cnblogs.com/telwanggs/p/10820701.html</a></p><p>mybatis 中文文档 <a href="https://mybatis.org/mybatis-3/zh/configuration.html">https://mybatis.org/mybatis-3/zh/configuration.html</a></p><h3 id="1-2-编写mybatis配置文件"><a href="#1-2-编写mybatis配置文件" class="headerlink" title="1.2 编写mybatis配置文件"></a>1.2 编写mybatis配置文件</h3><p>XML配置文件<code>configuration XML</code>中包含了对MyBatis系统的核心设置。</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">configuration</span>  <span class="token name">PUBLIC</span> <span class="token string">"-//mybatis.org//DTD Config 3.0//EN"</span>  <span class="token string">"http://mybatis.org/dtd/mybatis-3-config.dtd"</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>configuration</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>environments</span> <span class="token attr-name">default</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>development<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>environment</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>development<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>transactionManager</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>JDBC<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dataSource</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>POOLED<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>driver<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>${driver}<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>url<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>${url}<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>username<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>${username}<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>password<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>${password}<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dataSource</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>environment</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>environments</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>mappers</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>mapper</span> <span class="token attr-name">resource</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>org/mybatis/example/BlogMapper.xml<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>mappers</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>configuration</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-3-编写代码"><a href="#1-3-编写代码" class="headerlink" title="1.3 编写代码"></a>1.3 编写代码</h3><ul><li>实体类</li><li>Dao接口</li><li>接口实现类</li></ul><p>接口实现由原来的<code>UserDaoImpl</code>转换为<code>Mapper</code>配置文件。</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">mapper</span>        <span class="token name">PUBLIC</span> <span class="token string">"-//mybatis.org//DTD Mapper 3.0//EN"</span>        <span class="token string">"http://mybatis.org/dtd/mybatis-3-mapper.dtd"</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>mapper</span> <span class="token attr-name">namespace</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.kuang.dao.UserDao<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>getUserList<span class="token punctuation">"</span></span> <span class="token attr-name">resultType</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.kuang.pojo.User <span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>        select * from mybatis.user    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>mapper</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-4-测试"><a href="#1-4-测试" class="headerlink" title="1.4 测试"></a>1.4 测试</h3><ul><li>junit测试</li></ul><p>注意点：报错</p><p>org.apache.ibatis.binding.BindingException: Type interface com.kuang.dao.UserDao is not known to the MapperRegistry.</p><h3 id="1-5-知识点"><a href="#1-5-知识点" class="headerlink" title="1.5 知识点"></a>1.5 知识点</h3><ol><li><p>从SqlSessionFactory中获取SqlSession。</p></li><li><p>命名空间要写，绑定接口。写完全限定名。</p></li><li><p><font color="red">SqlSessionFactoryBuilder</font></p><p>这个类可以被实例化、使用和丢弃，一旦创建SqlSessionFactory就不再需要他了。因此它实例的最佳作用是方法作用域。</p></li><li><p>SqlSessionFactory</p><ul><li>可以想象为数据库连接池。</li></ul><p>SqlSessionFactory一旦创建就应该在运行期间一直存在。默认单例模式或静态单例模式。（适合全局）。</p></li><li><p>SqlSession</p><p>SqlSesion不是线程安全的，不能被共享。每次收到的HTTP请求，就可以打开一个SqlSession，返回一个相应就应该关闭它。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">try</span> <span class="token punctuation">(</span><span class="token class-name">SqlSession</span> session <span class="token operator">=</span> sqlSessionFactory<span class="token punctuation">.</span><span class="token function">openSession</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    你的应用逻辑代码<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ol><p>![](D:\1\奇技淫巧\photoDon’t delete\Spring\mybatisFactory.PNG)</p><h2 id="2-CRUD"><a href="#2-CRUD" class="headerlink" title="2.CRUD"></a>2.CRUD</h2><h3 id="1、-namespace"><a href="#1、-namespace" class="headerlink" title="1、 namespace"></a>1、 namespace</h3><p>namespace中的包名要和Dao/mapper接口中的一致。</p><h3 id="2、select"><a href="#2、select" class="headerlink" title="2、select"></a>2、select</h3><p>选择，查询语句</p><ul><li>id:对应的namespace中的方法。</li><li>returnType:Sql语句执行的返回值！</li><li>parameterType：参数类型</li></ul><h2 id="3-Map"><a href="#3-Map" class="headerlink" title="3. Map"></a>3. Map</h2><p>不需要知道数据库中有什么，只需要查对应的字段。</p><p>数据库中表或者字段参数过多，应当考虑使用Map。</p><h2 id="4-配置解析"><a href="#4-配置解析" class="headerlink" title="4.配置解析"></a>4.配置解析</h2><h4 id="4-1-核心配置文件"><a href="#4-1-核心配置文件" class="headerlink" title="4.1 核心配置文件"></a>4.1 核心配置文件</h4><p>  configuration（配置）</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">properties（属性）settings（设置）typeAliases（类型别名）typeHandlers（类型处理器）objectFactory（对象工厂）plugins（插件）environments（环境配置）environment（环境变量）transactionManager（事务管理器）dataSource（数据源）databaseIdProvider（数据库厂商标识）mappers（映射器）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="4-2-环境配置"><a href="#4-2-环境配置" class="headerlink" title="4.2 环境配置"></a>4.2 环境配置</h4><p>Mybatis 事务管理器有两种：JDBC和MANAGED。默认JDBC。</p><p>datasource 连接数据库。内置三种数据源类型 type = UNPOOLED | POOLED| JNDI。默认连接池POOLED。</p><p>学会使用配置多套运行环境。</p><p>池子的解释：用完可以回收。</p><h4 id="4-3-属性"><a href="#4-3-属性" class="headerlink" title="4.3 属性"></a>4.3 属性</h4><p>可以通过properties来提供多种实现方式。</p><p>属性都是可外部动态替换的，可在典型的Java属性文件中配置，亦可通过properties元素的子元素来改造。</p><h4 id="4-4-别名"><a href="#4-4-别名" class="headerlink" title="4.4 别名"></a>4.4 别名</h4><ul><li>类型别名是为Java类型设置一个短的名字。</li><li>存在的意义用来减少类完全限定名的冗余。</li></ul><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>typeAliases</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>typeAlias</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.kuang.pojo.User<span class="token punctuation">"</span></span> <span class="token attr-name">alias</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>User<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>typeAliases</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>扫描实体类的包，它的默认别名就为这个类的 类名，首字母小写！</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>typeAliases</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>package</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.kuang.pojo<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>typeAliases</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>在实体类比较少的时候使用第一种方式，如果实体类比较多，使用第二种。第一种可以DIY， 第二种则不行。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Alias</span><span class="token punctuation">(</span><span class="token string">"user"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">User</span><span class="token punctuation">{</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="4-5-Mappers-映射"><a href="#4-5-Mappers-映射" class="headerlink" title="4.5 Mappers 映射"></a>4.5 Mappers 映射</h4><p>MapperRegistry：注册绑定mappers文件。</p><p>第一种方式。mapper文件可以随便放。</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>mappers</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>mapper</span> <span class="token attr-name">resource</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com/kuang/dao/UserMapper.xml<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>mappers</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>第二种方式。类的方式。</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>mappers</span><span class="token punctuation">&gt;</span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>mapper</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.kuang.dao.UserMapper<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>mappers</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>接口和Mapper配置文件必须在同一个包下。</li><li>接口和Mapper配置文件必须同名。</li></ul><p>第三种方式。package方式</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>mappers</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>package</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.kuang.dao<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>mappers</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>注意方式：</p><ul><li>接口和Mapper配置文件必须在同一个包下。</li><li>接口和Mapper配置文件必须同名。</li></ul><h2 id="5-解决属性名和字段名不一致的问题"><a href="#5-解决属性名和字段名不一致的问题" class="headerlink" title="5. 解决属性名和字段名不一致的问题"></a>5. 解决属性名和字段名不一致的问题</h2><h3 id="5-1-结果集映射"><a href="#5-1-结果集映射" class="headerlink" title="5.1 结果集映射"></a>5.1 结果集映射</h3><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">id name pwdid name password<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>resultMap</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>UserMap<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>User<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token comment">&lt;!--        column 数据库中的字段 property 实体类属性--&gt;</span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>result</span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>pwd<span class="token punctuation">"</span></span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>password<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>resultMap</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>getUserById<span class="token punctuation">"</span></span> <span class="token attr-name">resultMap</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>UserMap<span class="token punctuation">"</span></span> <span class="token attr-name">resultType</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.kuang.pojo.User<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>        select * from mybatis.user1 where id=#{id};    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="6-日志"><a href="#6-日志" class="headerlink" title="6.日志"></a>6.日志</h2><p>如果一个数据库操作出现了异常，需要排错。日志就是最好的助手。</p><p>曾经：sout、debug</p><p>现在：日志工厂！</p><p>logImpl 指定Mybatis所用日志的具体实现。</p><table><thead><tr><th>logImpl</th><th>指定 MyBatis 所用日志的具体实现，未指定时将自动查找。</th><th>SLF4J | LOG4J | LOG4J2 | JDK_LOGGING | COMMONS_LOGGING | STDOUT_LOGGING | NO_LOGGING</th><th>未设置</th></tr></thead><tbody><tr><td></td><td></td><td></td><td></td></tr></tbody></table><p>具体使用哪一个日志实现，默认未设置日志工厂。</p><p>标准是STDOUT_LOGGING</p><h3 id="6-1-Log4j"><a href="#6-1-Log4j" class="headerlink" title="6.1 Log4j"></a>6.1 Log4j</h3><p>先导入Log4j的包。</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>log4j<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>log4j<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>1.2.17<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>通过一个配置文件来配置</li></ul><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token comment">#将等级为DEBUG的日志信息输出到console和file这两个目的地，console和file的定义在下面的代码</span><span class="token attr-name">log4j.rootLogger</span><span class="token punctuation">=</span><span class="token attr-value">DEBUG,console,file</span><span class="token comment">#控制台输出的相关配置</span><span class="token attr-name">log4j.appender.console</span> <span class="token punctuation">=</span> <span class="token attr-value">org.apache.log4j.ConsoleAppender</span><span class="token attr-name">log4j.appender.console.Target</span> <span class="token punctuation">=</span> <span class="token attr-value">System.out</span><span class="token attr-name">log4j.appender.console.Threshold</span> <span class="token punctuation">=</span> <span class="token attr-value">DEBUG</span><span class="token attr-name">log4j.appender.console.layout</span> <span class="token punctuation">=</span> <span class="token attr-value">org.apache.log4j.PatternLayout</span><span class="token attr-name">log4j.appender.console.layout.ConversionPattern</span> <span class="token punctuation">=</span> <span class="token attr-value">[%c]-%m%n</span><span class="token comment"># 将文件输出的相关配置</span><span class="token attr-name">log4j.appender.file</span> <span class="token punctuation">=</span> <span class="token attr-value">org.apache.log4j.RollingFileAppender</span><span class="token attr-name">log4j.appender.file.File</span> <span class="token punctuation">=</span> <span class="token attr-value">./log/kuang.log</span><span class="token attr-name">log4j.appender.file.MaxFileSize</span><span class="token punctuation">=</span><span class="token attr-value">10mb</span><span class="token attr-name">log4j.appender.file.Threshold</span><span class="token punctuation">=</span><span class="token attr-value">DEBUG</span><span class="token attr-name">log4j.appender.file.layout</span><span class="token punctuation">=</span><span class="token attr-value">org.apache.log4j.PatternLayout</span><span class="token attr-name">log4j.appender.file.layout.ConversionPattern</span><span class="token punctuation">=</span><span class="token attr-value">[%p][%d{yy-MM-dd}][%c]%m%n</span><span class="token comment"># 日志输出级别</span><span class="token attr-name">log4j.logger.org.mybatis</span><span class="token punctuation">=</span><span class="token attr-value">DEBUG</span><span class="token attr-name">log4j.logger.java.sql</span><span class="token punctuation">=</span><span class="token attr-value">DEBUG</span><span class="token attr-name">log4j.logger.java.sql.Statement</span><span class="token punctuation">=</span><span class="token attr-value">DEBUG</span><span class="token attr-name">log4j.logger.java.sql.ResultSet</span><span class="token punctuation">=</span><span class="token attr-value">DEBUG</span><span class="token attr-name">log4j.logger.java.sql.PreparedStatement</span><span class="token punctuation">=</span><span class="token attr-value">DEBUG</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>配置log4j为日志的实现</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>settings</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>setting</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>logImpl<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>Log4j<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>settings</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>使用</p></li></ul><ol><li>在要使用Log4j的类中导入包。</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>log4j<span class="token punctuation">.</span></span><span class="token class-name">Logger</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ol start="2"><li>日志对象加载参数为当前类的class。</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">static</span> <span class="token class-name">Logger</span> logger <span class="token operator">=</span> <span class="token class-name">Logger</span><span class="token punctuation">.</span><span class="token function">getLogger</span><span class="token punctuation">(</span><span class="token class-name">UserDaoTest</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="3"><li>日志级别</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java">logger<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span>logger<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span>logger<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="7-分页"><a href="#7-分页" class="headerlink" title="7.分页"></a>7.分页</h2><p>常见的就是使用mysql里面的limit关键字.比如：</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">SELECT * FROM limit 0,2;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>使用mybatis实现分页：</p><ol><li>接口</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//分页</span>    <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">User</span><span class="token punctuation">&gt;</span></span> <span class="token function">getUserByLimit</span><span class="token punctuation">(</span><span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> map<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ol start="2"><li>Mapper.XML</li></ol><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>getUserByLimit<span class="token punctuation">"</span></span> <span class="token attr-name">parameterType</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>map<span class="token punctuation">"</span></span> <span class="token attr-name">resultType</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>user<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>        select * from mybatis.user1 limit #{startIndex},${pageSize};    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ol start="3"><li>测试</li></ol><h3 id="7-2-RowBounds"><a href="#7-2-RowBounds" class="headerlink" title="7.2 RowBounds"></a>7.2 RowBounds</h3><p>不再使用SQL实现分页。</p><ol><li>接口</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">User</span><span class="token punctuation">&gt;</span></span> <span class="token function">getUserByRowBounds</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="2"><li>mapper.xml</li></ol><pre class="line-numbers language-none"><code class="language-none">&lt;select id="getUserByRowBounds" resultMap="UserMap"&gt;    select * from mybatis.user1;&lt;/select&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ol><li>测试</li></ol><h3 id="7-3-分页插件"><a href="#7-3-分页插件" class="headerlink" title="7.3 分页插件"></a>7.3 分页插件</h3><p>PageHelper</p><h2 id="8-使用注解开发"><a href="#8-使用注解开发" class="headerlink" title="8.使用注解开发"></a>8.使用注解开发</h2><h3 id="8-1-面向接口编程"><a href="#8-1-面向接口编程" class="headerlink" title="8.1 面向接口编程"></a>8.1 面向接口编程</h3><ul><li><p>定义（约束与规范）与实现的分离</p></li><li><p>有一些mapper不用xml配置，直接使用注解。</p></li></ul><ol><li>注解在接口上实现</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Select</span><span class="token punctuation">(</span><span class="token string">"select * from user1"</span><span class="token punctuation">)</span>    <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">User</span><span class="token punctuation">&gt;</span></span> <span class="token function">getUsers</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ol start="2"><li>在核心配置文件中绑定接口</li></ol><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>mappers</span><span class="token punctuation">&gt;</span></span><span class="token comment">&lt;!--        &lt;mapper resource="com/kuang/dao/UserMapper.xml"/&gt;--&gt;</span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>mapper</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.kuang.dao.UserMapper<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span><span class="token comment">&lt;!--        &lt;package name="com.kuang.dao"/&gt;--&gt;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>mappers</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="3"><li>测试</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Test</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token class-name">SqlSession</span> sqlSession <span class="token operator">=</span> <span class="token class-name">MybatisUtils</span><span class="token punctuation">.</span><span class="token function">getSqlSession</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">UserMapper</span> mapper <span class="token operator">=</span> sqlSession<span class="token punctuation">.</span><span class="token function">getMapper</span><span class="token punctuation">(</span><span class="token class-name">UserMapper</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">User</span><span class="token punctuation">&gt;</span></span> users <span class="token operator">=</span> mapper<span class="token punctuation">.</span><span class="token function">getUsers</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">User</span> user <span class="token operator">:</span> users<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        sqlSession<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="8-2-CURD"><a href="#8-2-CURD" class="headerlink" title="8.2 CURD"></a>8.2 CURD</h3><ul><li>可以在工具类创建的时候实现自动提交事务。</li><li>@Param（”name”）。SQL引用的就是这个起的名字</li></ul><h2 id="9-Mybatis执行流程"><a href="#9-Mybatis执行流程" class="headerlink" title="9. Mybatis执行流程"></a>9. Mybatis执行流程</h2><h2 id="10-Lombok"><a href="#10-Lombok" class="headerlink" title="10. Lombok"></a>10. Lombok</h2><p>通过注解消除冗余代码</p><p>缺点：1、不支持多种参数构造器的重载 2、降低了源代码的可读性和完整性</p><ol><li>安装插件</li><li>导入lombok包(pom.xml中配置)</li><li>实体类加注解</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Data</span><span class="token operator">:</span>无参构造、get、set、tostring、hashcode、equals<span class="token annotation punctuation">@ALLArgsConstructor</span><span class="token annotation punctuation">@NoArgsConstructor</span><span class="token annotation punctuation">@EqualsAndHashCode</span><span class="token annotation punctuation">@ToString</span><span class="token annotation punctuation">@Getter</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="11-多对一"><a href="#11-多对一" class="headerlink" title="11.多对一"></a>11.多对一</h2><ul><li>多个学生对应一个老师</li></ul><h3 id="11-1按照查询嵌套处理"><a href="#11-1按照查询嵌套处理" class="headerlink" title="11.1按照查询嵌套处理"></a>11.1按照查询嵌套处理</h3><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>mapper</span> <span class="token attr-name">namespace</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.kuang.dao.StudentMapper<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>getStudent<span class="token punctuation">"</span></span> <span class="token attr-name">resultMap</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>StudentTeacher<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>        select * from student    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>resultMap</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>StudentTeacher<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.kuang.pojo.Student<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token comment">&lt;!--        对象使用association--&gt;</span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>association</span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>teacher<span class="token punctuation">"</span></span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>tid<span class="token punctuation">"</span></span> <span class="token attr-name">javaType</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.kuang.pojo.Teacher<span class="token punctuation">"</span></span> <span class="token attr-name">select</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>getTeacher<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>resultMap</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>getTeacher<span class="token punctuation">"</span></span> <span class="token attr-name">resultType</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.kuang.pojo.Teacher<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>        select * from teacher where id = #{id}    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>mapper</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="11-2-按照结果嵌套查询"><a href="#11-2-按照结果嵌套查询" class="headerlink" title="11.2 按照结果嵌套查询"></a>11.2 按照结果嵌套查询</h3><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>getStudent2<span class="token punctuation">"</span></span> <span class="token attr-name">resultMap</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>StudentTeacher2<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>        select s.id sid, s.name sname, t.name tname from student s, teacher t where s.tid = t.id;    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>resultMap</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>StudentTeacher2<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.kuang.pojo.Student<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>        <span class="token comment">&lt;!--        对象使用association--&gt;</span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>result</span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>id<span class="token punctuation">"</span></span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>sid<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>result</span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>name<span class="token punctuation">"</span></span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>sname<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>association</span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>teacher<span class="token punctuation">"</span></span> <span class="token attr-name">javaType</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.kuang.pojo.Teacher<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>result</span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>name<span class="token punctuation">"</span></span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>tname<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>association</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>resultMap</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="11-3-一对多处理"><a href="#11-3-一对多处理" class="headerlink" title="11.3 一对多处理"></a>11.3 一对多处理</h3><p>同上，其实是类似的</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>javaType &amp;&amp; ofType</p><p>javaType 用来指定实体类中的属性的类型</p><p>ofType用来指定映射到List或集合中的pojo类型，泛型中的约束类型。</p><h2 id="12-动态SQL"><a href="#12-动态SQL" class="headerlink" title="12. 动态SQL"></a>12. 动态SQL</h2><p>动态SQL根据不同的条件生成不同的sql语句。</p><ul><li>if</li></ul><h3 id="if"><a href="#if" class="headerlink" title="if"></a>if</h3><p>使用动态 SQL 最常见情景是根据条件包含 where 子句的一部分。比如：</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>findActiveBlogWithTitleLike<span class="token punctuation">"</span></span>        <span class="token attr-name">resultType</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>Blog<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    SELECT * FROM BLOG    WHERE state = ‘ACTIVE’    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>if</span> <span class="token attr-name">test</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>title != null<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>        AND title like #{title}    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>if</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>choose (when, otherwise)</li></ul><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>findActiveBlogLike<span class="token punctuation">"</span></span>     <span class="token attr-name">resultType</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>Blog<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  SELECT * FROM BLOG WHERE state = ‘ACTIVE’  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>choose</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>when</span> <span class="token attr-name">test</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>title != null<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>      AND title like #{title}    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>when</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>when</span> <span class="token attr-name">test</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>author != null and author.name != null<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>      AND author_name like #{author.name}    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>when</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>otherwise</span><span class="token punctuation">&gt;</span></span>      AND featured = 1    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>otherwise</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>choose</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>trim (where, set)</li></ul><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>findActiveBlogLike<span class="token punctuation">"</span></span>     <span class="token attr-name">resultType</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>Blog<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  SELECT * FROM BLOG  WHERE  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>if</span> <span class="token attr-name">test</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>state != null<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    state = #{state}  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>if</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>if</span> <span class="token attr-name">test</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>title != null<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    AND title like #{title}  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>if</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>if</span> <span class="token attr-name">test</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>author != null and author.name != null<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    AND author_name like #{author.name}  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>if</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意，set语句别忘了后面加,</p><h3 id="SQL片段"><a href="#SQL片段" class="headerlink" title="SQL片段"></a>SQL片段</h3><ol><li>使用SQL标签抽取公共的部分</li></ol><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>sql</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>if-title-author<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>if</span> <span class="token attr-name">test</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>title != null<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>        title = #{title}    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>if</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>if</span> <span class="token attr-name">test</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>author != null<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>        author = #{author}    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>if</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>sql</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li>在需要的地方使用incllude标签引用即可</li></ol><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>queryBlogIF<span class="token punctuation">"</span></span> <span class="token attr-name">parameterType</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>map<span class="token punctuation">"</span></span> <span class="token attr-name">resultType</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.kuang.pojo.Blog<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    select * from mybatis.blog    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>where</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>include</span> <span class="token attr-name">refid</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>if-title-author<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>include</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>where</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>foreach</li></ul><p>是对一个集合进行遍历，通常构建IN条件语句的时候。</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>selectPostIn<span class="token punctuation">"</span></span> <span class="token attr-name">resultType</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>domain.blog.Post<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  SELECT *  FROM POST P  WHERE ID in  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>foreach</span> <span class="token attr-name">item</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>item<span class="token punctuation">"</span></span> <span class="token attr-name">index</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>index<span class="token punctuation">"</span></span> <span class="token attr-name">collection</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>list<span class="token punctuation">"</span></span>      <span class="token attr-name">open</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>(<span class="token punctuation">"</span></span> <span class="token attr-name">separator</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>,<span class="token punctuation">"</span></span> <span class="token attr-name">close</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>)<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>        #{item}  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>foreach</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="13-缓存"><a href="#13-缓存" class="headerlink" title="13. 缓存"></a>13. 缓存</h2><pre class="line-numbers language-none"><code class="language-none">查询 ： 连接数据库，耗费资源！一次查询的结果，给他暂时存在一个直接取到的地方！--&gt; 内存： 缓存我们再次查询相同数据的时候，直接走缓存，就不用走数据库了。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ol><li>什么是缓存？<ul><li>放在内存中的临时数据</li><li>将用户经常查的数据放在内存中可以提高性能。</li></ul></li></ol><ul><li><p>Mybatis默认两级缓存，默认一级缓存。</p></li><li><p>二级缓存需要手动开启配置。他是基于namespace级别的缓存。</p></li><li><p>为了提高扩展性，MyBatis定义了缓存接口Cache。我们可以通过Cache接口自定义二级缓存。</p></li></ul><h3 id="13-1-一级缓存"><a href="#13-1-一级缓存" class="headerlink" title="13.1 一级缓存"></a>13.1 一级缓存</h3><p>一级缓存也叫本地会话缓存。</p><ul><li>与数据库同一次会话期间查询到的数据会放在本地缓存中。</li><li>以后如果需要获取相同的数据，直接从缓存中拿，没必须再去查询数据库。</li></ul><p>缓存失效的情况：</p><ol><li>所有增删改都要缓冲失效。（增删改有可能会改变数据，所以缓存需要失效）</li><li>查询不同的mapper.xml</li><li>查询不同的数据。</li><li>手动清理缓存。</li></ol><p>小结：一级缓存默认是开启的，只在一次SqlSession中有效，也就是拿到连接到关闭连接。</p><h3 id="13-2-二级缓存"><a href="#13-2-二级缓存" class="headerlink" title="13.2 二级缓存"></a>13.2 二级缓存</h3><ul><li>工作机制<ul><li>一个会话查询一条数据，这个数据就会被放在当前会话的一级缓存中。</li><li>如果当前会话关闭，这个会话对应的一级缓存就没了。但是我们希望会话关闭了，一级缓存中的数据被保存到二级缓存中。</li><li>新的会话查询信息，就可以从二级缓存中获取内容。</li><li>不同的mapper查出的数据会放在自己的缓存map中。</li></ul></li></ul><ol start="2"><li>缓存清除策略</li></ol><ul><li>LRU 最近最少使用</li><li>FIFO 先进先出</li><li>SOFT 软引用</li><li>WEAK 弱引用，更积极地基于垃圾收集器状态和弱引用规则移除对象。</li></ul><p>步骤：</p><ol><li>开启全局缓存。<code>cacheEnabled = true</code></li></ol><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>setting</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>cacheEnabled<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="2"><li><p>在Mapper.xml中加入</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>cache</span><span class="token punctuation">/&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol><h3 id="13-3-缓存原理"><a href="#13-3-缓存原理" class="headerlink" title="13.3 缓存原理"></a>13.3 缓存原理</h3><p>再次查询时会先找二级缓存，再一级，如果两个都没有对应的数据，再从数据库中找。</p><h3 id="13-4-自定义缓存ehcache"><a href="#13-4-自定义缓存ehcache" class="headerlink" title="13.4 自定义缓存ehcache"></a>13.4 自定义缓存ehcache</h3><h1 id="面试部分"><a href="#面试部分" class="headerlink" title="面试部分"></a>面试部分</h1><h2 id="1-一部分"><a href="#1-一部分" class="headerlink" title="1. 一部分"></a>1. 一部分</h2><h3 id="1-1-和jdbc的区别"><a href="#1-1-和jdbc的区别" class="headerlink" title="1.1 和jdbc的区别"></a>1.1 和jdbc的区别</h3><p>jdbc是java提供的操作数据库的API。</p><p>mybatis消除了几乎所有的JDBC代码和参数的手工设置以及对应的结果集的检索封装。</p><p>mybatis是对JDBC的封装，相对于JDBC，Mybatis有以下优点：</p><ol><li>优化获取和释放</li><li>SQL统一管理，对数据库进行存取操作。</li><li>生成动态SQL语句</li><li>能够对结果集进行映射</li></ol><h3 id="1-2-为什么是半自动ORM映射工具？"><a href="#1-2-为什么是半自动ORM映射工具？" class="headerlink" title="1.2 为什么是半自动ORM映射工具？"></a>1.2 为什么是半自动ORM映射工具？</h3><ul><li><p>Hibernate 属于全自动ORM映射工具，使用Hibernate查询关联对象或者关联集合对象时，可以根据对象关系模型直接获取，所以它是全自动的。</p></li><li><p>mybatis在查询关联对象时需要手动编写sql来完成，所以是半自动ORM映射工具。</p></li></ul><h3 id="1-3-一个xml映射文件，都会有一个Dao接口与之对应。dao接口工作原理以及dao的方法参数不同是否能够重载？"><a href="#1-3-一个xml映射文件，都会有一个Dao接口与之对应。dao接口工作原理以及dao的方法参数不同是否能够重载？" class="headerlink" title="1.3 一个xml映射文件，都会有一个Dao接口与之对应。dao接口工作原理以及dao的方法参数不同是否能够重载？"></a>1.3 一个xml映射文件，都会有一个Dao接口与之对应。dao接口工作原理以及dao的方法参数不同是否能够重载？</h3><ul><li>Dao接口，就是常说的Mapper接口，接口的全限名，就是映射文件中的namespace值，接口的方法名，就是映射文件中的MappedStatement的id值，接口方法内的参数就是传递给sql的参数。</li><li>Mapper接口是没有实现类的，当调用接口方法时，接口全限名+方法名拼装字符串作为key值，可以唯一定位一个MappedStatement。</li></ul><p>Dao接口的工作原理是JDK动态代理，mybatis运行时会使用JDK动态代理为Dao接口生成代理proxy对象，代理对象proxy会拦截接口方法，转而执行MappedStatement所代表的sql，然后将sql执行结果返回。</p><p>原理可以参考：[<a href="https://www.cnblogs.com/soundcode/p/6497291.html">MyBatis]DAO层只写接口，不用写实现类 - 左正 - 博客园 (cnblogs.com)</a></p><h3 id="1-4-和ibatis比较大的几个改进？"><a href="#1-4-和ibatis比较大的几个改进？" class="headerlink" title="1.4 和ibatis比较大的几个改进？"></a>1.4 和ibatis比较大的几个改进？</h3><ol><li>有接口绑定，包括注解绑定sql和xml绑定sql。</li><li>动态sql由原来的节点配置编程了OGNL表达式。</li><li>在一对一，一对多的时候引进了association，在一对多的时候引入了collection节点，不过都是在resultMap里面配置</li></ol><h3 id="1-5-接口绑定有几种实现方式，分别如何实现？"><a href="#1-5-接口绑定有几种实现方式，分别如何实现？" class="headerlink" title="1.5 接口绑定有几种实现方式，分别如何实现？"></a>1.5 接口绑定有几种实现方式，分别如何实现？</h3><ol><li>通过xml。指定xml映射文件里面的namespace必须为接口的全路径名。</li><li>通过注解。通过在接口的方法上添加@select等注解。</li></ol><h3 id="1-6-mybatis如何进行分页？分页插件原理？"><a href="#1-6-mybatis如何进行分页？分页插件原理？" class="headerlink" title="1.6 mybatis如何进行分页？分页插件原理？"></a>1.6 mybatis如何进行分页？分页插件原理？</h3><p>使用<code>RowBounds</code>对象进行分页，它是针对ResultSet结果集执行的内存分页，而非物理分页，可以在sql内直接书写带有物理分页的参数来完成物理分页，也可以使用分页插件来完成物理分页。</p><p>分页插件的基本原理是使用Mybatis提供的插件接口，实现自定义插件，在插件的拦截方法内拦截执行的sql，然后重写sql，根据dialect方言，添加对应的物理分页语句和物理分页参数。</p><h3 id="1-7-Mybatis动态sql是做什么的？都有哪些动态sql？能简述一下动态sql的执行原理不？"><a href="#1-7-Mybatis动态sql是做什么的？都有哪些动态sql？能简述一下动态sql的执行原理不？" class="headerlink" title="1.7 Mybatis动态sql是做什么的？都有哪些动态sql？能简述一下动态sql的执行原理不？"></a>1.7 Mybatis动态sql是做什么的？都有哪些动态sql？能简述一下动态sql的执行原理不？</h3><ul><li>Mybatis动态sql可以让我们在Xml映射文件内，<strong>以标签的形式编写动态sql，完成逻辑判断和动态拼接sql的功能</strong>。</li><li>Mybatis提供了9种动态sql标签：trim|where|set|foreach|if|choose|when|otherwise|bind。</li><li>其执行原理为，使用OGNL从sql参数对象中计算表达式的值，<strong>根据表达式的值动态拼接sql，以此来完成动态sql的功能</strong>。</li></ul><h3 id="1-8-Mybatis的Xml映射文件中，不同的Xml映射文件，id是否可以重复？"><a href="#1-8-Mybatis的Xml映射文件中，不同的Xml映射文件，id是否可以重复？" class="headerlink" title="1.8 Mybatis的Xml映射文件中，不同的Xml映射文件，id是否可以重复？"></a>1.8 Mybatis的Xml映射文件中，不同的Xml映射文件，id是否可以重复？</h3><p><strong>如果配置了namespace那么当然是可以重复的，因为我们的Statement实际上就是namespace+id</strong>。</p><p>如果没有配置namespace的话，那么相同的id就会导致覆盖了。</p><h3 id="2-二部分"><a href="#2-二部分" class="headerlink" title="2. 二部分"></a>2. 二部分</h3><p>参考至：<a href="https://blog.csdn.net/ThinkWon/article/details/101292950">MyBatis面试题（2020最新版）_ThinkWon的博客-CSDN博客_mybatis面试题</a></p><h3 id="2-1-MyBatis编程步骤是什么样的？"><a href="#2-1-MyBatis编程步骤是什么样的？" class="headerlink" title="2.1 MyBatis编程步骤是什么样的？"></a>2.1 MyBatis编程步骤是什么样的？</h3><p>1、 创建SqlSessionFactory</p><p>2、 通过SqlSessionFactory创建SqlSession</p><p>3、 通过sqlsession执行数据库操作</p><p>4、 调用session.commit()提交事务</p><p>5、 调用session.close()关闭会话</p><h3 id="2-2-mybatis工作原理"><a href="#2-2-mybatis工作原理" class="headerlink" title="2.2 mybatis工作原理"></a>2.2 mybatis工作原理</h3><p><img src="/2021/05/24/mybatis/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL0pvdXJXb24vaW1hZ2UvbWFzdGVyL015QmF0aXMlRTYlQTElODYlRTYlOUUlQjYlRTYlODAlQkIlRTclQkIlOTMvTXlCYXRpcyVFNSVCNyVBNSVFNCVCRCU5QyVFNSU4RSU5RiVFNyU5MCU4Ni5wbmc" alt="MyBatis工作原理"></p><p>1）读取 MyBatis 配置文件：mybatis-config.xml 为 MyBatis 的全局配置文件，配置了 MyBatis 的运行环境等信息，例如数据库连接信息。</p><p>2）加载映射文件。映射文件即 SQL 映射文件，该文件中配置了操作数据库的 SQL 语句，需要在 MyBatis 配置文件 mybatis-config.xml 中加载。mybatis-config.xml 文件可以加载多个映射文件，每个文件对应数据库中的一张表。</p><p>3）构造会话工厂：通过 MyBatis 的环境等配置信息构建会话工厂 SqlSessionFactory。</p><p>4）创建会话对象：由会话工厂创建 SqlSession 对象，该对象中包含了执行 SQL 语句的所有方法。</p><p>5）Executor 执行器：MyBatis 底层定义了一个 Executor 接口来操作数据库，它将根据 SqlSession 传递的参数动态地生成需要执行的 SQL 语句，同时负责查询缓存的维护。</p><p>6）MappedStatement 对象：在 Executor 接口的执行方法中有一个 MappedStatement 类型的参数，该参数是对映射信息的封装，用于存储要映射的 SQL 语句的 id、参数等信息。</p><p>7）输入参数映射：输入参数类型可以是 Map、List 等集合类型，也可以是基本数据类型和 POJO 类型。输入参数映射过程类似于 JDBC 对 preparedStatement 对象设置参数的过程。</p><p>8）输出结果映射：输出结果类型可以是 Map、 List 等集合类型，也可以是基本数据类型和 POJO 类型。输出结果映射过程类似于 JDBC 对结果集的解析过程。</p><h3 id="2-3-Mybatis都有哪些Executor执行器？它们之间的区别是什么？"><a href="#2-3-Mybatis都有哪些Executor执行器？它们之间的区别是什么？" class="headerlink" title="2.3 Mybatis都有哪些Executor执行器？它们之间的区别是什么？"></a>2.3 Mybatis都有哪些Executor执行器？它们之间的区别是什么？</h3><p>Mybatis有三种基本的Executor执行器，SimpleExecutor、ReuseExecutor、BatchExecutor。</p><p><code>SimpleExecutor</code>：每执行一次update或select，就开启一个Statement对象，用完立刻关闭Statement对象。</p><p><code>ReuseExecutor</code>：执行update或select，以sql作为key查找Statement对象，存在就使用，不存在就创建，用完后，不关闭Statement对象，而是放置于Map&lt;String, Statement&gt;内，供下一次使用。简言之，就是重复使用Statement对象。</p><p><code>BatchExecutor</code>：执行update（没有select，JDBC批处理不支持select），将所有sql都添加到批处理中（addBatch()），等待统一执行（executeBatch()），它缓存了多个Statement对象，每个Statement对象都是addBatch()完毕后，等待逐一执行executeBatch()批处理。与JDBC批处理相同。</p><p>作用范围：Executor的这些特点，都严格限制在SqlSession生命周期范围内。</p><h3 id="1-4-Mybatis是否支持延迟加载？如果支持，它的实现原理是什么？"><a href="#1-4-Mybatis是否支持延迟加载？如果支持，它的实现原理是什么？" class="headerlink" title="1.4 Mybatis是否支持延迟加载？如果支持，它的实现原理是什么？"></a>1.4 Mybatis是否支持延迟加载？如果支持，它的实现原理是什么？</h3><p>Mybatis仅支持association关联对象和collection关联集合对象的延迟加载，association指的就是一对一，collection指的就是一对多查询。在Mybatis配置文件中，可以配置是否启用延迟加载lazyLoadingEnabled=true|false。</p><p>它的原理是，使用CGLIB创建目标对象的代理对象，当调用目标方法时，进入拦截器方法，比如调用a.getB().getName()，拦截器invoke()方法发现a.getB()是null值，那么就会单独发送事先保存好的查询关联B对象的sql，把B查询上来，然后调用a.setB(b)，于是a的对象b属性就有值了，接着完成a.getB().getName()方法的调用。这就是延迟加载的基本原理。</p><p>当然了，不光是Mybatis，几乎所有的包括Hibernate，支持延迟加载的原理都是一样的。</p><h3 id="2-5-和-的区别"><a href="#2-5-和-的区别" class="headerlink" title="2.5 #{}和${}的区别"></a>2.5 #{}和${}的区别</h3><p>#{}是占位符，预编译处理；${}是拼接符，字符串替换，没有预编译处理。</p><ol><li><p>Mybatis在处理#{}时，#{}传入参数是以字符串传入，会将SQL中的#{}替换为?号，调用PreparedStatement的set方法来赋值。</p></li><li><p>Mybatis在处理时 ， 是 原 值 传 入 ， 就 是 把 {}时，是原值传入，就是把时，是原值传入，就是把{}替换成变量的值，相当于JDBC中的Statement编译</p></li><li><p>变量替换后，#{} 对应的变量自动加上单引号 ‘’；变量替换后，${} 对应的变量不会加上单引号 ‘’</p></li><li><p>#{} 可以有效的防止SQL注入，提高系统安全性；${} 不能防止SQL 注入</p></li><li><p>#{} 的变量替换是在DBMS 中；${} 的变量替换是在 DBMS 外</p></li></ol><h3 id="2-6-Mapper-编写有哪几种方式？"><a href="#2-6-Mapper-编写有哪几种方式？" class="headerlink" title="2.6 Mapper 编写有哪几种方式？"></a>2.6 Mapper 编写有哪几种方式？</h3><p>第一种：接口实现类继承 SqlSessionDaoSupport：使用此种方法需要编写mapper 接口，mapper 接口实现类、mapper.xml 文件。</p><p>（1）在 sqlMapConfig.xml 中配置 mapper.xml 的位置</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>mappers</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>mapper</span> <span class="token attr-name">resource</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>mapper.xml 文件的地址<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>mapper</span> <span class="token attr-name">resource</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>mapper.xml 文件的地址<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>mappers</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>（2）定义 mapper 接口</p><p>（3）实现类集成 SqlSessionDaoSupport</p><p>mapper 方法中可以 this.getSqlSession()进行数据增删改查。</p><p>（4）spring 配置</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span> <span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>mapper 接口的实现<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>sqlSessionFactory<span class="token punctuation">"</span></span>    <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>sqlSessionFactory<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>第二种：使用 org.mybatis.spring.mapper.MapperFactoryBean：</p><p>（1）在 sqlMapConfig.xml 中配置 mapper.xml 的位置，如果 mapper.xml 和mappre 接口的名称相同且在同一个目录，这里可以不用配置。</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>mappers</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>mapper</span> <span class="token attr-name">resource</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>mapper.xml 文件的地址<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>mapper</span> <span class="token attr-name">resource</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>mapper.xml 文件的地址<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>mappers</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>（2）定义 mapper 接口：</p><p>（3）mapper.xml 中的 namespace 为 mapper 接口的地址</p><p>（4）mapper 接口中的方法名和 mapper.xml 中的定义的 statement 的 id 保持一致</p><p>（5）Spring 中定义</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span><span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>org.mybatis.spring.mapper.MapperFactoryBean<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>mapperInterface<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>mapper 接口地址<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>sqlSessionFactory<span class="token punctuation">"</span></span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>sqlSessionFactory<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>第三种：使用 mapper 扫描器：</p><p>（1）mapper.xml 文件编写：</p><p>mapper.xml 中的 namespace 为 mapper 接口的地址；</p><p>mapper 接口中的方法名和 mapper.xml 中的定义的 statement 的 id 保持一致；</p><p>如果将 mapper.xml 和 mapper 接口的名称保持一致则不用在 sqlMapConfig.xml中进行配置。</p><p>（2）定义 mapper 接口：</p><p>注意 mapper.xml 的文件名和 mapper 的接口名称保持一致，且放在同一个目录</p><p>（3）配置 mapper 扫描器：</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>org.mybatis.spring.mapper.MapperScannerConfigurer<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>basePackage<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>mapper 接口包地址    <span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>sqlSessionFactoryBeanName<span class="token punctuation">"</span></span>    <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>sqlSessionFactory<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-7-使用扫描器后从-spring-容器中获取-mapper-的实现对象。"><a href="#2-7-使用扫描器后从-spring-容器中获取-mapper-的实现对象。" class="headerlink" title="2.7 使用扫描器后从 spring 容器中获取 mapper 的实现对象。"></a>2.7 使用扫描器后从 spring 容器中获取 mapper 的实现对象。</h3><p>简述Mybatis的Xml映射文件和Mybatis内部数据结构之间的映射关系？<br>答：Mybatis将所有Xml配置信息都封装到All-In-One重量级对象Configuration内部。在Xml映射文件中，<parametermap>标签会被解析为ParameterMap对象，其每个子元素会被解析为ParameterMapping对象。<resultmap>标签会被解析为ResultMap对象，其每个子元素会被解析为ResultMapping对象。每一个<select>、、、标签均会被解析为MappedStatement对象，标签内的sql会被解析为BoundSql对象。</select></resultmap></parametermap></p><h3 id="2-8-缓存"><a href="#2-8-缓存" class="headerlink" title="2.8 缓存"></a>2.8 缓存</h3><p>Mybatis的一级、二级缓存<br>1）一级缓存: 基于 PerpetualCache 的 HashMap 本地缓存，其存储作用域为 Session，当 Session flush 或 close 之后，该 Session 中的所有 Cache 就将清空，默认打开一级缓存。</p><p>2）二级缓存与一级缓存其机制相同，默认也是采用 PerpetualCache，HashMap 存储，不同在于其存储作用域为 Mapper(Namespace)，并且可自定义存储源，如 Ehcache。默认不打开二级缓存，要开启二级缓存，使用二级缓存属性类需要实现Serializable序列化接口(可用来保存对象的状态),可在它的映射文件中配置<cache> ；</cache></p><p>3）对于缓存数据更新机制，当某一个作用域(一级缓存 Session/二级缓存Namespaces)的进行了C/U/D 操作后，默认该作用域下所有 select 中的缓存将被 clear。</p><p><a href="https://segmentfault.com/a/1190000038544664">彻底搞明白mybatis缓存（上） - SegmentFault 思否</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2021/05/24/springmvc/"/>
      <url>2021/05/24/springmvc/</url>
      
        <content type="html"><![CDATA[<h1 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a>SpringMVC</h1><ol><li><p>模型 dao service 数据模型，提供要展示的数据，他们的行为由service提供。</p></li><li><p>视图 jsp</p></li><li><p>控制器 Servlet：（转发，重定向）接收用户请求，委托给模型进行处理（状态改变），处理完毕后把返回的模型数据返回给视图，由视图负责展示。控制器做了调度员的工作。</p></li></ol><p>它是一种软件设计规范。将业务逻辑、数据和显示分离。</p><h2 id="1-创建项目"><a href="#1-创建项目" class="headerlink" title="1 创建项目"></a>1 创建项目</h2><ul><li>导入依赖：junit,数据库驱动，连接池，servlet,jsp,mybatis,mybatis-spring,spring</li></ul><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>junit<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>junit<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>4.12<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>scope</span><span class="token punctuation">&gt;</span></span>test<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>scope</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>mysql<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>mysql-connector-java<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>5.1.46<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>com.mchange<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>c3p0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>0.9.5.4<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>javax.servlet<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>servlet-api<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>2.5<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>javax.servlet.jsp<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>jsp-api<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>2.2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-webmvc<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>5.2.4.RELEASE<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>web.xml下的：</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>web-app</span> <span class="token attr-name">xmlns</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://xmlns.jcp.org/xml/ns/javaee<span class="token punctuation">"</span></span>         <span class="token attr-name"><span class="token namespace">xmlns:</span>xsi</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.w3.org/2001/XMLSchema-instance<span class="token punctuation">"</span></span>         <span class="token attr-name"><span class="token namespace">xsi:</span>schemaLocation</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd<span class="token punctuation">"</span></span>         <span class="token attr-name">version</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>4.0<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token comment">&lt;!--    配置DispatchServlet：这是SpringMVC的核心--&gt;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>servlet</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>servlet-name</span><span class="token punctuation">&gt;</span></span>SpringMVC<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>servlet-name</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>servlet-class</span><span class="token punctuation">&gt;</span></span>org.springframework.web.servlet.DispatcherServlet<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>servlet-class</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>init-param</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>param-name</span><span class="token punctuation">&gt;</span></span>contextConfigLocation<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>param-name</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>param-value</span><span class="token punctuation">&gt;</span></span>classpath:springmvc-servlet.xml<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>param-value</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>init-param</span><span class="token punctuation">&gt;</span></span>        <span class="token comment">&lt;!--        启动级别--&gt;</span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>load-on-startup</span><span class="token punctuation">&gt;</span></span>1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>load-on-startup</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>servlet</span><span class="token punctuation">&gt;</span></span>    <span class="token comment">&lt;!--    在springmvc / 和 /* 有区别    / 只匹配所有请求，不会匹配jsp页面，一般写/就可以了    /* 匹配所有请求，包括jsp    --&gt;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>servlet-mapping</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>servlet-name</span><span class="token punctuation">&gt;</span></span>SpringMVC<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>servlet-name</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>url-pattern</span><span class="token punctuation">&gt;</span></span>/<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>url-pattern</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>servlet-mapping</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>web-app</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>servlet configuration配置文件：</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>beans</span> <span class="token attr-name">xmlns</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/beans<span class="token punctuation">"</span></span>       <span class="token attr-name"><span class="token namespace">xmlns:</span>xsi</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.w3.org/2001/XMLSchema-instance<span class="token punctuation">"</span></span>       <span class="token attr-name"><span class="token namespace">xmlns:</span>context</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/context<span class="token punctuation">"</span></span>       <span class="token attr-name"><span class="token namespace">xmlns:</span>mvc</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/mvc<span class="token punctuation">"</span></span>       <span class="token attr-name"><span class="token namespace">xsi:</span>schemaLocation</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/beans       https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">context:</span>component-scan</span> <span class="token attr-name">base-package</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.kuang.controller<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">mvc:</span>default-servlet-handler</span><span class="token punctuation">/&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">mvc:</span>annotation-driven</span><span class="token punctuation">/&gt;</span></span><span class="token comment">&lt;!--    支持mvc注解驱动        在spring中一般采用@RequestMapping注解来完成映射关系        要想使@RequestMapping注解生效        必须向上下文注册DefaultAnnotationHandlerMapping        和一个AnnotationMethodHandlerAdapter实例        这两个实例分别在类同级别和方法级别处理。        而annotation-driven配置帮助我们自动完成上述两个实例的注入。--&gt;</span><span class="token comment">&lt;!--    视图解析器--&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>org.springframework.web.servlet.view.InternalResourceViewResolver<span class="token punctuation">"</span></span>      <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>internalResourceViewResolver<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>prefix<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>/WEB-INF/jsp/<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>suffix<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>.jsp<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>beans</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-Controller及RestFul风格"><a href="#2-Controller及RestFul风格" class="headerlink" title="2. Controller及RestFul风格"></a>2. Controller及RestFul风格</h2><h3 id="1-控制器Controller"><a href="#1-控制器Controller" class="headerlink" title="1.控制器Controller"></a>1.控制器Controller</h3><ul><li>控制器复杂提供访问应用程序的行为，通常通过接口定义或注解定义两种方法实现。</li><li>控制器负责解析用户的请求并将其转换为一个模型。</li><li>在SpringMVC中一个控制器类可以包含多个方法。</li><li>在SpringMVC中，对于controller的配置方式有很多种。</li></ul><h3 id="2-实现Controller接口"><a href="#2-实现Controller接口" class="headerlink" title="2. 实现Controller接口"></a>2. 实现Controller接口</h3><p><code>Controller</code>是一个接口，在<code>org.springframework.web.servlet.mvc</code>包下，接口中只有一个方法。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@FunctionalInterface</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Controller</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Nullable</span>    <span class="token class-name">ModelAndView</span> <span class="token function">handleRequest</span><span class="token punctuation">(</span><span class="token class-name">HttpServletRequest</span> var1<span class="token punctuation">,</span> <span class="token class-name">HttpServletResponse</span> var2<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-注解-Controller"><a href="#3-注解-Controller" class="headerlink" title="3. 注解@Controller"></a>3. 注解@Controller</h3><p>在类加上<code>@Controller</code>, 方法加上<code>RequestMapping("/hello")</code>(“/hello”是起的名字)。</p><h3 id="4-RequestMapping"><a href="#4-RequestMapping" class="headerlink" title="4.RequestMapping"></a>4.RequestMapping</h3><p><strong>@RequestMapping</strong></p><ul><li><p>@RequestMapping注解用于映射url到控制器类或一个特定的处理程序方法。可用于类或方法上。用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。</p></li><li><p>只注解在方法上面</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Controller</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestController</span> <span class="token punctuation">{</span>   <span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">"/h1"</span><span class="token punctuation">)</span>   <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>       <span class="token keyword">return</span> <span class="token string">"test"</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>访问路径：<a href="http://localhost:8080/">http://localhost:8080</a> / 项目名 / h1</p></li><li><p>同时注解类与方法</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Controller</span><span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">"/admin"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestController</span> <span class="token punctuation">{</span>   <span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">"/h1"</span><span class="token punctuation">)</span>   <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>       <span class="token keyword">return</span> <span class="token string">"test"</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>访问路径：<a href="http://localhost:8080/">http://localhost:8080</a> / 项目名/ admin /h1  , 需要先指定类的路径再指定方法的路径；</p></li></ul><h3 id="5-RestFul风格"><a href="#5-RestFul风格" class="headerlink" title="5. RestFul风格"></a>5. RestFul风格</h3><p>RestFul风格就是一个资源定位及资源操作的风格。不是标准也不是协议，只是一种风格。基于这个风格设计的软件可以更简洁，更有层次，更易于实现缓存等机制。</p><p>通过不同的请求方式来实现不同的效果！</p><h4 id="5-1-作用"><a href="#5-1-作用" class="headerlink" title="5.1 作用"></a>5.1 作用</h4><p>安全 统一 高效</p><p><strong>传统方式操作资源</strong>  ：通过不同的参数来实现不同的效果！方法单一，post 和 get</p><p>​    <a href="http://127.0.0.1/item/queryItem.action?id=1">http://127.0.0.1/item/queryItem.action?id=1</a> 查询,GET</p><p>​    <a href="http://127.0.0.1/item/saveItem.action">http://127.0.0.1/item/saveItem.action</a> 新增,POST</p><p>​    <a href="http://127.0.0.1/item/updateItem.action">http://127.0.0.1/item/updateItem.action</a> 更新,POST</p><p>​    <a href="http://127.0.0.1/item/deleteItem.action?id=1">http://127.0.0.1/item/deleteItem.action?id=1</a> 删除,GET或POST</p><p><strong>使用RESTful操作资源</strong> ：可以通过不同的请求方式来实现不同的效果！如下：请求地址一样，但是功能可以不同！</p><p>​    <a href="http://127.0.0.1/item/1">http://127.0.0.1/item/1</a> 查询,GET</p><p>​    <a href="http://127.0.0.1/item">http://127.0.0.1/item</a> 新增,POST</p><p>​    <a href="http://127.0.0.1/item">http://127.0.0.1/item</a> 更新,PUT</p><p>​    <a href="http://127.0.0.1/item/1">http://127.0.0.1/item/1</a> 删除,DELETE</p><h3 id="5-2-测试"><a href="#5-2-测试" class="headerlink" title="5.2 测试"></a>5.2 测试</h3><ol><li><p>在新建一个类 RestFulController</p><pre class="line-numbers language-none"><code class="language-none">@Controllerpublic class RestFulController {}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>在Spring MVC中可以使用  @PathVariable 注解，让方法参数的值对应绑定到一个URI模板变量上。</p><pre class="line-numbers language-none"><code class="language-none">@Controllerpublic class RestFulController {   //映射访问路径   @RequestMapping("/commit/{p1}/{p2}")   public String index(@PathVariable int p1, @PathVariable int p2, Model model){              int result = p1+p2;       //Spring MVC会自动实例化一个Model对象用于向视图中传值       model.addAttribute("msg", "结果："+result);       //返回视图位置       return "test";         }   }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>我们来测试请求查看下</p></li></ol><p><img src="/2021/05/24/springmvc/restfultest.PNG"></p><p><strong>使用method属性指定请求类型</strong></p><p>用于约束请求的类型，可以收窄请求范围。指定请求谓词的类型如GET, POST, HEAD, OPTIONS, PUT, PATCH, DELETE, TRACE等</p><p>我们来测试一下：</p><ul><li><p>增加一个方法</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//映射访问路径,必须是POST请求</span><span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"/hello"</span><span class="token punctuation">,</span>method <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token class-name">RequestMethod</span><span class="token punctuation">.</span>POST<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">index2</span><span class="token punctuation">(</span><span class="token class-name">Model</span> model<span class="token punctuation">)</span><span class="token punctuation">{</span>   model<span class="token punctuation">.</span><span class="token function">addAttribute</span><span class="token punctuation">(</span><span class="token string">"msg"</span><span class="token punctuation">,</span> <span class="token string">"hello!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">return</span> <span class="token string">"test"</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>我们使用浏览器地址栏进行访问默认是Get请求，会报错405：</p></li></ul><p>如果将POST修改为GET则正常了；</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//映射访问路径,必须是Get请求</span><span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"/hello"</span><span class="token punctuation">,</span>method <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token class-name">RequestMethod</span><span class="token punctuation">.</span>GET<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">index2</span><span class="token punctuation">(</span><span class="token class-name">Model</span> model<span class="token punctuation">)</span><span class="token punctuation">{</span>   model<span class="token punctuation">.</span><span class="token function">addAttribute</span><span class="token punctuation">(</span><span class="token string">"msg"</span><span class="token punctuation">,</span> <span class="token string">"hello!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">return</span> <span class="token string">"test"</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>小结：</strong></p><p>Spring MVC 的 @RequestMapping 注解能够处理 HTTP 请求的方法, 比如 GET, PUT, POST, DELETE 以及 PATCH。</p><p><strong>所有的地址栏请求默认都会是 HTTP GET 类型的。</strong></p><p>方法级别的注解变体有如下几个：组合注解</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@GetMapping</span><span class="token annotation punctuation">@PostMapping</span><span class="token annotation punctuation">@PutMapping</span><span class="token annotation punctuation">@DeleteMapping</span><span class="token annotation punctuation">@PatchMapping</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>@GetMapping 是一个组合注解，平时使用的会比较多！</p><p>它所扮演的是 @RequestMapping(method =RequestMethod.GET) 的一个快捷方式。</p><h2 id="3-SpringMVC-结果跳转方式"><a href="#3-SpringMVC-结果跳转方式" class="headerlink" title="3.SpringMVC 结果跳转方式"></a>3.SpringMVC 结果跳转方式</h2><h3 id="3-1-ModelAndView"><a href="#3-1-ModelAndView" class="headerlink" title="3.1 ModelAndView"></a>3.1 ModelAndView</h3><p>设置ModelAndView对象 , 根据view的名称 , 和视图解析器跳到指定的页面 .</p><p>页面 : {视图解析器前缀} + viewName +{视图解析器后缀}</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token comment">&lt;!-- 视图解析器 --&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>org.springframework.web.servlet.view.InternalResourceViewResolver<span class="token punctuation">"</span></span>     <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>internalResourceViewResolver<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>   <span class="token comment">&lt;!-- 前缀 --&gt;</span>   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>prefix<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>/WEB-INF/jsp/<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>   <span class="token comment">&lt;!-- 后缀 --&gt;</span>   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>suffix<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>.jsp<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对应的controller类</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ControllerTest1</span> <span class="token keyword">implements</span> <span class="token class-name">Controller</span> <span class="token punctuation">{</span>   <span class="token keyword">public</span> <span class="token class-name">ModelAndView</span> <span class="token function">handleRequest</span><span class="token punctuation">(</span><span class="token class-name">HttpServletRequest</span> httpServletRequest<span class="token punctuation">,</span> <span class="token class-name">HttpServletResponse</span> httpServletResponse<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>       <span class="token comment">//返回一个模型视图对象</span>       <span class="token class-name">ModelAndView</span> mv <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ModelAndView</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       mv<span class="token punctuation">.</span><span class="token function">addObject</span><span class="token punctuation">(</span><span class="token string">"msg"</span><span class="token punctuation">,</span><span class="token string">"ControllerTest1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       mv<span class="token punctuation">.</span><span class="token function">setViewName</span><span class="token punctuation">(</span><span class="token string">"test"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token keyword">return</span> mv<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-2-ServletAPI"><a href="#3-2-ServletAPI" class="headerlink" title="3.2 ServletAPI"></a>3.2 ServletAPI</h3><p>通过设置ServletAPI , 不需要视图解析器 .</p><p>1、通过HttpServletResponse进行输出</p><p>2、通过HttpServletResponse实现重定向</p><p>3、通过HttpServletResponse实现转发</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Controller</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ResultGo</span> <span class="token punctuation">{</span>   <span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">"/result/t1"</span><span class="token punctuation">)</span>   <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test1</span><span class="token punctuation">(</span><span class="token class-name">HttpServletRequest</span> req<span class="token punctuation">,</span> <span class="token class-name">HttpServletResponse</span> rsp<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">{</span>       rsp<span class="token punctuation">.</span><span class="token function">getWriter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Hello,Spring BY servlet API"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>   <span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">"/result/t2"</span><span class="token punctuation">)</span>   <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test2</span><span class="token punctuation">(</span><span class="token class-name">HttpServletRequest</span> req<span class="token punctuation">,</span> <span class="token class-name">HttpServletResponse</span> rsp<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">{</span>       rsp<span class="token punctuation">.</span><span class="token function">sendRedirect</span><span class="token punctuation">(</span><span class="token string">"/index.jsp"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>   <span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">"/result/t3"</span><span class="token punctuation">)</span>   <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test3</span><span class="token punctuation">(</span><span class="token class-name">HttpServletRequest</span> req<span class="token punctuation">,</span> <span class="token class-name">HttpServletResponse</span> rsp<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>       <span class="token comment">//转发</span>       req<span class="token punctuation">.</span><span class="token function">setAttribute</span><span class="token punctuation">(</span><span class="token string">"msg"</span><span class="token punctuation">,</span><span class="token string">"/result/t3"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       req<span class="token punctuation">.</span><span class="token function">getRequestDispatcher</span><span class="token punctuation">(</span><span class="token string">"/WEB-INF/jsp/test.jsp"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forward</span><span class="token punctuation">(</span>req<span class="token punctuation">,</span>rsp<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-3-SpringMVC"><a href="#3-3-SpringMVC" class="headerlink" title="3.3 SpringMVC"></a>3.3 SpringMVC</h3><p><strong>通过SpringMVC来实现转发和重定向 - 无需视图解析器；</strong></p><p>测试前，需要将视图解析器注释掉</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Controller</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ResultSpringMVC</span> <span class="token punctuation">{</span>   <span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">"/rsm/t1"</span><span class="token punctuation">)</span>   <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">test1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>       <span class="token comment">//转发</span>       <span class="token keyword">return</span> <span class="token string">"/index.jsp"</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>   <span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">"/rsm/t2"</span><span class="token punctuation">)</span>   <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">test2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>       <span class="token comment">//转发二</span>       <span class="token keyword">return</span> <span class="token string">"forward:/index.jsp"</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>   <span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">"/rsm/t3"</span><span class="token punctuation">)</span>   <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">test3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>       <span class="token comment">//重定向</span>       <span class="token keyword">return</span> <span class="token string">"redirect:/index.jsp"</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>通过SpringMVC来实现转发和重定向 - 有视图解析器；</strong></p><p>重定向 , 不需要视图解析器 , 本质就是重新请求一个新地方嘛 , 所以注意路径问题.</p><p>可以重定向到另外一个请求实现 .</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Controller</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ResultSpringMVC2</span> <span class="token punctuation">{</span>   <span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">"/rsm2/t1"</span><span class="token punctuation">)</span>   <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">test1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>       <span class="token comment">//转发</span>       <span class="token keyword">return</span> <span class="token string">"test"</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>   <span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">"/rsm2/t2"</span><span class="token punctuation">)</span>   <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">test2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>       <span class="token comment">//重定向</span>       <span class="token keyword">return</span> <span class="token string">"redirect:/index.jsp"</span><span class="token punctuation">;</span>       <span class="token comment">//return "redirect:hello.do"; //hello.do为另一个请求/</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4-数据处理"><a href="#4-数据处理" class="headerlink" title="4.数据处理"></a>4.数据处理</h2><h3 id="4-1处理提交数据"><a href="#4-1处理提交数据" class="headerlink" title="4.1处理提交数据"></a>4.1处理提交数据</h3><p><strong>1、提交的域名称和处理方法的参数名一致</strong></p><p>提交数据 : <a href="http://localhost:8080/hello?name=kuangshen">http://localhost:8080/hello?name=kuangshen</a></p><p>处理方法 :</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">"/hello"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">hello</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span><span class="token punctuation">{</span>   <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">return</span> <span class="token string">"hello"</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>后台输出 : kuangshen</p><p><strong>2、提交的域名称和处理方法的参数名不一致</strong></p><p>提交数据 : <a href="http://localhost:8080/hello?username=kuangshen">http://localhost:8080/hello?username=kuangshen</a></p><p>处理方法 :</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//@RequestParam("username") : username提交的域的名称 .</span><span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">"/hello"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">hello</span><span class="token punctuation">(</span><span class="token annotation punctuation">@RequestParam</span><span class="token punctuation">(</span><span class="token string">"username"</span><span class="token punctuation">)</span> <span class="token class-name">String</span> name<span class="token punctuation">)</span><span class="token punctuation">{</span>   <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">return</span> <span class="token string">"hello"</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>后台输出 : kuangshen</p><p><strong>3、提交的是一个对象</strong></p><p>要求提交的表单域和对象的属性名一致  , 参数使用对象即可</p><p>1、实体类</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">User</span> <span class="token punctuation">{</span>   <span class="token keyword">private</span> <span class="token keyword">int</span> id<span class="token punctuation">;</span>   <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>   <span class="token keyword">private</span> <span class="token keyword">int</span> age<span class="token punctuation">;</span>   <span class="token comment">//构造</span>   <span class="token comment">//get/set</span>   <span class="token comment">//tostring()</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>2、提交数据 : <a href="http://localhost:8080/mvc04/user?name=kuangshen&amp;id=1&amp;age=15">http://localhost:8080/mvc04/user?name=kuangshen&amp;id=1&amp;age=15</a></p><p>3、处理方法 :</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">"/user"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">user</span><span class="token punctuation">(</span><span class="token class-name">User</span> user<span class="token punctuation">)</span><span class="token punctuation">{</span>   <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">return</span> <span class="token string">"hello"</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>后台输出 : User { id=1, name=’kuangshen’, age=15 }</p><p>说明：如果使用对象的话，前端传递的参数名和对象名必须一致，否则就是null。</p><h3 id="4-2数据显示到前端"><a href="#4-2数据显示到前端" class="headerlink" title="4.2数据显示到前端"></a>4.2数据显示到前端</h3><p><strong>第一种 : 通过ModelAndView</strong></p><p>我们前面一直都是如此 . 就不过多解释</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ControllerTest1</span> <span class="token keyword">implements</span> <span class="token class-name">Controller</span> <span class="token punctuation">{</span>   <span class="token keyword">public</span> <span class="token class-name">ModelAndView</span> <span class="token function">handleRequest</span><span class="token punctuation">(</span><span class="token class-name">HttpServletRequest</span> httpServletRequest<span class="token punctuation">,</span> <span class="token class-name">HttpServletResponse</span> httpServletResponse<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>       <span class="token comment">//返回一个模型视图对象</span>       <span class="token class-name">ModelAndView</span> mv <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ModelAndView</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       mv<span class="token punctuation">.</span><span class="token function">addObject</span><span class="token punctuation">(</span><span class="token string">"msg"</span><span class="token punctuation">,</span><span class="token string">"ControllerTest1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       mv<span class="token punctuation">.</span><span class="token function">setViewName</span><span class="token punctuation">(</span><span class="token string">"test"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token keyword">return</span> mv<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>第二种 : 通过ModelMap</strong></p><p>ModelMap(继承了linkedhashmap)</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">"/hello"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">hello</span><span class="token punctuation">(</span><span class="token annotation punctuation">@RequestParam</span><span class="token punctuation">(</span><span class="token string">"username"</span><span class="token punctuation">)</span> <span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token class-name">ModelMap</span> model<span class="token punctuation">)</span><span class="token punctuation">{</span>   <span class="token comment">//封装要显示到视图中的数据</span>   <span class="token comment">//相当于req.setAttribute("name",name);</span>   model<span class="token punctuation">.</span><span class="token function">addAttribute</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">,</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">return</span> <span class="token string">"hello"</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>第三种 : 通过Model</strong></p><p>Model (精简，大部分情况使用model即可，只有几个方法)</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">"/ct2/hello"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">hello</span><span class="token punctuation">(</span><span class="token annotation punctuation">@RequestParam</span><span class="token punctuation">(</span><span class="token string">"username"</span><span class="token punctuation">)</span> <span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token class-name">Model</span> model<span class="token punctuation">)</span><span class="token punctuation">{</span>   <span class="token comment">//封装要显示到视图中的数据</span>   <span class="token comment">//相当于req.setAttribute("name",name);</span>   model<span class="token punctuation">.</span><span class="token function">addAttribute</span><span class="token punctuation">(</span><span class="token string">"msg"</span><span class="token punctuation">,</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">return</span> <span class="token string">"test"</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-3对比"><a href="#4-3对比" class="headerlink" title="4.3对比"></a>4.3对比</h3><p>就对于新手而言简单来说使用区别就是：</p><pre class="line-numbers language-none"><code class="language-none">Model 只有寥寥几个方法只适合用于储存数据，简化了新手对于Model对象的操作和理解；ModelMap 继承了 LinkedMap ，除了实现了自身的一些方法，同样的继承 LinkedMap 的方法和特性；ModelAndView 可以在储存数据的同时，可以进行设置返回的逻辑视图，进行控制展示层的跳转。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当然更多的以后开发考虑的更多的是性能和优化，就不能单单仅限于此的了解。</p><p><strong>请使用80%的时间打好扎实的基础，剩下18%的时间研究框架，2%的时间去学点英文，框架的官方文档永远是最好的教程。</strong></p><h2 id="5-乱码问题"><a href="#5-乱码问题" class="headerlink" title="5. 乱码问题"></a>5. 乱码问题</h2><p>测试步骤：</p><p>1、我们可以在首页编写一个提交的表单</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>form</span> <span class="token attr-name">action</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>/e/t<span class="token punctuation">"</span></span> <span class="token attr-name">method</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>post<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>name<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>submit<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>form</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>2、后台编写对应的处理类</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Controller</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Encoding</span> <span class="token punctuation">{</span>   <span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">"/e/t"</span><span class="token punctuation">)</span>   <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token class-name">Model</span> model<span class="token punctuation">,</span><span class="token class-name">String</span> name<span class="token punctuation">)</span><span class="token punctuation">{</span>       model<span class="token punctuation">.</span><span class="token function">addAttribute</span><span class="token punctuation">(</span><span class="token string">"msg"</span><span class="token punctuation">,</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//获取表单提交的值</span>       <span class="token keyword">return</span> <span class="token string">"test"</span><span class="token punctuation">;</span> <span class="token comment">//跳转到test页面显示输入的值</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>3、输入中文测试，发现乱码</p><p>不得不说，乱码问题是在我们开发中十分常见的问题，也是让我们程序猿比较头大的问题！</p><p>以前乱码问题通过过滤器解决 , 而SpringMVC给我们提供了一个过滤器 , 可以在web.xml中配置 .</p><p>修改了xml文件需要重启服务器！</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>filter</span><span class="token punctuation">&gt;</span></span>   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>filter-name</span><span class="token punctuation">&gt;</span></span>encoding<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>filter-name</span><span class="token punctuation">&gt;</span></span>   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>filter-class</span><span class="token punctuation">&gt;</span></span>org.springframework.web.filter.CharacterEncodingFilter<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>filter-class</span><span class="token punctuation">&gt;</span></span>   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>init-param</span><span class="token punctuation">&gt;</span></span>       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>param-name</span><span class="token punctuation">&gt;</span></span>encoding<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>param-name</span><span class="token punctuation">&gt;</span></span>       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>param-value</span><span class="token punctuation">&gt;</span></span>utf-8<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>param-value</span><span class="token punctuation">&gt;</span></span>   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>init-param</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>filter</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>filter-mapping</span><span class="token punctuation">&gt;</span></span>   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>filter-name</span><span class="token punctuation">&gt;</span></span>encoding<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>filter-name</span><span class="token punctuation">&gt;</span></span>   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>url-pattern</span><span class="token punctuation">&gt;</span></span>/*<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>url-pattern</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>filter-mapping</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>但是我们发现 , 有些极端情况下.这个过滤器对get的支持不好 .</p><p>处理方法 :</p><p>1、修改tomcat配置文件 ：设置编码！</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Connector</span> <span class="token attr-name">URIEncoding</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>utf-8<span class="token punctuation">"</span></span> <span class="token attr-name">port</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>8080<span class="token punctuation">"</span></span> <span class="token attr-name">protocol</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>HTTP/1.1<span class="token punctuation">"</span></span>          <span class="token attr-name">connectionTimeout</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>20000<span class="token punctuation">"</span></span>          <span class="token attr-name">redirectPort</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>8443<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>2、自定义过滤器</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>kuang<span class="token punctuation">.</span>filter</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">javax<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span></span><span class="token operator">*</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">javax<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>http<span class="token punctuation">.</span></span><span class="token class-name">HttpServletRequest</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">javax<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>http<span class="token punctuation">.</span></span><span class="token class-name">HttpServletRequestWrapper</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">javax<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>http<span class="token punctuation">.</span></span><span class="token class-name">HttpServletResponse</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">IOException</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">UnsupportedEncodingException</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">Map</span><span class="token punctuation">;</span><span class="token comment">/*** 解决get和post请求 全部乱码的过滤器*/</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">GenericEncodingFilter</span> <span class="token keyword">implements</span> <span class="token class-name">Filter</span> <span class="token punctuation">{</span>   <span class="token annotation punctuation">@Override</span>   <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">destroy</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token punctuation">}</span>   <span class="token annotation punctuation">@Override</span>   <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doFilter</span><span class="token punctuation">(</span><span class="token class-name">ServletRequest</span> request<span class="token punctuation">,</span> <span class="token class-name">ServletResponse</span> response<span class="token punctuation">,</span> <span class="token class-name">FilterChain</span> chain<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span><span class="token punctuation">,</span> <span class="token class-name">ServletException</span> <span class="token punctuation">{</span>       <span class="token comment">//处理response的字符编码</span>       <span class="token class-name">HttpServletResponse</span> myResponse<span class="token operator">=</span><span class="token punctuation">(</span><span class="token class-name">HttpServletResponse</span><span class="token punctuation">)</span> response<span class="token punctuation">;</span>       myResponse<span class="token punctuation">.</span><span class="token function">setContentType</span><span class="token punctuation">(</span><span class="token string">"text/html;charset=UTF-8"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">// 转型为与协议相关对象</span>       <span class="token class-name">HttpServletRequest</span> httpServletRequest <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">HttpServletRequest</span><span class="token punctuation">)</span> request<span class="token punctuation">;</span>       <span class="token comment">// 对request包装增强</span>       <span class="token class-name">HttpServletRequest</span> myrequest <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyRequest</span><span class="token punctuation">(</span>httpServletRequest<span class="token punctuation">)</span><span class="token punctuation">;</span>       chain<span class="token punctuation">.</span><span class="token function">doFilter</span><span class="token punctuation">(</span>myrequest<span class="token punctuation">,</span> response<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>   <span class="token annotation punctuation">@Override</span>   <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token class-name">FilterConfig</span> filterConfig<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">ServletException</span> <span class="token punctuation">{</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment">//自定义request对象，HttpServletRequest的包装类</span><span class="token keyword">class</span> <span class="token class-name">MyRequest</span> <span class="token keyword">extends</span> <span class="token class-name">HttpServletRequestWrapper</span> <span class="token punctuation">{</span>   <span class="token keyword">private</span> <span class="token class-name">HttpServletRequest</span> request<span class="token punctuation">;</span>   <span class="token comment">//是否编码的标记</span>   <span class="token keyword">private</span> <span class="token keyword">boolean</span> hasEncode<span class="token punctuation">;</span>   <span class="token comment">//定义一个可以传入HttpServletRequest对象的构造函数，以便对其进行装饰</span>   <span class="token keyword">public</span> <span class="token class-name">MyRequest</span><span class="token punctuation">(</span><span class="token class-name">HttpServletRequest</span> request<span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token keyword">super</span><span class="token punctuation">(</span>request<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// super必须写</span>       <span class="token keyword">this</span><span class="token punctuation">.</span>request <span class="token operator">=</span> request<span class="token punctuation">;</span>  <span class="token punctuation">}</span>   <span class="token comment">// 对需要增强方法 进行覆盖</span>   <span class="token annotation punctuation">@Override</span>   <span class="token keyword">public</span> <span class="token class-name">Map</span> <span class="token function">getParameterMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token comment">// 先获得请求方式</span>       <span class="token class-name">String</span> method <span class="token operator">=</span> request<span class="token punctuation">.</span><span class="token function">getMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token keyword">if</span> <span class="token punctuation">(</span>method<span class="token punctuation">.</span><span class="token function">equalsIgnoreCase</span><span class="token punctuation">(</span><span class="token string">"post"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>           <span class="token comment">// post请求</span>           <span class="token keyword">try</span> <span class="token punctuation">{</span>               <span class="token comment">// 处理post乱码</span>               request<span class="token punctuation">.</span><span class="token function">setCharacterEncoding</span><span class="token punctuation">(</span><span class="token string">"utf-8"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>               <span class="token keyword">return</span> request<span class="token punctuation">.</span><span class="token function">getParameterMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">UnsupportedEncodingException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>               e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token punctuation">}</span>      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>method<span class="token punctuation">.</span><span class="token function">equalsIgnoreCase</span><span class="token punctuation">(</span><span class="token string">"get"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>           <span class="token comment">// get请求</span>           <span class="token class-name">Map</span><span class="token operator">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">&gt;</span> parameterMap <span class="token operator">=</span> request<span class="token punctuation">.</span><span class="token function">getParameterMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>hasEncode<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 确保get手动编码逻辑只运行一次</span>               <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">String</span> parameterName <span class="token operator">:</span> parameterMap<span class="token punctuation">.</span><span class="token function">keySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                   <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> values <span class="token operator">=</span> parameterMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>parameterName<span class="token punctuation">)</span><span class="token punctuation">;</span>                   <span class="token keyword">if</span> <span class="token punctuation">(</span>values <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                       <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> values<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                           <span class="token keyword">try</span> <span class="token punctuation">{</span>                               <span class="token comment">// 处理get乱码</span>                               values<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>values<span class="token punctuation">[</span>i<span class="token punctuation">]</span>                                      <span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token string">"ISO-8859-1"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"utf-8"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                          <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">UnsupportedEncodingException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                               e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                          <span class="token punctuation">}</span>                      <span class="token punctuation">}</span>                  <span class="token punctuation">}</span>              <span class="token punctuation">}</span>               hasEncode <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>          <span class="token punctuation">}</span>           <span class="token keyword">return</span> parameterMap<span class="token punctuation">;</span>      <span class="token punctuation">}</span>       <span class="token keyword">return</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">getParameterMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>   <span class="token comment">//取一个值</span>   <span class="token annotation punctuation">@Override</span>   <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">getParameter</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token class-name">Map</span><span class="token operator">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">&gt;</span> parameterMap <span class="token operator">=</span> <span class="token function">getParameterMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> values <span class="token operator">=</span> parameterMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token keyword">if</span> <span class="token punctuation">(</span>values <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>           <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>       <span class="token keyword">return</span> values<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 取回参数的第一个值</span>  <span class="token punctuation">}</span>   <span class="token comment">//取所有值</span>   <span class="token annotation punctuation">@Override</span>   <span class="token keyword">public</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">getParameterValues</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token class-name">Map</span><span class="token operator">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">&gt;</span> parameterMap <span class="token operator">=</span> <span class="token function">getParameterMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> values <span class="token operator">=</span> parameterMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token keyword">return</span> values<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个也是我在网上找的一些大神写的，一般情况下，SpringMVC默认的乱码处理就已经能够很好的解决了！</p><p><strong>然后在web.xml中配置这个过滤器即可！</strong></p><p>乱码问题，需要平时多注意，在尽可能能设置编码的地方，都设置为统一编码 UTF-8！</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>nginx</title>
      <link href="2021/05/23/nginx/"/>
      <url>2021/05/23/nginx/</url>
      
        <content type="html"><![CDATA[<h1 id="NIGNX"><a href="#NIGNX" class="headerlink" title="NIGNX"></a>NIGNX</h1><h2 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1. 基本概念"></a>1. 基本概念</h2><h3 id="1-1-正向代理"><a href="#1-1-正向代理" class="headerlink" title="1.1 正向代理"></a>1.1 正向代理</h3><p>需要我们自己配置代理服务器，我们的请求都经过代理服务器，这个叫做正向代理。</p><h3 id="1-2-反向代理"><a href="#1-2-反向代理" class="headerlink" title="1.2 反向代理"></a>1.2 反向代理</h3><p>客户端对代理是无感知的，客户端不需要做任何配置。服务器方对外暴露反向代理服务器的地址，然后客户端所有请求都是直接与反向代理服务器交互，反向代理服务器会根据请求去和要请求的服务器尽心交互，再将结果返回给客户端。</p><h3 id="1-3-负载均衡"><a href="#1-3-负载均衡" class="headerlink" title="1.3 负载均衡"></a>1.3 负载均衡</h3><p>通过代理服务器，将请求平均分到代理服务器中。</p><ol><li><p>nginx 的 upstream目前支持 4 种方式的分配<br>1)、轮询（默认）</p><pre class="line-numbers language-none"><code class="language-none">每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>2)、weight</p><pre class="line-numbers language-none"><code class="language-none">指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>2)、ip_hash</p><pre class="line-numbers language-none"><code class="language-none">每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session的问题。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>3)、fair（第三方）</p><pre class="line-numbers language-none"><code class="language-none">按后端服务器的响应时间来分配请求，响应时间短的优先分配。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>4)、url_hash（第三方）</p></li></ol><h3 id="1-4-动静分离"><a href="#1-4-动静分离" class="headerlink" title="1.4 动静分离"></a>1.4 动静分离</h3><p>为了加快网站的解析速度，可以把动态页面和静态页面由不同的服务器来解析，加快解析速度，降低原来单个服务器的压力。</p><p><img src="/2021/05/23/nginx/%E5%8A%A8%E9%9D%99%E5%88%86%E7%A6%BB.PNG"></p><h2 id="2-nginx-常用命令"><a href="#2-nginx-常用命令" class="headerlink" title="2. nginx 常用命令"></a>2. nginx 常用命令</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 前提必须进入nginx的目录中</span><span class="token comment"># nginx 版本</span>./nginx -v<span class="token comment"># 关闭nginx 命令</span>./nginx -s stop<span class="token comment"># 重新加载 nginx</span>./nginx -s reload<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-nginx-配置文件"><a href="#3-nginx-配置文件" class="headerlink" title="3. nginx 配置文件"></a>3. nginx 配置文件</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 修改 nginx.conf 一般在/usr/local/nginx/conf/nginx.conf</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>由三部分组成，全局块、events块、HTTP块。</p><p>全局块中，从配置文件开始到events块之间的内容</p><h3 id="3-1-全局部分"><a href="#3-1-全局部分" class="headerlink" title="3.1 全局部分"></a>3.1 全局部分</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">worker_process <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment"># 这是nginx服务器并发处理服务的关键配置，worker_process值越大，可以支持的并发处理量越多，但是受到硬件、软件等设备的制约。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="3-2-events块"><a href="#3-2-events块" class="headerlink" title="3.2 events块"></a>3.2 events块</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 主要是nginx服务器与用户的网络连接。</span>events <span class="token punctuation">{</span>worker_connections <span class="token number">1024</span><span class="token punctuation">;</span> <span class="token comment"># 支持的最大连接数</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-3-http块"><a href="#3-3-http块" class="headerlink" title="3.3 http块"></a>3.3 http块</h3><h4 id="3-3-1-全局块"><a href="#3-3-1-全局块" class="headerlink" title="3.3.1 全局块"></a>3.3.1 全局块</h4><p>指令包括文件引入、MIME-TYPE定义、日志自定义、连接超时时间、单链接请求数上限等。</p><h4 id="3-3-2-server块"><a href="#3-3-2-server块" class="headerlink" title="3.3.2 server块"></a>3.3.2 server块</h4><p>和虚拟主机有密切关系。</p><p>每个http块可以包括多个server块，而每个server块相当于一个虚拟主机。</p><p>每个server快可以分为全局server块，以及可以同时包含多个location块。</p><ol><li><p>全局server块</p><p>配置本虚拟主机的监听配置和本虚拟主机的名称和IP配置。</p></li><li><p>location块</p><p>一个serve块可以配置多个location块。</p><p>这块的主要作用是基于nginx服务器接收到的请求字符串（例如 server_name/uri-string），对虚拟主机名称（也可以是IP别名）之外的字符串（例如前面的 /uri-string）进行匹配，对特定的请求进行处理。地址定向、数据缓冲和应答控制等功能，还有许多第三方模块的配置也在这里进行。</p></li></ol><h2 id="4-高可用"><a href="#4-高可用" class="headerlink" title="4. 高可用"></a>4. 高可用</h2><p><img src="/2021/05/23/nginx/%E9%AB%98%E5%8F%AF%E7%94%A8.PNG"></p><p>需要两台nginx服务器。</p><p>需要keepalived。</p><p>需要虚拟ip。</p><h2 id="5-原理"><a href="#5-原理" class="headerlink" title="5. 原理"></a>5. 原理</h2><ol><li>nginx启动后有master和worker。</li></ol><p><img src="/2021/05/23/nginx/%E5%8E%9F%E7%90%86.PNG"></p><ol start="2"><li>worker的工作机制：</li></ol><p><img src="/2021/05/23/nginx/worker%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6.PNG"></p><ol start="3"><li><p>一个master多个worker的好处：</p></li><li><p>可以使用 nginx -s reload 热部署。</p></li><li><p>对于每个worker是个独立的进程，不需要加锁。</p></li><li><p>多路复用机制。（windows中没有，linux中有）。worker数和cpu数相等是最合适的，因为每个worker都可以把cpu性能发挥到极致。</p></li></ol><ol start="4"><li><p>多少连接数最合适</p></li><li><p>发送一个请求，占用了worker的几个连接数？</p></li></ol><p>每次请求有和客户端的发送连接和接收连接，然后worker还要和tomcat交互也有两个连接，所以可以说成占用4个连接数，也可以说成两个（静态访问）。</p><ol start="2"><li>nginx有一个master，四个worker，每个worker支持最大连接数1024。问支持的<strong>最大并发数多少</strong>？</li></ol><pre><code>最大连接数 4 * 1024 / 2（静态访问）或 4 （反向代理，需要访问tomcat）= 并发数</code></pre><h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><h3 id="1-启动-Nginx"><a href="#1-启动-Nginx" class="headerlink" title="1.启动 Nginx"></a>1.启动 Nginx</h3><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">systemctl start nginx<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="2-停止-Nginx"><a href="#2-停止-Nginx" class="headerlink" title="2.停止 Nginx"></a>2.停止 Nginx</h3><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">systemctl stop nginx<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="3-重启-Nginx"><a href="#3-重启-Nginx" class="headerlink" title="3.重启 Nginx"></a>3.重启 Nginx</h3><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">systemctl restart nginx<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="4-查看-Nginx-状态"><a href="#4-查看-Nginx-状态" class="headerlink" title="4.查看 Nginx 状态"></a>4.查看 Nginx 状态</h3><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">systemctl status nginx<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="5-启用开机启动-Nginx"><a href="#5-启用开机启动-Nginx" class="headerlink" title="5.启用开机启动 Nginx"></a>5.启用开机启动 Nginx</h3><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">systemctl enable nginx<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="6-禁用开机启动-Nginx"><a href="#6-禁用开机启动-Nginx" class="headerlink" title="6.禁用开机启动 Nginx"></a>6.禁用开机启动 Nginx</h3><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">systemctl disable nginx<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="安装-Nginx"><a href="#安装-Nginx" class="headerlink" title="安装 Nginx"></a>安装 Nginx</h3><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">sudo yum install <span class="token operator">-</span>y nginx<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>安装成功后，默认的网站目录为： /usr/share/nginx/html</p><p>默认的配置文件为：/etc/nginx/nginx.conf</p><p>自定义配置文件目录为: /etc/nginx/conf.d/</p>]]></content>
      
      
      <categories>
          
          <category> nginx </category>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springboot</title>
      <link href="2021/05/19/springboot/"/>
      <url>2021/05/19/springboot/</url>
      
        <content type="html"><![CDATA[<h1 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h1><h2 id="1-1-自动装配原理"><a href="#1-1-自动装配原理" class="headerlink" title="1.1 自动装配原理"></a>1.1 自动装配原理</h2><ol><li>springboot在启动时，从类路径下/META-INF/spring.factories 获取指定的值。</li><li>将这些自动配置的类导入容器，自动配置就会生效，帮我进行自动配置</li><li>以前需要自动配置的东西，springboot帮我们做了。</li><li>整合javaEE解决方案和自动配置的东西都在<code>springbootautoconfiguration</code>下面</li></ol><h2 id="2-yaml"><a href="#2-yaml" class="headerlink" title="2 yaml"></a>2 yaml</h2><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token comment"># 普通</span><span class="token key atrule">name</span><span class="token punctuation">:</span> qinjiang<span class="token comment"># 对象</span><span class="token key atrule">student</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> qinjiang  age<span class="token punctuation">:</span><span class="token number">3</span><span class="token comment"># 行内写法</span><span class="token key atrule">student</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token key atrule">name</span><span class="token punctuation">:</span> qinjiang<span class="token punctuation">,</span> <span class="token key atrule">age</span><span class="token punctuation">:</span> <span class="token number">3</span><span class="token punctuation">}</span><span class="token comment"># 数组</span><span class="token key atrule">pets</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> cat  <span class="token punctuation">-</span> dog  <span class="token punctuation">-</span> pig  <span class="token key atrule">pets</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>cat<span class="token punctuation">,</span>dog<span class="token punctuation">,</span>pig<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-Shiro"><a href="#3-Shiro" class="headerlink" title="3. Shiro"></a>3. Shiro</h2><p>一个Java安全（权限）框架。</p><p><img src="/2021/05/19/springboot/shiro%E7%BB%93%E6%9E%84.PNG"></p><ul><li>subject：直接交互的对象是subject。</li><li>SecurityManager：安全管理器，所有与安全相关的操作都与此交互，并且管理所有的Subject，相当于SpringMVC中的DispatcherServlet的角色。</li><li>Realm：Shiro从Realm获取安全数据（如用户，角色，权限），就是说SecurityManager要验证用户身份，那么它需要从Realm获取相应的用户进行比较，来确定用户的身份是否合法，可以把Realm看成是DataSource。</li></ul><h2 id="4-RestTemplate"><a href="#4-RestTemplate" class="headerlink" title="4.RestTemplate"></a>4.RestTemplate</h2><p>提供了多种便捷访问远程Http服务的方法。</p><p>是一种简单便捷的访问resful服务模板类，是Spring提供的用于访问Rest服务的客户端模板工具集。</p><p>（url，requestMap，ResponseBean.class）这三个参数分别代表：</p><p>Rest请求地址、请求参数、HTTP响应转换被转换成的对象类型。</p>]]></content>
      
      
      <categories>
          
          <category> springboot </category>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springboot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>什么是高可用</title>
      <link href="2021/05/18/shi-me-shi-gao-ke-yong/"/>
      <url>2021/05/18/shi-me-shi-gao-ke-yong/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是高可用"><a href="#什么是高可用" class="headerlink" title="什么是高可用"></a>什么是高可用</h1><p>为什么就不说了吧，系统都要保证这一点的，否则经常奔溃那这系统还能用吗？</p><h2 id="1-是什么"><a href="#1-是什么" class="headerlink" title="1. 是什么"></a>1. 是什么</h2><p>高可用HA(High Availability)是分布式系统架构设计种必须考虑的因素之一。指通过设计减少系统不可用的时间。</p><p>如果系统能够一直提供服务，那么系统的可用性是100%。如果系统每运行100个时间单位，会有1个时间单位无法提供服务，那么可用性是99%。</p><h2 id="2-怎么做"><a href="#2-怎么做" class="headerlink" title="2. 怎么做"></a>2. 怎么做</h2><ol><li><p>首先要做的就是冗余。</p><p>通过集群化，如果只有一个节点挂了，那么其他节点可以继续提供服务。</p></li><li><p>自动转移故障机制。</p><p>有了冗余，如果每次故障都需要人为接入那么太拉跨了。</p></li></ol><p>如何故障转移呢，这就涉及到了典型的互联网架构。</p><p><img src="/2021/05/18/shi-me-shi-gao-ke-yong/v2-b263bfcbf32c4bc0f1326b4faad7afef_720w.jpg" alt="img"></p><p>（1）客户端层：典型调用方是浏览器browser或者手机应用APP</p><p>（2）反向代理层：系统入口，反向代理</p><p>（3）站点应用层：实现核心应用逻辑，返回html或者json</p><p>（4）服务层：如果实现了服务化，就有这一层</p><p>（5）数据-缓存层：缓存加速访问存储</p><p>（6）数据-数据库层：数据库固化数据存储</p><h2 id="3-每层架构的高可用"><a href="#3-每层架构的高可用" class="headerlink" title="3. 每层架构的高可用"></a>3. 每层架构的高可用</h2><h3 id="3-1客户端层-gt-反向代理层的高可用"><a href="#3-1客户端层-gt-反向代理层的高可用" class="headerlink" title="3.1客户端层->反向代理层的高可用"></a>3.1客户端层-&gt;反向代理层的高可用</h3><p><img src="/2021/05/18/shi-me-shi-gao-ke-yong/v2-59ea4193669f2bbd9b1ad7593f069e44_720w.jpg" alt="img"></p><p>客户端层】到【反向代理层】的高可用，是通过反向代理层的冗余来实现的。以nginx为例：有两台nginx，一台对线上提供服务，另一台冗余以保证高可用，常见的实践是keepalived存活探测，相同virtual IP提供服务。</p><p><img src="/2021/05/18/shi-me-shi-gao-ke-yong/v2-3c99711c68fcc7c1b504768e0e64fa3d_720w.jpg" alt="img"></p><p>自动故障转移：当nginx挂了的时候，keepalived能够探测到，会自动的进行故障转移，将流量自动迁移到shadow-nginx，由于使用的是相同的virtual IP，这个切换过程对调用方是透明的。</p><h3 id="3-2-反向代理层-gt-站点层-高可用"><a href="#3-2-反向代理层-gt-站点层-高可用" class="headerlink" title="3.2 反向代理层 -> 站点层 高可用"></a>3.2 反向代理层 -&gt; 站点层 高可用</h3><p><img src="/2021/05/18/shi-me-shi-gao-ke-yong/v2-1951d6ea670a6f879b06f62fa0d3223a_720w.jpg" alt="img"></p><p>【反向代理层】到【站点层】的高可用，是通过站点层的冗余来实现的。假设反向代理层是nginx，nginx.conf里能够配置多个web后端，并且nginx能够探测到多个后端的存活性。</p><p><img src="/2021/05/18/shi-me-shi-gao-ke-yong/v2-7fd0f7076902f4534a6debddf2c999d8_720w.jpg" alt="img"></p><p>自动故障转移：当web-server挂了的时候，nginx能够探测到，会自动的进行故障转移，将流量自动迁移到其他的web-server，整个过程由nginx自动完成，对调用方是透明的。</p><h3 id="3-3-站点层-gt-服务层的高可用"><a href="#3-3-站点层-gt-服务层的高可用" class="headerlink" title="3.3 站点层->服务层的高可用"></a>3.3 站点层-&gt;服务层的高可用</h3><p><img src="https://pic2.zhimg.com/80/v2-470b831cc42aa39eda3c98c0078abfb9_720w.jpg" alt="img"></p><p>【站点层】到【服务层】的高可用，是通过服务层的冗余来实现的。“服务连接池”会建立与下游服务多个连接，每次请求会“随机”选取连接来访问下游服务。</p><p><img src="https://pic1.zhimg.com/80/v2-62818fa9f676d50dbd4d9be076cba1dc_720w.jpg" alt="img"></p><p>自动故障转移：当service挂了的时候，service-connection-pool能够探测到，会自动的进行故障转移，将流量自动迁移到其他的service，整个过程由连接池自动完成，对调用方是透明的（所以说RPC-client中的服务连接池是很重要的基础组件）。</p><h3 id="3-4-服务层-gt-缓存层的高可用"><a href="#3-4-服务层-gt-缓存层的高可用" class="headerlink" title="3.4 服务层>缓存层的高可用"></a>3.4 服务层&gt;缓存层的高可用</h3><p><img src="/2021/05/18/shi-me-shi-gao-ke-yong/v2-4e031e94cfc8ae0303ac70020e61e4bc_720w.jpg" alt="img"></p><p>【服务层】到【缓存层】的高可用，是通过缓存数据的冗余来实现的。</p><p>缓存层的数据冗余又有几种方式：第一种是利用客户端的封装，service对cache进行双读或者双写。</p><p><img src="/2021/05/18/shi-me-shi-gao-ke-yong/v2-0fdeb1ee63b7c88ce2e727c0a6faf095_720w.jpg" alt="img"></p><p>缓存层也可以通过支持主从同步的缓存集群来解决缓存层的高可用问题。</p><p>以redis为例，redis天然支持主从同步，redis官方也有sentinel哨兵机制，来做redis的存活性检测。</p><p><img src="/2021/05/18/shi-me-shi-gao-ke-yong/v2-cabab5281cfc4475bfa4b875953a4652_720w.jpg" alt="img"></p><p>自动故障转移：当redis主挂了的时候，sentinel能够探测到，会通知调用方访问新的redis，整个过程由sentinel和redis集群配合完成，对调用方是透明的。</p><p>说完缓存的高可用，这里要多说一句，业务对缓存并不一定有“高可用”要求，更多的对缓存的使用场景，是用来“加速数据访问”：把一部分数据放到缓存里，如果缓存挂了或者缓存没有命中，是可以去后端的数据库中再取数据的。</p><p>这类允许“cache miss”的业务场景，缓存架构的建议是：</p><p><img src="/2021/05/18/shi-me-shi-gao-ke-yong/v2-e75def903e6669d81cb1dc46c22bf436_720w-1621330184627.jpg" alt="img"></p><p>将kv缓存封装成服务集群，上游设置一个代理（代理可以用集群冗余的方式保证高可用），代理的后端根据缓存访问的key水平切分成若干个实例，每个实例的访问并不做高可用。</p><p><img src="/2021/05/18/shi-me-shi-gao-ke-yong/v2-54882e121ce8268eb4ae6525cbfe3b23_720w-1621330182799.jpg" alt="img"></p><p>缓存实例挂了屏蔽：当有水平切分的实例挂掉时，代理层直接返回cache miss，此时缓存挂掉对调用方也是透明的。key水平切分实例减少，不建议做re-hash，这样容易引发缓存数据的不一致。</p><h3 id="3-5服务层-gt-数据库层的高可用"><a href="#3-5服务层-gt-数据库层的高可用" class="headerlink" title="3.5服务层>数据库层的高可用"></a>3.5服务层&gt;数据库层的高可用</h3><p>大部分互联网技术，数据库层都用了“主从同步，读写分离”架构，所以数据库层的高可用，又分为“读库高可用”与“写库高可用”两类。</p><p>【服务层&gt;数据库层“读”】的高可用</p><p><img src="/2021/05/18/shi-me-shi-gao-ke-yong/v2-02eb450cf9d174e331540e31dd0345c5_720w.jpg" alt="img"></p><p>【服务层】到【数据库读】的高可用，是通过读库的冗余来实现的。</p><p>既然冗余了读库，一般来说就至少有2个从库，“数据库连接池”会建立与读库多个连接，每次请求会路由到这些读库。</p><p><img src="/2021/05/18/shi-me-shi-gao-ke-yong/v2-4225d557e4561607ad7e503903ac0222_720w.jpg" alt="img"></p><p>自动故障转移：当读库挂了的时候，db-connection-pool能够探测到，会自动的进行故障转移，将流量自动迁移到其他的读库，整个过程由连接池自动完成，对调用方是透明的（所以说DAO中的数据库连接池是很重要的基础组件）。</p><h3 id="3-6服务层-gt-数据库层“写”的高可用"><a href="#3-6服务层-gt-数据库层“写”的高可用" class="headerlink" title="3.6服务层>数据库层“写”的高可用"></a>3.6服务层&gt;数据库层“写”的高可用</h3><p><img src="/2021/05/18/shi-me-shi-gao-ke-yong/v2-246454fcc1f8819b67469b63485c2798_720w.jpg" alt="img"></p><p>【服务层】到【数据库写】的高可用，是通过写库的冗余来实现的。</p><p>以mysql为例，可以设置两个mysql双主同步，一台对线上提供服务，另一台冗余以保证高可用，常见的实践是keepalived存活探测，相同virtual IP提供服务。</p><p><img src="/2021/05/18/shi-me-shi-gao-ke-yong/v2-ed96e26ab8c04b3fe16b61aa36c0f4bb_720w.jpg" alt="img"></p><p>自动故障转移：当写库挂了的时候，keepalived能够探测到，会自动的进行故障转移，将流量自动迁移到shadow-db-master，由于使用的是相同的virtual IP，这个切换过程对调用方是透明的。</p>]]></content>
      
      
      <categories>
          
          <category> 讨论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 讨论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker</title>
      <link href="2021/05/16/docker/"/>
      <url>2021/05/16/docker/</url>
      
        <content type="html"><![CDATA[<h1 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><h3 id="1-1-为什么"><a href="#1-1-为什么" class="headerlink" title="1.1 为什么"></a>1.1 为什么</h3><p>我的代码在我的机子上能跑，在你的机子上竟然崩了！！！docker解决这个问题！</p><h3 id="1-2-是什么"><a href="#1-2-是什么" class="headerlink" title="1.2 是什么"></a>1.2 是什么</h3><p>通过docker直接把运行环境打包且跨平台。隔离是docker的核心思想。</p><h3 id="1-3-怎么做"><a href="#1-3-怎么做" class="headerlink" title="1.3 怎么做"></a>1.3 怎么做</h3><p><img src="/2021/05/16/docker/image-20210604194813470.png" alt="image-20210604194813470"></p><p>通过Docker Engine 直接使用宿主机的内核，相比虚拟机少了一层Guest OS的抽象层，所以占用空间少。</p><h2 id="2-常用命令"><a href="#2-常用命令" class="headerlink" title="2. 常用命令"></a>2. 常用命令</h2><p>官方命令地址：<a href="https://docs.docker.com/engine/reference/commandline/login/">docker login | Docker Documentation</a></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">docker verison # 显示docker的版本信息docker info # 显示docker的系统信息，包括镜像和容器的数量docker 命令 --help #万能命令<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-1-搜索"><a href="#2-1-搜索" class="headerlink" title="2.1 搜索"></a>2.1 搜索</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">docker searchdocker search mysql --filter=STARS=3000<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="2-2-拉取"><a href="#2-2-拉取" class="headerlink" title="2.2 拉取"></a>2.2 拉取</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">docker pull # docker pull 镜像名字:tag# 如果不写tag就下载最新的 latest# <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-3-运行"><a href="#2-3-运行" class="headerlink" title="2.3 运行"></a>2.3 运行</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">docker run [可选参数] image--name="name" #名字-d #后台运行-it #交互方式进行-p 指定容器的端口， -p 8080:8080-P 随机指定端口<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-4-列出容器"><a href="#2-4-列出容器" class="headerlink" title="2.4 列出容器"></a>2.4 列出容器</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">docker ps 正在运行-a 正在运行+历史运行<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="2-5-退出容器"><a href="#2-5-退出容器" class="headerlink" title="2.5 退出容器"></a>2.5 退出容器</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">exit #直接退出容器并停止Ctrl + P + Q #容器不停止退出<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="2-6-删除容器"><a href="#2-6-删除容器" class="headerlink" title="2.6 删除容器"></a>2.6 删除容器</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">docker rm id #镜像是rmidocker rm -f $(docker ps -aq)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="2-7-停止容器"><a href="#2-7-停止容器" class="headerlink" title="2.7 停止容器"></a>2.7 停止容器</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">docker stop iddocker kill iddocker start iddocker restart id<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-8-查看内部信息"><a href="#2-8-查看内部信息" class="headerlink" title="2.8 查看内部信息"></a>2.8 查看内部信息</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">docker top id # 查看内部信息<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="2-9-常用其他命令"><a href="#2-9-常用其他命令" class="headerlink" title="2.9 常用其他命令"></a>2.9 常用其他命令</h3><h4 id="2-9-1-后台启动命令"><a href="#2-9-1-后台启动命令" class="headerlink" title="2.9.1 后台启动命令"></a>2.9.1 后台启动命令</h4><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">docker run -d centos# 问题docker ps 如果退出会停止，容器使用后台进程，容器中必须要有一个进程在跑着，不然就自动停了。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="2-9-2-查看日志"><a href="#2-9-2-查看日志" class="headerlink" title="2.9.2 查看日志"></a>2.9.2 查看日志</h4><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">docker logs -ft --tail 10 容器id #查看id容器的日志，且一开始打印最新的10条log（如果还有新日志，会一直增加显示新日志）docker inspect 容器id # 查看容器信息<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="2-9-3-进入当前容器"><a href="#2-9-3-进入当前容器" class="headerlink" title="2.9.3 进入当前容器"></a>2.9.3 进入当前容器</h4><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">docker exec -it 容器id /bin/bash # 进入容器后开启新的终端，可以在里面操作（常用）docker attach 容器id # 进入容器正在执行的终端，不会启动新的进程<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="2-9-4-容器内的文件拷贝到机子上"><a href="#2-9-4-容器内的文件拷贝到机子上" class="headerlink" title="2.9.4 容器内的文件拷贝到机子上"></a>2.9.4 容器内的文件拷贝到机子上</h4><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"># 进入容器后！！！docker cp 容器id:/dir/XXX.java /home<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>post</title>
      <link href="2021/05/16/post/"/>
      <url>2021/05/16/post/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>git</title>
      <link href="2021/05/16/git/"/>
      <url>2021/05/16/git/</url>
      
        <content type="html"><![CDATA[<h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h1><h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h2><p>开发中版本迭代，新的和老的版本之间进行管理。</p><h3 id="1-1-本地版本控制"><a href="#1-1-本地版本控制" class="headerlink" title="1.1 本地版本控制"></a>1.1 本地版本控制</h3><p>记录文件每次的更新，可以对每个版本做一个快照，或是记录补丁文件，适合个人用，如RCS。</p><p><img src="/2021/05/16/git/local.PNG"></p><h3 id="1-2-集中式版本控制"><a href="#1-2-集中式版本控制" class="headerlink" title="1.2 集中式版本控制"></a>1.2 集中式版本控制</h3><p><img src="/2021/05/16/git/center.PNG"></p><p>所有版本数据保存在一个服务器上，协同开发者从服务器上同步更新自己的修改。</p><p>代表作：SVN</p><p>一旦服务器坏了，那工程直接没了。</p><h3 id="1-3-分布式版本控制"><a href="#1-3-分布式版本控制" class="headerlink" title="1.3 分布式版本控制"></a>1.3 分布式版本控制</h3><p><img src="/2021/05/16/git/%E5%88%86%E5%B8%83%E5%BC%8F%E7%89%88%E6%9C%AC.PNG"></p><p>所有版本信息仓库全部同步到本地的每个用户，这样</p><h3 id="1-1-git和svn的区别"><a href="#1-1-git和svn的区别" class="headerlink" title="1.1 git和svn的区别"></a>1.1 git和svn的区别</h3><ul><li>svn </li></ul><p>集种式版本控制系统，版本库是集种放在中央服务器的。而工作的时候，用的都是自己的电脑，所以首先要从中央服务器得到最新的版本，然后工作，完成工作后，需要把自己做完的活推送到中央服务器。集中式版本控制系统是必须联网才能工作，对网络带宽要求较高。</p><ul><li>git</li></ul><p>分布式版本控制系统，没有中央服务器，每个人的电脑就是一个完整的版本库，工作的时候不需要联网，因为版本都在自己电脑上。</p><p>有个人在自己电脑上改了文件A，其他人也在电脑上改了文件A，这时只需要把各自修改推送给对方，就可以看到对方的修改了。</p><h2 id="2-环境配置"><a href="#2-环境配置" class="headerlink" title="2. 环境配置"></a>2. 环境配置</h2><p>下载下来无脑next安装。</p><h3 id="2-1-git配置"><a href="#2-1-git配置" class="headerlink" title="2.1 git配置"></a>2.1 git配置</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 查看系统config</span><span class="token function">git</span> config --system --list<span class="token comment"># 查看当前用户(global)配置</span><span class="token function">git</span> config --global --list<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li>Git\etc\gitconfig：Git安装目录下的gitconfig –system 系垃圾</li><li>C:\Users\Admin.gitconfig 当前登录用户的配置 –global 全局 这里可以直接编辑配置文件，通过命令设置后会响应到这里。</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> config --global user.name <span class="token string">"kuangshen"</span> <span class="token comment">#名称</span><span class="token function">git</span> config --global user.email <span class="token number">1256211675</span>@qq.com <span class="token comment">#邮箱</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><code>git config -l</code> 查看配置</p><h2 id="3-基本理论"><a href="#3-基本理论" class="headerlink" title="3. 基本理论"></a>3. 基本理论</h2><h3 id="3-1-工作原理"><a href="#3-1-工作原理" class="headerlink" title="3.1 工作原理"></a>3.1 工作原理</h3><p>工作目录(Working Directory)、暂存区(stage/Index)、资源库(Repository)。</p><p><img src="/2021/05/16/git/git%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.PNG"></p><h3 id="3-2-工作流程"><a href="#3-2-工作流程" class="headerlink" title="3.2 工作流程"></a>3.2 工作流程</h3><ol><li>在工作目录添加、修改文件。</li><li>将需要进行版本管理的文件放入暂存区。</li><li>将暂存区的文件提交到git仓库。</li></ol><p>git管理的文件有三种状态：已修改(modified)、已暂存(staged)、已提交(commited)</p><h2 id="4-文件操作"><a href="#4-文件操作" class="headerlink" title="4. 文件操作"></a>4. 文件操作</h2><p>对文件的修改、提交等操作，需要知道文件当前在什么状态。</p><ol><li>Untracked：未跟踪，此文件在文件夹中，但并没有加入到git库，不参与版本控制。通过<code>git add</code> 状态变为<code>staged</code>。</li><li>Unmodify:未修改，文件入库未修改，即版本库中的文件快照内容与文件夹中完全一致。这种类型的文件有两种去处，如果它被修改，而变为<code>Modified</code>。如果使用<code>git rm</code>移出版本库，则成为<code>Untracked</code>文件。</li><li>Modified：已修改，仅仅是修改，并没有进行其他操作。通过<code>git add</code>进入暂存<code>staged</code>状态，使用<code>git checkout</code>则丢弃修改过，返回到<code>unmodify</code>状态，这个<code>git checkout</code>即从库中取出文件，覆盖当前修改。</li><li>Stage：暂存状态，执行<code>git commit</code>则将修改同步到库中，这时库中的文件和本地文件又变为一致，文件为<code>Unmodify</code>状态。执行<code>git reset HEAD filename</code>取消暂存，文件变为<code>Modified</code>。</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 为注释</span>*.txt <span class="token comment">#忽略所有.txt结尾的文件</span><span class="token operator">!</span>lib.txt <span class="token comment">#但lib.txt除外</span>/temp <span class="token comment">#仅忽略项目根目录下的TODO文件，不包括其他目录temp</span>build/ <span class="token comment">#忽略build/目录下的所有文件</span>doc/*.txt <span class="token comment">#会忽略 doc/noted.txt 但不包括 doc/server/arch.txt</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 新建一个分支，但依然停留在当前分支</span><span class="token function">git</span> branch <span class="token punctuation">[</span>branch-name<span class="token punctuation">]</span><span class="token comment"># 新建一个分支，并切换到该分支</span><span class="token function">git</span> checkout -b <span class="token punctuation">[</span>branch<span class="token punctuation">]</span><span class="token comment"># 切换到已有分支</span><span class="token function">git</span> switch <span class="token punctuation">[</span>branch<span class="token punctuation">]</span><span class="token comment"># 合并指定分支到当前分支</span><span class="token function">git</span> merge <span class="token punctuation">[</span>branch<span class="token punctuation">]</span><span class="token comment"># 删除分支</span><span class="token function">git</span> brach -d <span class="token punctuation">[</span>branch-name<span class="token punctuation">]</span><span class="token comment"># 删除远程分支</span><span class="token function">git</span> push origin --delete <span class="token punctuation">[</span>branch-name<span class="token punctuation">]</span><span class="token function">git</span> branch -dr <span class="token punctuation">[</span>remote/branch<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springcloud</title>
      <link href="2021/05/16/springcloud/"/>
      <url>2021/05/16/springcloud/</url>
      
        <content type="html"><![CDATA[<h1 id="Springcloud"><a href="#Springcloud" class="headerlink" title="Springcloud"></a>Springcloud</h1><h2 id="1-微服务架构"><a href="#1-微服务架构" class="headerlink" title="1. 微服务架构"></a>1. 微服务架构</h2><h3 id="1-1-为什么"><a href="#1-1-为什么" class="headerlink" title="1.1 为什么"></a>1.1 为什么</h3><h3 id="2-2-是什么"><a href="#2-2-是什么" class="headerlink" title="2.2 是什么"></a>2.2 是什么</h3><p>将单一应用划分成一组小的服务，服务之间相互协调、互相配合，为用户提供最终价值。</p><p>springcloud=多种微服务架构落地技术的集合体，微服务全家桶</p><p><img src="/2021/05/16/springcloud/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%A8%A1%E5%9D%97.PNG"></p><h3 id="1-3-pom文件"><a href="#1-3-pom文件" class="headerlink" title="1.3 pom文件"></a>1.3 pom文件</h3><p><code>dependencyManagement</code> 是maven提供的一种管理依赖版本号的方式。</p><p>使用<code>pom.xml</code>中的dependencyManagement元素能让所有在子项目中引用一个依赖而不用显示的列出版本号。Maven会沿着父子层次向上走，直到找到一个拥有dependencyManagement元素的项目，然后它会使用这个dependencymanagement元素中指定的版本号。</p><p><font color="red"><code>dependencyManagement</code> 只是声明依赖，并不实现引入，因此子项目需要显示的声明需要用的依赖。</font></p><h2 id="2-服务注册中心"><a href="#2-服务注册中心" class="headerlink" title="2.服务注册中心"></a>2.服务注册中心</h2><h3 id="2-1-Zookeeper"><a href="#2-1-Zookeeper" class="headerlink" title="2.1 Zookeeper"></a>2.1 Zookeeper</h3><h3 id="2-2-Consul"><a href="#2-2-Consul" class="headerlink" title="2.2 Consul"></a>2.2 Consul</h3><h4 id="2-2-1-是什么"><a href="#2-2-1-是什么" class="headerlink" title="2.2.1 是什么"></a>2.2.1 是什么</h4><p>Consul是一套开源的分布式服务发现和配置管理系统，有hashiCorp用go语言开发。</p><h3 id="2-3-Nacos"><a href="#2-3-Nacos" class="headerlink" title="2.3 Nacos"></a>2.3 Nacos</h3><h3 id="2-4-Eureka"><a href="#2-4-Eureka" class="headerlink" title="2.4 Eureka"></a>2.4 Eureka</h3><h4 id="2-4-1-基础知识"><a href="#2-4-1-基础知识" class="headerlink" title="2.4.1 基础知识"></a>2.4.1 基础知识</h4><ul><li>服务治理</li></ul><p>Spring Cloud封装了Netflic公司开发的Eureka模块来实现服务治理。</p><p>在传统的rpc远程调用框架中，管理每个服务与服务之间的依赖关系比较复杂，需要使用服务治理管理服务与服务之间的依赖关系，可以实现服务调用、负载均衡、容错等，实现服务的注册与发现。</p><h4 id="2-4-2-单机Eureka构建步骤"><a href="#2-4-2-单机Eureka构建步骤" class="headerlink" title="2.4.2 单机Eureka构建步骤"></a>2.4.2 单机Eureka构建步骤</h4><h4 id="2-4-3-集群Eureka构建步骤"><a href="#2-4-3-集群Eureka构建步骤" class="headerlink" title="2.4.3  集群Eureka构建步骤"></a>2.4.3  集群Eureka构建步骤</h4><h4 id="2-4-4-Eureka-理论"><a href="#2-4-4-Eureka-理论" class="headerlink" title="2.4.4 Eureka 理论"></a>2.4.4 Eureka 理论</h4><p>保护模式主要用于一组客户端和Eureka Server之间存在网络分区场景下的保护。一旦进入保护模式，Eureka Server将会尝试保护其服务注册表中的信息，不再删除服务注册表中的数据，也就是不会注销任何微服务。</p><p>其实就是某时刻某一个微服务不可用，Eureka不会立即清理，依旧会对该微服务的信息进行保存。</p><h3 id="2-5-zookeaper"><a href="#2-5-zookeaper" class="headerlink" title="2.5 zookeaper"></a>2.5 zookeaper</h3>]]></content>
      
      
      <categories>
          
          <category> springcloud </category>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springcloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java堆栈内存与堆外内存</title>
      <link href="2021/05/08/java-dui-zhan-nei-cun-yu-dui-wai-nei-cun/"/>
      <url>2021/05/08/java-dui-zhan-nei-cun-yu-dui-wai-nei-cun/</url>
      
        <content type="html"><![CDATA[<h2 id="Java堆栈内存与堆外内存"><a href="#Java堆栈内存与堆外内存" class="headerlink" title="Java堆栈内存与堆外内存"></a>Java堆栈内存与堆外内存</h2><p>参考至：<a href="https://zhuanlan.zhihu.com/p/161939673">Java 堆外内存、零拷贝、直接内存以及针对于NIO中的FileChannel的思考 - 知乎 (zhihu.com)</a></p><h2 id="1-堆栈内存"><a href="#1-堆栈内存" class="headerlink" title="1. 堆栈内存"></a>1. 堆栈内存</h2><p>堆栈内存指的是堆内存和栈内存：堆内存是GC管理的内存，栈内存是线程内存。</p><p>堆内存结构：</p><p><img src="/2021/05/08/java-dui-zhan-nei-cun-yu-dui-wai-nei-cun/v2-204901182bea659e8e72bc9bac66ffd5_720w.jpg" alt="img"></p><p>还有一个更细致的结构图（包括MetaSpace还有code cache）：</p><p><strong>注意在Java8以后PermGen被MetaSpace代替，运行时可自动扩容，并且默认是无限大</strong></p><p><img src="/2021/05/08/java-dui-zhan-nei-cun-yu-dui-wai-nei-cun/v2-9e2284cf759dcbfd479d78cae9112983_720w.jpg" alt="img"></p><p>我们看下面一段代码来简单理解下堆栈的关系：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">public static void main(String[] args) {    Object o = new Object();}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>其中<code>new Object()</code>是在堆上面分配，而Object o这个变量，是在main这个线程栈上面。</p><ul><li>应用程序所有的部分都使用堆内存，然后栈内存通过一个线程运行来使用。</li><li>不论对象什么时候创建，他都会存储在堆内存中，栈内存包含它的引用。栈内存只包含原始值变量好和堆中对象变量的引用。</li><li>存储在堆中的对象是全局可以被访问的，然而栈内存不能被其他线程所访问。</li><li>通过JVM参数<code>-Xmx</code>我们可以指定最大堆内存大小，通过<code>-Xss</code>我们可以指定每个线程线程栈占用内存大小</li></ul><h2 id="2-堆外内存"><a href="#2-堆外内存" class="headerlink" title="2. 堆外内存"></a>2. 堆外内存</h2><h3 id="2-1-广义的堆外内存"><a href="#2-1-广义的堆外内存" class="headerlink" title="2.1. 广义的堆外内存"></a>2.1. 广义的堆外内存</h3><p>除了堆栈内存，剩下的就都是堆外内存了，包括了jvm本身在运行过程中分配的内存，codecache，jni里分配的内存，DirectByteBuffer分配的内存等等</p><h3 id="2-2-狭义的堆外内存-DirectByteBuffer"><a href="#2-2-狭义的堆外内存-DirectByteBuffer" class="headerlink" title="2.2. 狭义的堆外内存 - DirectByteBuffer"></a>2.2. 狭义的堆外内存 - DirectByteBuffer</h3><p>而作为java开发者，我们常说的堆外内存溢出了，其实是狭义的堆外内存，这个主要是指java.nio.DirectByteBuffer在创建的时候分配内存，我们这篇文章里也主要是讲狭义的堆外内存，因为它和我们平时碰到的问题比较密切</p><p><strong>为啥要使用堆外内存。通常因为：</strong></p><ul><li>在进程间可以共享，减少虚拟机间的复制</li><li>对垃圾回收停顿的改善：如果应用某些长期存活并大量存在的对象，经常会出发YGC或者FullGC，可以考虑把这些对象放到堆外。过大的堆会影响Java应用的性能。如果使用堆外内存的话，堆外内存是直接受操作系统管理( 而不是虚拟机 )。这样做的结果就是能保持一个较小的堆内内存，以减少垃圾收集对应用的影响。</li><li>在某些场景下可以提升程序I/O操纵的性能。少去了将数据从堆内内存拷贝到堆外内存的步骤。</li></ul><h2 id="3-JNI调用与内核态及用户态"><a href="#3-JNI调用与内核态及用户态" class="headerlink" title="3. JNI调用与内核态及用户态"></a>3. JNI调用与内核态及用户态</h2><ul><li>内核态：cpu可以访问内存的所有数据，包括外围设备，例如硬盘，网卡，cpu也可以将自己从一个程序切换到另一个程序。</li><li>用户态：只能受限的访问内存，且不允许访问外围设备，占用cpu的能力被剥夺，cpu资源可以被其他程序获取。</li><li>系统调用：为了使上层应用能够访问到这些资源，内核为上层应用提供访问的接口</li></ul><p><strong>Java调用原生方法即JNI就是系统调用的一种。</strong></p><p>我们举个例子，文件读取；Java本身并不能读取文件，因为用户态没有权限访问外围设备。需要通过系统调用切换内核态进行读取。</p><p>目前，JAVA的IO方式有基于流的传统IO还有基于块的NIO方式（虽然文件读取其实不是严格意义上的NIO，哈哈）。面向流意味着从流中一次可以读取一个或多个字节，拿到读取的这些做什么你说了算，这里没有任何缓存（这里指的是使用流没有任何缓存，接收或者发送的数据是缓存到操作系统中的，流就像一根水管从操作系统的缓存中读取数据）而且只能顺序从流中读取数据，如果需要跳过一些字节或者再读取已经读过的字节，你必须将从流中读取的数据先缓存起来。面向块的处理方式有些不同，数据是先被 读/写到buffer中的，根据需要你可以控制读取什么位置的数据。这在处理的过程中给用户多了一些灵活性，然而，你需要额外做的工作是检查你需要的数据是否已经全部到了buffer中，你还需要保证当有更多的数据进入buffer中时，buffer中未处理的数据不会被覆盖。</p><p>我们这里只分析基于块的NIO方式，在JAVA中这个块就是ByteBuffer。</p><h2 id="4-Linux下零拷贝原理"><a href="#4-Linux下零拷贝原理" class="headerlink" title="4. Linux下零拷贝原理"></a>4. Linux下零拷贝原理</h2><p>大部分web服务器都要处理大量的静态内容，而其中大部分都是从磁盘文件中读取数据然后写到socket中。我们以这个过程为例子，来看下不同模式下Linux工作流程</p><h3 id="4-1-普通Read-Write模式"><a href="#4-1-普通Read-Write模式" class="headerlink" title="4.1. 普通Read/Write模式"></a>4.1. 普通Read/Write模式</h3><p>涉及的代码抽象：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">//从文件中读取，存入tmp_bufread(file, tmp_buf, len);//将tmp_buf写入socketwrite(socket, tmp_buf, len);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>看上去很简单的步骤但是经过了很多复制：</p><ol><li>当调用 read 系统调用时，通过 DMA（Direct Memory Access）将数据 copy 到内核模式</li><li>然后由 CPU 控制将内核模式数据 copy 到用户模式下的 buffer 中</li><li>read 调用完成后，write 调用首先将用户模式下 buffer 中的数据 copy 到内核模式下的 socket buffer 中</li><li>最后通过 DMA copy 将内核模式下的 socket buffer 中的数据 copy 到网卡设备中传送。</li></ol><p>从上面的过程可以看出，数据白白从内核模式到用户模式走了一圈，浪费了两次 copy(第一次，从kernel模式拷贝到user模式；第二次从user模式再拷贝回kernel模式，即上面4次过程的第2和3步骤。)，而这两次 copy 都是 CPU copy，即占用CPU资源</p><h3 id="4-2-sendfile模式"><a href="#4-2-sendfile模式" class="headerlink" title="4.2. sendfile模式"></a>4.2. sendfile模式</h3><p><img src="/2021/05/08/java-dui-zhan-nei-cun-yu-dui-wai-nei-cun/v2-2dd88958164ecc10b419f8ec741dbbe1_720w.jpg" alt="img"></p><p>通过 sendfile 传送文件只需要一次系统调用，当调用 sendfile 时：</p><ol><li>首先通过 DMA copy 将数据从磁盘读取到 kernel buffer 中</li><li>然后通过 CPU copy 将数据从 kernel buffer copy 到 sokcet buffer 中</li><li>最终通过 DMA copy 将 socket buffer 中数据 copy 到网卡 buffer 中发送 sendfile 与 read/write 方式相比，少了 一次模式切换一次 CPU copy。但是从上述过程中也可以发现从 kernel buffer 中将数据 copy 到socket buffer 是没必要的。</li></ol><h3 id="4-3-sendfile模式改进"><a href="#4-3-sendfile模式改进" class="headerlink" title="4.3. sendfile模式改进"></a>4.3. sendfile模式改进</h3><p>Linux2.4 内核对sendFile模式进行了改进：</p><p><img src="/2021/05/08/java-dui-zhan-nei-cun-yu-dui-wai-nei-cun/v2-d12a3c0a2cc43a104860e90ce835163a_720w.jpg" alt="img"></p><p>改进后的处理过程如下：</p><ol><li>DMA copy 将磁盘数据 copy 到 kernel buffer 中 2.向 socket buffer 中追加当前要发送的数据在 kernel buffer 中的位置和偏移量</li><li>DMA gather copy 根据 socket buffer 中的位置和偏移量直接将 kernel buffer 中的数据 copy 到网卡上。</li></ol><p>经过上述过程，数据只经过了 2 次 copy 就从磁盘传送出去了。（事实上这个 Zero copy 是针对内核来讲的，数据在内核模式下是 Zero－copy 的）。</p><p>当前许多高性能 http server 都引入了 sendfile 机制，如 nginx，lighttpd 等。</p><h2 id="5-Java零拷贝实现的变化"><a href="#5-Java零拷贝实现的变化" class="headerlink" title="5. Java零拷贝实现的变化"></a>5. Java零拷贝实现的变化</h2><p>Zero-Copy技术省去了将操作系统的read buffer拷贝到程序的buffer，以及从程序buffer拷贝到socket buffer的步骤，直接将read buffer拷贝到socket buffer. Java NIO中的FileChannal.transferTo()方法就是这样的实现</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">public void transferTo(long position,long count,WritableByteChannel target);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>transferTo()方法将数据从一个channel传输到另一个可写的channel上，其内部实现依赖于操作系统对zero copy技术的支持。在unix操作系统和各种linux的发型版本中，这种功能最终是通过sendfile()系统调用实现。下边就是这个方法的定义：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">#include &lt;sys/socket.h&gt;ssize_t sendfile(int out_fd, int in_fd, off_t *offset, size_t count);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="5-1-Linux-2-4之前的底层实现"><a href="#5-1-Linux-2-4之前的底层实现" class="headerlink" title="5.1. Linux 2.4之前的底层实现"></a>5.1. Linux 2.4之前的底层实现</h3><p>和之前所述一样，我们用下面两幅图更清楚的展示一下发生的复制以及内核态用户态切换：</p><p><img src="/2021/05/08/java-dui-zhan-nei-cun-yu-dui-wai-nei-cun/v2-19e824356374ffa2e1cd1c9e6befc078_b.webp" alt="img"></p><p><img src="/2021/05/08/java-dui-zhan-nei-cun-yu-dui-wai-nei-cun/v2-a56109754a1558f5b64b8f02e45ddcc4_b.jpg" alt="img"></p><p>内核、用户态切换的次数只有两次，将数据的复制次只有三次(只有一次用到cpu资源) 在Linux2.4之后，我们可以将这仅有的一次cpu复制也去掉</p><h3 id="5-2-Linux-2-4之后的底层实现"><a href="#5-2-Linux-2-4之后的底层实现" class="headerlink" title="5.2. Linux 2.4之后的底层实现"></a>5.2. Linux 2.4之后的底层实现</h3><p><img src="/2021/05/08/java-dui-zhan-nei-cun-yu-dui-wai-nei-cun/v2-61882b6e8a11b6ae6d60f69ba12fdbd9_b.jpg" alt="img"></p><p>在内核为2.4或者以上版本的linux系统上，socket缓冲区描述符将被用来满足这个需求。这个方式不仅减少了内核用户态间的切换，而且也省去了那次需要cpu参与的复制过程。 从用户角度来看依旧是调用transferTo()方法，但是其本质发生了变化：</p><ol><li>调用transferTo方法后数据被DMA从文件复制到了内核的一个缓冲区中。</li><li>数据不再被复制到socket关联的缓冲区中了，仅仅是将一个描述符（包含了数据的位置和长度等信息）追加到socket关联的缓冲区中。DMA直接将内核中的缓冲区中的数据传输给协议引擎，消除了仅剩的一次需要cpu周期的数据复制。</li></ol><h3 id="5-3-对于JAVA普通字节流IO与NIOFileChannel实现的零拷贝性能："><a href="#5-3-对于JAVA普通字节流IO与NIOFileChannel实现的零拷贝性能：" class="headerlink" title="5.3 对于JAVA普通字节流IO与NIOFileChannel实现的零拷贝性能："></a>5.3 对于JAVA普通字节流IO与NIOFileChannel实现的零拷贝性能：</h3><p>直接上源码：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">BufferedInputStream</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">BufferedOutputStream</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">File</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">FileInputStream</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">FileNotFoundException</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">FileOutputStream</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">IOException</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">InputStream</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">OutputStream</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>nio<span class="token punctuation">.</span>channels<span class="token punctuation">.</span></span><span class="token class-name">FileChannel</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FileCopyTest</span> <span class="token punctuation">{</span>    <span class="token comment">/**     * 通过字节流的方式复制文件     * @param fromFile 源文件     * @param toFile   目标文件     * @throws FileNotFoundException 未找到文件异常     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">fileCopyNormal</span><span class="token punctuation">(</span><span class="token class-name">File</span> fromFile<span class="token punctuation">,</span> <span class="token class-name">File</span> toFile<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">FileNotFoundException</span> <span class="token punctuation">{</span>        <span class="token class-name">InputStream</span> inputStream <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token class-name">OutputStream</span> outputStream <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            inputStream <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedInputStream</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span>fromFile<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            outputStream <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedOutputStream</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">FileOutputStream</span><span class="token punctuation">(</span>toFile<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">//用户态缓冲有1kB这么大，不算小了</span>            <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> bytes <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token number">1024</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> i<span class="token punctuation">;</span>            <span class="token comment">//读取到输入流数据，然后写入到输出流中去，实现复制</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>i <span class="token operator">=</span> inputStream<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span>bytes<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                outputStream<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>bytes<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>inputStream <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    inputStream<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>outputStream <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    outputStream<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment">/**     * 用filechannel进行文件复制     *     * @param fromFile 源文件     * @param toFile   目标文件     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">fileCopyWithFileChannel</span><span class="token punctuation">(</span><span class="token class-name">File</span> fromFile<span class="token punctuation">,</span> <span class="token class-name">File</span> toFile<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">FileInputStream</span> fileInputStream <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token class-name">FileOutputStream</span> fileOutputStream <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token class-name">FileChannel</span> fileChannelInput <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token class-name">FileChannel</span> fileChannelOutput <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            fileInputStream <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span>fromFile<span class="token punctuation">)</span><span class="token punctuation">;</span>            fileOutputStream <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileOutputStream</span><span class="token punctuation">(</span>toFile<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">//得到fileInputStream的文件通道</span>            fileChannelInput <span class="token operator">=</span> fileInputStream<span class="token punctuation">.</span><span class="token function">getChannel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">//得到fileOutputStream的文件通道</span>            fileChannelOutput <span class="token operator">=</span> fileOutputStream<span class="token punctuation">.</span><span class="token function">getChannel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">//将fileChannelInput通道的数据，写入到fileChannelOutput通道</span>            fileChannelInput<span class="token punctuation">.</span><span class="token function">transferTo</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> fileChannelInput<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> fileChannelOutput<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>fileInputStream <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    fileInputStream<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>fileChannelInput <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    fileChannelInput<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>fileOutputStream <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    fileOutputStream<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>fileChannelOutput <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    fileChannelOutput<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">{</span>        <span class="token class-name">File</span> fromFile <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">File</span><span class="token punctuation">(</span><span class="token string">"D:/readFile.txt"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">File</span> toFile <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">File</span><span class="token punctuation">(</span><span class="token string">"D:/outputFile.txt"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//预热</span>        <span class="token function">fileCopyNormal</span><span class="token punctuation">(</span>fromFile<span class="token punctuation">,</span> toFile<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">fileCopyWithFileChannel</span><span class="token punctuation">(</span>fromFile<span class="token punctuation">,</span> toFile<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//计时</span>        <span class="token keyword">long</span> start <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">1000</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">fileCopyNormal</span><span class="token punctuation">(</span>fromFile<span class="token punctuation">,</span> toFile<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"fileCopyNormal time: "</span> <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> start<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        start <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">1000</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">fileCopyWithFileChannel</span><span class="token punctuation">(</span>fromFile<span class="token punctuation">,</span> toFile<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"fileCopyWithFileChannel time: "</span> <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> start<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>测试结果：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">fileCopyNormal time: 14271fileCopyWithFileChannel time: 6632<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>差了一倍多的时间（文件大小大概8MB），如果文件更大这个差距应该更加明显。</p><h2 id="6-DirectBuffer分配"><a href="#6-DirectBuffer分配" class="headerlink" title="6. DirectBuffer分配"></a>6. DirectBuffer分配</h2><p>Java中NIO的核心缓冲就是ByteBuffer，所有的IO操作都是通过这个ByteBuffer进行的；Bytebuffer有两种： <strong>分配HeapByteBuffer</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">ByteBuffer</span> buffer <span class="token operator">=</span> <span class="token class-name">ByteBuffer</span><span class="token punctuation">.</span><span class="token function">allocate</span><span class="token punctuation">(</span><span class="token keyword">int</span> capacity<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>分配DirectByteBuffer</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">ByteBuffer</span> buffer <span class="token operator">=</span> <span class="token class-name">ByteBuffer</span><span class="token punctuation">.</span><span class="token function">allocateDirect</span><span class="token punctuation">(</span><span class="token keyword">int</span> capacity<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>两者的区别：</p><p><img src="/2021/05/08/java-dui-zhan-nei-cun-yu-dui-wai-nei-cun/v2-efa63bd49d8399351d3d4e8f2288d00b_720w.jpg" alt="img"></p><h3 id="6-1-为何HeapByteBuffer会多一次拷贝？"><a href="#6-1-为何HeapByteBuffer会多一次拷贝？" class="headerlink" title="6.1. 为何HeapByteBuffer会多一次拷贝？"></a>6.1. 为何HeapByteBuffer会多一次拷贝？</h3><h3 id="6-1-1-FileChannel的force-api说明"><a href="#6-1-1-FileChannel的force-api说明" class="headerlink" title="6.1.1. FileChannel的force api说明"></a>6.1.1. FileChannel的force api说明</h3><p>FileChannel的force方法： FileChannel.force()方法将通道里尚未写入磁盘的数据强制写到磁盘上。出于性能方面的考虑，操作系统会将数据缓存在内存中，所以无法保证写入到FileChannel里的数据一定会即时写到磁盘上。要保证这一点，需要调用force()方法。 force()方法有一个boolean类型的参数，指明是否同时将文件元数据（权限信息等）写到磁盘上。</p><h3 id="6-1-2-FileChannel和SocketChannel依赖的IOUtil源码解析"><a href="#6-1-2-FileChannel和SocketChannel依赖的IOUtil源码解析" class="headerlink" title="6.1.2. FileChannel和SocketChannel依赖的IOUtil源码解析"></a>6.1.2. FileChannel和SocketChannel依赖的IOUtil源码解析</h3><p>无论是FileChannel还是SocketChannel，他们的读写方法都依赖IOUtil的相同方法，我们这里来看下： <strong>IOUtil.java</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">write</span><span class="token punctuation">(</span><span class="token class-name">FileDescriptor</span> var0<span class="token punctuation">,</span> <span class="token class-name">ByteBuffer</span> var1<span class="token punctuation">,</span> <span class="token keyword">long</span> var2<span class="token punctuation">,</span> <span class="token class-name">NativeDispatcher</span> var4<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">{</span>    <span class="token comment">//如果是DirectBuffer，直接写</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>var1 <span class="token keyword">instanceof</span> <span class="token class-name">DirectBuffer</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">writeFromNativeBuffer</span><span class="token punctuation">(</span>var0<span class="token punctuation">,</span> var1<span class="token punctuation">,</span> var2<span class="token punctuation">,</span> var4<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token comment">//非DirectBuffer</span>        <span class="token comment">//获取已经读取到的位置</span>        <span class="token keyword">int</span> var5 <span class="token operator">=</span> var1<span class="token punctuation">.</span><span class="token function">position</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//获取可以读到的位置</span>        <span class="token keyword">int</span> var6 <span class="token operator">=</span> var1<span class="token punctuation">.</span><span class="token function">limit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">assert</span> var5 <span class="token operator">&lt;=</span> var6<span class="token punctuation">;</span>        <span class="token comment">//申请一个源buffer可读大小的DirectByteBuffer</span>        <span class="token keyword">int</span> var7 <span class="token operator">=</span> var5 <span class="token operator">&lt;=</span> var6 <span class="token operator">?</span> var6 <span class="token operator">-</span> var5 <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token class-name">ByteBuffer</span> var8 <span class="token operator">=</span> <span class="token class-name">Util</span><span class="token punctuation">.</span><span class="token function">getTemporaryDirectBuffer</span><span class="token punctuation">(</span>var7<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> var10<span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            var8<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>var1<span class="token punctuation">)</span><span class="token punctuation">;</span>            var8<span class="token punctuation">.</span><span class="token function">flip</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            var1<span class="token punctuation">.</span><span class="token function">position</span><span class="token punctuation">(</span>var5<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">//通过DirectBuffer写</span>            <span class="token keyword">int</span> var9 <span class="token operator">=</span> <span class="token function">writeFromNativeBuffer</span><span class="token punctuation">(</span>var0<span class="token punctuation">,</span> var8<span class="token punctuation">,</span> var2<span class="token punctuation">,</span> var4<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>var9 <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                var1<span class="token punctuation">.</span><span class="token function">position</span><span class="token punctuation">(</span>var5 <span class="token operator">+</span> var9<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            var10 <span class="token operator">=</span> var9<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>            <span class="token comment">//回收分配的DirectByteBuffer</span>            <span class="token class-name">Util</span><span class="token punctuation">.</span><span class="token function">offerFirstTemporaryDirectBuffer</span><span class="token punctuation">(</span>var8<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> var10<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment">//读的方法和写类似，这里省略</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="6-1-3-为何一定要复制到DirectByteBuffer来读写（系统调用）"><a href="#6-1-3-为何一定要复制到DirectByteBuffer来读写（系统调用）" class="headerlink" title="6.1.3. 为何一定要复制到DirectByteBuffer来读写（系统调用）"></a>6.1.3. 为何一定要复制到DirectByteBuffer来读写（系统调用）</h3><p>首先，先说一点，执行native方法的线程，被认为是处于SafePoint，所以，会发生 NIO 如果不复制到 DirectByteBuffer，就会有 GC 发生重排列对象内存的情况（可以参考我的另一篇文章： <a href="https://link.zhihu.com/?target=https://blog.csdn.net/zhxdick/article/details/107450858%EF%BC%89%E3%80%82">https://blog.csdn.net/zhxdick/article/details/107450858）。</a></p><p>传统 BIO 是面向 Stream 的，底层实现可以理解为写入的是 byte 数组，调用 native 方法写入 IO，传的参数是这个数组，就算GC改变了内存地址，但是拿这个数组的引用照样能找到最新的地址，，对应的方法时是：FileOutputStream.write</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">native</span> <span class="token keyword">void</span> <span class="token function">writeBytes</span><span class="token punctuation">(</span><span class="token keyword">byte</span> b<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> off<span class="token punctuation">,</span> <span class="token keyword">int</span> len<span class="token punctuation">,</span> <span class="token keyword">boolean</span> append<span class="token punctuation">)</span>        <span class="token keyword">throws</span> <span class="token class-name">IOException</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>但是NIO，为了提升效率，传的是内存地址，省去了一次间接应用，但是就必须用 DirectByteBuffer 防止内存地址改变，对应的是 NativeDispatcher.write</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">abstract</span> <span class="token keyword">int</span> <span class="token function">write</span><span class="token punctuation">(</span><span class="token class-name">FileDescriptor</span> fd<span class="token punctuation">,</span> <span class="token keyword">long</span> address<span class="token punctuation">,</span> <span class="token keyword">int</span> len<span class="token punctuation">)</span>        <span class="token keyword">throws</span> <span class="token class-name">IOException</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>那为何内存地址会改变呢？GC会回收无用对象，同时还会进行碎片整理，移动对象在内存中的位置，来减少内存碎片。DirectByteBuffer不受GC控制。如果不用DirectByteBuffer而是用HeapByteBuffer，如果在调用系统调用时，发生了GC，导致HeapByteBuffer内存位置发生了变化，但是内核态并不能感知到这个变化导致系统调用读取或者写入错误的数据。所以一定要通过不受GC影响的DirectByteBuffer来进行IO系统调用。</p><p>假设我们要从网络中读入一段数据，再把这段数据发送出去的话，采用Non-direct ByteBuffer的流程是这样的：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">网络 –&gt; 临时的DirectByteBuffer –&gt; 应用 Non-direct ByteBuffer –&gt; 临时的Direct ByteBuffer –&gt; 网络<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这种方式是直接在堆外分配一个内存(即，native memory)来存储数据， 程序通过JNI直接将数据读/写到堆外内存中。因为数据直接写入到了堆外内存中，所以这种方式就不会再在JVM管控的堆内再分配内存来存储数据了，也就不存在堆内内存和堆外内存数据拷贝的操作了。这样在进行I/O操作时，只需要将这个堆外内存地址传给JNI的I/O的函数就好了。</p><p>采用Direct ByteBuffer的流程是这样的：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">网络 –&gt; 应用 Direct ByteBuffer –&gt; 网络<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>可以看到，除开构造和析构临时Direct ByteBuffer的时间外，起码还能节约两次内存拷贝的时间。那么是否在任何情况下都采用Direct Buffer呢？</p><p>不是。对于大部分应用而言，两次内存拷贝的时间几乎可以忽略不计，而构造和析构DirectBuffer的时间却相对较长。在JVM的实现当中，某些方法会缓存一部分临时Direct ByteBuffer，意味着如果采用Direct ByteBuffer仅仅能节约掉两次内存拷贝的时间， 而无法节约构造和析构的时间。就用Sun的实现来说，write(ByteBuffer)和read(ByteBuffer)方法都会缓存临时Direct ByteBuffer，而write(ByteBuffer[])和read(ByteBuffer[])每次都生成新的临时Direct ByteBuffer。</p><h3 id="6-2-ByteBuffer创建"><a href="#6-2-ByteBuffer创建" class="headerlink" title="6.2. ByteBuffer创建"></a>6.2. ByteBuffer创建</h3><h3 id="6-2-1-ByteBuffer创建HeapByteBuffer"><a href="#6-2-1-ByteBuffer创建HeapByteBuffer" class="headerlink" title="6.2.1. ByteBuffer创建HeapByteBuffer"></a>6.2.1. ByteBuffer创建HeapByteBuffer</h3><p>分配在堆上的，直接由Java虚拟机负责垃圾收集，你可以把它想象成一个字节数组的包装类</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">HeapByteBuffer</span>    <span class="token keyword">extends</span> <span class="token class-name">ByteBuffer</span><span class="token punctuation">{</span>    <span class="token class-name">HeapByteBuffer</span><span class="token punctuation">(</span><span class="token keyword">int</span> cap<span class="token punctuation">,</span> <span class="token keyword">int</span> lim<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment">// package-private</span>        <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> lim<span class="token punctuation">,</span> cap<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token keyword">byte</span><span class="token punctuation">[</span>cap<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">/*        hb = new byte[cap];        offset = 0;        */</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">ByteBuffer</span>    <span class="token keyword">extends</span> <span class="token class-name">Buffer</span>    <span class="token keyword">implements</span> <span class="token class-name">Comparable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">ByteBuffer</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">{</span>    <span class="token comment">// These fields are declared here rather than in Heap-X-Buffer in order to</span>    <span class="token comment">// reduce the number of virtual method invocations needed to access these</span>    <span class="token comment">// values, which is especially costly when coding small buffers.</span>    <span class="token comment">//</span>    <span class="token keyword">final</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> hb<span class="token punctuation">;</span>                  <span class="token comment">// Non-null only for heap buffers</span>    <span class="token keyword">final</span> <span class="token keyword">int</span> offset<span class="token punctuation">;</span>    <span class="token keyword">boolean</span> isReadOnly<span class="token punctuation">;</span>                 <span class="token comment">// Valid only for heap buffers</span>    <span class="token comment">// Creates a new buffer with the given mark, position, limit, capacity,</span>    <span class="token comment">// backing array, and array offset</span>    <span class="token comment">//</span>    <span class="token class-name">ByteBuffer</span><span class="token punctuation">(</span><span class="token keyword">int</span> mark<span class="token punctuation">,</span> <span class="token keyword">int</span> pos<span class="token punctuation">,</span> <span class="token keyword">int</span> lim<span class="token punctuation">,</span> <span class="token keyword">int</span> cap<span class="token punctuation">,</span>   <span class="token comment">// package-private</span>                 <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> hb<span class="token punctuation">,</span> <span class="token keyword">int</span> offset<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">(</span>mark<span class="token punctuation">,</span> pos<span class="token punctuation">,</span> lim<span class="token punctuation">,</span> cap<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>hb <span class="token operator">=</span> hb<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>offset <span class="token operator">=</span> offset<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="6-2-2-DirectByteBuffer"><a href="#6-2-2-DirectByteBuffer" class="headerlink" title="6.2.2. DirectByteBuffer"></a>6.2.2. DirectByteBuffer</h3><p>这个类就没有HeapByteBuffer简单了</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">DirectByteBuffer</span><span class="token punctuation">(</span><span class="token keyword">int</span> cap<span class="token punctuation">)</span> <span class="token punctuation">{</span>                   <span class="token comment">// package-private</span>    <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> cap<span class="token punctuation">,</span> cap<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">boolean</span> pa <span class="token operator">=</span> VM<span class="token punctuation">.</span><span class="token function">isDirectMemoryPageAligned</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> ps <span class="token operator">=</span> <span class="token class-name">Bits</span><span class="token punctuation">.</span><span class="token function">pageSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">long</span> size <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token number">1L</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span>cap <span class="token operator">+</span> <span class="token punctuation">(</span>pa <span class="token operator">?</span> ps <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">Bits</span><span class="token punctuation">.</span><span class="token function">reserveMemory</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span> cap<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">long</span> base <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        base <span class="token operator">=</span> unsafe<span class="token punctuation">.</span><span class="token function">allocateMemory</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">OutOfMemoryError</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">Bits</span><span class="token punctuation">.</span><span class="token function">unreserveMemory</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span> cap<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">throw</span> x<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    unsafe<span class="token punctuation">.</span><span class="token function">setMemory</span><span class="token punctuation">(</span>base<span class="token punctuation">,</span> size<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">byte</span><span class="token punctuation">)</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>pa <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>base <span class="token operator">%</span> ps <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// Round up to page boundary</span>        address <span class="token operator">=</span> base <span class="token operator">+</span> ps <span class="token operator">-</span> <span class="token punctuation">(</span>base <span class="token operator">&amp;</span> <span class="token punctuation">(</span>ps <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        address <span class="token operator">=</span> base<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    cleaner <span class="token operator">=</span> <span class="token class-name">Cleaner</span><span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Deallocator</span><span class="token punctuation">(</span>base<span class="token punctuation">,</span> size<span class="token punctuation">,</span> cap<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    att <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Bits.reserveMemory(size, cap) 方法</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">reserveMemory</span><span class="token punctuation">(</span><span class="token keyword">long</span> size<span class="token punctuation">,</span> <span class="token keyword">int</span> cap<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token class-name">Bits</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>memoryLimitSet <span class="token operator">&amp;&amp;</span> VM<span class="token punctuation">.</span><span class="token function">isBooted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            maxMemory <span class="token operator">=</span> VM<span class="token punctuation">.</span><span class="token function">maxDirectMemory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            memoryLimitSet <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment">// -XX:MaxDirectMemorySize limits the total capacity rather than the</span>        <span class="token comment">// actual memory usage, which will differ when buffers are page</span>        <span class="token comment">// aligned.</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>cap <span class="token operator">&lt;=</span> maxMemory <span class="token operator">-</span> totalCapacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>            reservedMemory <span class="token operator">+=</span> size<span class="token punctuation">;</span>            totalCapacity <span class="token operator">+=</span> cap<span class="token punctuation">;</span>            count<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">gc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// Restore interrupt status</span>        <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">interrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token class-name">Bits</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>totalCapacity <span class="token operator">+</span> cap <span class="token operator">&gt;</span> maxMemory<span class="token punctuation">)</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">OutOfMemoryError</span><span class="token punctuation">(</span><span class="token string">"Direct buffer memory"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        reservedMemory <span class="token operator">+=</span> size<span class="token punctuation">;</span>        totalCapacity <span class="token operator">+=</span> cap<span class="token punctuation">;</span>        count<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在DirectByteBuffer中，首先向Bits类申请额度，Bits类有一个全局的totalCapacity变量，记录着全部DirectByteBuffer的总大小，每次申请，都先看看是否超限,堆外内存的限额默认与堆内内存(由-Xmx 设定)相仿，可用 -XX:MaxDirectMemorySize 重新设定。</p><blockquote><p>如果不指定，该参数的默认值为Xmx的值减去1个Survior区的值。 如设置启动参数-Xmx20M -Xmn10M -XX：SurvivorRatio=8,那么申请20M-1M=19M的DirectMemory</p></blockquote><p>如果已经超限，会主动执行Sytem.gc()，期待能主动回收一点堆外内存。System.gc()会触发一个full gc，当然前提是你没有显示的设置-XX:+DisableExplicitGC来禁用显式GC。并且你需要知道，调用System.gc()并不能够保证full gc马上就能被执行。然后休眠一百毫秒，看看totalCapacity降下来没有，如果内存还是不足，就抛出OOM异常。如果额度被批准，就调用大名鼎鼎的sun.misc.Unsafe去分配内存,返回内存基地址</p><p><strong>所以，一般的框架里面，会在启动时申请一大块DirectByteBuffer，然后自己做内存管理</strong></p><p>最后，创建一个Cleaner，并把代表清理动作的Deallocator类绑定 – 降低Bits里的totalCapacity，并调用Unsafe调free去释放内存。</p><h3 id="6-2-3-ByteBuffer回收"><a href="#6-2-3-ByteBuffer回收" class="headerlink" title="6.2.3. ByteBuffer回收"></a>6.2.3. ByteBuffer回收</h3><p>HeapByteBuffer就不要说了，GC就帮忙处理了。这儿主要说下DirectByteBuffer 存在于堆内的DirectByteBuffer对象很小，只存着基地址和大小等几个属性，和一个Cleaner，但它代表着后面所分配的一大段内存，是所谓的冰山对象。</p><p><img src="/2021/05/08/java-dui-zhan-nei-cun-yu-dui-wai-nei-cun/v2-9927b76bb9f0b3083524b079c5ed52b2_720w.jpg" alt="img"></p><p>其中first是Cleaner类的静态变量，Cleaner对象在初始化时会被添加到Clener链表中，和first形成引用关系，ReferenceQueue是用来保存需要回收的Cleaner对象。</p><p>如果该DirectByteBuffer对象在一次GC中被回收了</p><p><img src="/2021/05/08/java-dui-zhan-nei-cun-yu-dui-wai-nei-cun/v2-385fcb32ebf4b5fc59ddd1c5548b7e39_720w.jpg" alt="img"></p><p>此时，只有Cleaner对象唯一保存了堆外内存的数据（开始地址、大小和容量），在下一次Full GC时，把该Cleaner对象放入到ReferenceQueue中，并触发clean方法。</p><p>快速回顾一下堆内的GC机制，当新生代满了，就会发生young gc；如果此时对象还没失效，就不会被回收；撑过几次young gc后，对象被迁移到老生代；当老生代也满了，就会发生full gc。</p><p>这里可以看到一种尴尬的情况，因为DirectByteBuffer本身的个头很小，只要熬过了young gc，即使已经失效了也能在老生代里舒服的呆着，不容易把老生代撑爆触发full gc，如果没有别的大块头进入老生代触发full gc，就一直在那耗着，占着一大片堆外内存不释放。</p><p>这时，就只能靠前面提到的申请额度超限时触发的system.gc()来救场了。但这道最后的保险其实也不很好，首先它会中断整个进程，然后它让当前线程睡了整整一百毫秒，而且如果gc没在一百毫秒内完成，它仍然会无情的抛出OOM异常。还有，万一，万一大家迷信某个调优指南设置了-DisableExplicitGC禁止了system.gc()，那就不好玩了。</p><p>所以，堆外内存还是自己主动点回收更好，比如Netty就是这么做的</p><h2 id="7-查看DirectBuffer使用情况的方法："><a href="#7-查看DirectBuffer使用情况的方法：" class="headerlink" title="7. 查看DirectBuffer使用情况的方法："></a>7. 查看DirectBuffer使用情况的方法：</h2><h3 id="7-1-进程内获取："><a href="#7-1-进程内获取：" class="headerlink" title="7.1. 进程内获取："></a>7.1. 进程内获取：</h3><pre class="line-numbers language-text" data-language="text"><code class="language-text">MBeanServer mbs = ManagementFactory. getPlatformMBeanServer() ;ObjectName objectName = new ObjectName("java.nio:type=BufferPool,name=direct" ) ;MBeanInfo info = mbs.getMBeanInfo(objectName) ;for(MBeanAttributeInfo i : info.getAttributes()) {    System.out .println(i.getName() + ":" + mbs.getAttribute(objectName , i.getName()));}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="7-2-远程进程"><a href="#7-2-远程进程" class="headerlink" title="7.2. 远程进程"></a>7.2. 远程进程</h3><p>JMX获取 如果目标机器没有启动JMX，那么添加jvm参数：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">-Dcom.sun.management.jmxremote.port=9999 -Dcom.sun.management.jmxremote.authenticate=false -Dcom.sun.management.jmxremotAe.ssl=false<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>重启进程 然后本机通过JMX连接访问：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">String jmxURL = "service:jmx:rmi:///jndi/rmi://10.125.6.204:9999/jmxrmi" ;JMXServiceURL serviceURL = new JMXServiceURL(jmxURL);Map map = new HashMap() ;String[] credentials = new String[] { "monitorRole" , "QED" } ;map.put( "jmx.remote.credentials" , credentials) ;JMXConnector connector = JMXConnectorFactory. connect(serviceURL , map);MBeanServerConnection mbsc = connector.getMBeanServerConnection() ;ObjectName objectName = new ObjectName("java.nio:type=BufferPool,name=direct" ) ;MBeanInfo mbInfo = mbsc.getMBeanInfo(objectName) ;for(MBeanAttributeInfo i : mbInfo.getAttributes()) {    System.out .println(i.getName() + ":" + mbsc.getAttribute(objectName , i.getName()));}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>本地也可以通过 JConsole 工具查看：</p><p><strong>但是注意，采集不要太频繁。否则会触发所有线程进入安全点（也就是 Stop the world）</strong></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>netty</title>
      <link href="2021/05/01/netty/"/>
      <url>2021/05/01/netty/</url>
      
        <content type="html"><![CDATA[<h1 id="Netty"><a href="#Netty" class="headerlink" title="Netty"></a>Netty</h1><h2 id="1-IO模型"><a href="#1-IO模型" class="headerlink" title="1. IO模型"></a>1. IO模型</h2><ul><li>BIO 适用于连接数目较小且固定的架构，这种方式对于服务器资源要求较高，有并发局限，JDK1.4以前的唯一选择，但程序简单易理解。基于字节流和字符流，以流的方式进行，阻塞。</li><li>NIO 适用于连接数目多且连接比较短（轻操作）的架构，比如聊天服务器，弹幕系统，服务器间通讯等。编程比较复杂，JDK1.4开始支持。基于channel和buffer，以块的方式进行，不阻塞。</li><li>AIO 适用于连接数目多且连接时间长（重操作）的架构，比如相册服务器，充分调用OS参与并发操作，编程比较复杂，JDK7开始支持。</li></ul><p>netty基于NIO。</p><h3 id="1-1-NIO"><a href="#1-1-NIO" class="headerlink" title="1.1 NIO"></a>1.1 NIO</h3><h4 id="1-1-1-buffer"><a href="#1-1-1-buffer" class="headerlink" title="1.1.1 buffer"></a><strong>1.1.1 buffer</strong></h4><p>（为什么）它是为了实现缓冲区的概念而产生的。</p><p>（是什么）是一种缓冲区的抽象类（<code>abstract class</code>）。本质上是一个可以读写数据的内存块，可以理解成是一个容器对象（含数组），该对象提供了一组方法，可以更轻松地使用内存块，缓冲区对象内置了一些机制，能够跟踪和记录缓冲区的状态变化情况。</p><p>（怎么做）四个属性：</p><p><img src="/2021/05/01/netty/Buffer_nio.PNG"></p><ol><li>capacity 容量，即可以容纳的最大数据量。在缓冲区创建时被设定并且不能改变。</li><li>limit 缓冲区当前终点，不能对缓冲区超过极限位置进行读写操作。且极限位置可以修改的</li><li>position 位置，下一个要被读或写的元素的索引，每次读写缓冲区数据时都会改变值，为下次读写作准备。</li><li>mark 标记</li></ol><ul><li><p>注意</p><p>buffer中存放的数据类型，放入和取除的数据类型必须一致。否则抛出<code>BufferUnderflowException</code>异常。</p></li></ul><p>使用：</p><h5 id="1-ReadOnlyBuffer"><a href="#1-ReadOnlyBuffer" class="headerlink" title="1.ReadOnlyBuffer"></a>1.ReadOnlyBuffer</h5><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">ByteBuffer</span> readBuffer <span class="token operator">=</span> buffer<span class="token punctuation">.</span><span class="token function">asReadOnlyBuffer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span>readOnlyBuffer<span class="token punctuation">.</span><span class="token function">hasRemaining</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>readOnlyBuffer<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">// 错误的异常</span>readOnlyBuffer<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">byte</span><span class="token punctuation">)</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//ReadOnlyBufferException</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="2-MappedByteBuffer"><a href="#2-MappedByteBuffer" class="headerlink" title="2. MappedByteBuffer"></a>2. MappedByteBuffer</h5><p>这个buffer可以让文件直接在内存中进行修改，而如何同步到文件由NIO来完成。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Test</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">{</span>        <span class="token class-name">RandomAccessFile</span> accessFile <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RandomAccessFile</span><span class="token punctuation">(</span><span class="token string">"1.txt"</span><span class="token punctuation">,</span> <span class="token string">"rw"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//获取对应的通道</span>        <span class="token class-name">FileChannel</span> channel <span class="token operator">=</span> accessFile<span class="token punctuation">.</span><span class="token function">getChannel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">/**         * 使用的读写模式         * 可以直接修改的读写位置         * 映射到内存的大小，即将 1.txt 的多少个字节映射到内存         * 可以直接修改的范围是 0-5         */</span>        <span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>nio<span class="token punctuation">.</span></span>MappedByteBuffer</span> mappedByteBuffer <span class="token operator">=</span> channel<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token class-name">FileChannel<span class="token punctuation">.</span>MapMode</span><span class="token punctuation">.</span>READ_WRITE<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        mappedByteBuffer<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">byte</span><span class="token punctuation">)</span> <span class="token string">'H'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//抛出异常，超出索引范围</span>        mappedByteBuffer<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">byte</span><span class="token punctuation">)</span> <span class="token string">'0'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        accessFile<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="3-buffer分散和聚集"><a href="#3-buffer分散和聚集" class="headerlink" title="3. buffer分散和聚集"></a>3. buffer分散和聚集</h5><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Test</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span><span class="token punctuation">{</span>        <span class="token comment">// 使用ServerSocketChannel 和 SocketChannel</span>        <span class="token class-name">ServerSocketChannel</span> serverSocketChannel <span class="token operator">=</span> <span class="token class-name">ServerSocketChannel</span><span class="token punctuation">.</span><span class="token keyword">open</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">InetSocketAddress</span> inetSocketAddress <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">InetSocketAddress</span><span class="token punctuation">(</span><span class="token number">7000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        serverSocketChannel<span class="token punctuation">.</span><span class="token function">socket</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span>inetSocketAddress<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">ByteBuffer</span><span class="token punctuation">[</span><span class="token punctuation">]</span> byteBuffers <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ByteBuffer</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        byteBuffers<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token class-name">ByteBuffer</span><span class="token punctuation">.</span><span class="token function">allocate</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        byteBuffers<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token class-name">ByteBuffer</span><span class="token punctuation">.</span><span class="token function">allocate</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">SocketChannel</span> socketChannel <span class="token operator">=</span> serverSocketChannel<span class="token punctuation">.</span><span class="token function">accept</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 等客户端连接</span>        <span class="token comment">// 循环读取</span>        <span class="token keyword">int</span> clientByteLen <span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> byteRead <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>byteRead <span class="token operator">&lt;</span> clientByteLen<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">long</span> read <span class="token operator">=</span> socketChannel<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span>byteBuffers<span class="token punctuation">)</span><span class="token punctuation">;</span>                byteRead <span class="token operator">+=</span> read<span class="token punctuation">;</span>                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"byteRead = "</span> <span class="token operator">+</span> byteRead<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">// 使用流打印，看看当前这个buffer的position 和 limit</span>                <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span>byteBuffers<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>buffer <span class="token operator">-&gt;</span> <span class="token string">"posiiton"</span> <span class="token operator">+</span> buffer<span class="token punctuation">.</span><span class="token function">position</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">", limit="</span> <span class="token operator">+</span> buffer<span class="token punctuation">.</span><span class="token function">limit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token operator">::</span> <span class="token function">println</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">// 将所有的buffer进行反转</span>                <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span>byteBuffers<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>byteBuffer <span class="token operator">-&gt;</span> byteBuffer<span class="token punctuation">.</span><span class="token function">flip</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">// 将数据读出显示到客户端</span>                <span class="token keyword">long</span> byteWrite <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                <span class="token keyword">while</span> <span class="token punctuation">(</span>byteWrite <span class="token operator">&lt;</span> clientByteLen<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">long</span> write <span class="token operator">=</span> socketChannel<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>byteBuffers<span class="token punctuation">)</span><span class="token punctuation">;</span>                    byteWrite <span class="token operator">+=</span> write<span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span>byteBuffers<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>byteBuffer <span class="token operator">-&gt;</span> byteBuffer<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"byteRead:="</span> <span class="token operator">+</span> byteRead <span class="token operator">+</span> <span class="token string">" byteWrite = "</span> <span class="token operator">+</span> byteWrite<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>1.2 Channel</strong> 通道</p><p>（是什么）是一个接口(interface)</p><ul><li>通道可以同时读写，而流只能读或者只能写</li><li>通道可以实现异步读写数据</li><li>可以从缓冲区读数据，也可以写数据到缓冲</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Channel</span> <span class="token keyword">extends</span> <span class="token class-name">Closeable</span> <span class="token punctuation">{</span>    <span class="token comment">/**     * Tells whether or not this channel is open.     *     * @return &lt;tt&gt;true&lt;/tt&gt; if, and only if, this channel is open     */</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isOpen</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/**     * Closes this channel.     *     * &lt;p&gt; After a channel is closed, any further attempt to invoke I/O     * operations upon it will cause a {@link ClosedChannelException} to be     * thrown.     *     * &lt;p&gt; If this channel is already closed then invoking this method has no     * effect.     *     * &lt;p&gt; This method may be invoked at any time.  If some other thread has     * already invoked it, however, then another invocation will block until     * the first invocation is complete, after which it will return without     * effect. &lt;/p&gt;     *     * @throws  IOException  If an I/O error occurs     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>常用的<code>Channel</code>类有：<code>FileChannel</code>、<code>DatagramChannel</code>、<code>ServerSocketChannel</code>和<code>SocketChannel</code>。</p><p><code>FileChannel</code>用于文件的读写，<code>DatagramChannel</code>用于UDP的数据读写，<code>ServerSocketChannel</code>和<code>SocketChannel</code>用于TCP的数据读写。</p><h3 id="1-2-Selector"><a href="#1-2-Selector" class="headerlink" title="1.2 Selector"></a><strong>1.2 Selector</strong></h3><p>是什么？</p><p>Selector能够检测多个注册的通道上是否有事件发生。注意：多个Channel以事件的方式可以注册到同一个Selector。如果有事件发生，便获取事件然后针对每个事件进行相应的处理。这样就可以只用一个单线程去管理多个通道，也就是管理多个连接和请求。</p><p>怎么做？</p><p>Netty的IO线程<code>NioEventLoop</code>聚合了<code>Selector（选择器）</code>（也叫多路复用器），可以同时并发处理成百上千个客户端连接。</p><p>当线程从某客户端Socket通道进行读写数据时，若没有数据可用时，该线程可以进行其他任务。</p><h5 id="1-实现"><a href="#1-实现" class="headerlink" title="1. 实现"></a>1. 实现</h5><p>Selector类是一个抽象类</p><ul><li><p>select()阻塞。</p></li><li><p>select(long timeout) 监控所有注册的通道，当其中有IO操作可以进行时，将对应的<code>SelectionKey</code>加入到内部集合中并返回，参数用来设置超时时间。</p></li><li><p>wakeup() 唤醒selector</p></li><li><p>selectNow() 不阻塞，立马返回。</p></li><li><p>Set<selectionkey> selectedKeys(); //从内部集合中得到所有的SelectionKey。</selectionkey></p></li></ul><h5 id="2-NIO-非阻塞网络编程原理分析图"><a href="#2-NIO-非阻塞网络编程原理分析图" class="headerlink" title="2. NIO 非阻塞网络编程原理分析图"></a>2. NIO 非阻塞网络编程原理分析图</h5><ol><li>当客户端连接时，会通过<code>ServerSocketChannel</code>得到<code>SocketChannel</code>。</li><li>将socketChannel注册到Selector上，register(Selector sel, int ops)， 一个selector上可以注册多个SocketChannel。</li><li>注册后返回一个SelectionKey，会和该Selector关联（集合）。</li><li>Selector进行监听select方法，返回有事件发生的通道的个数。</li><li>进一步得到各个SelectionKey。</li><li>再通过SelectionKey得到注册的Channel。</li><li>通过得到的Channel完成业务处理。</li></ol><h2 id="2-零拷贝"><a href="#2-零拷贝" class="headerlink" title="2. 零拷贝"></a>2. 零拷贝</h2><p>零拷贝指的是从操作系统角度看的，没有CPU拷贝。</p><p>传统IO，四次拷贝，三次切换。</p><h3 id="3-1-mmap优化"><a href="#3-1-mmap优化" class="headerlink" title="3.1 mmap优化"></a>3.1 mmap优化</h3><ul><li>mmap通过内存映射，将文件映射到内核缓冲区，同时，用户空间可以共享内核空间的数据。这样，在进行网络传输时，就可以减少内核空间到用户空间的拷贝次数。</li></ul><p>拷贝减少为3次，内核态和用户态的切换仍然为3次。</p><p>适合小数据量。</p><h3 id="3-2-sendfile-优化"><a href="#3-2-sendfile-优化" class="headerlink" title="3.2 sendfile 优化"></a>3.2 sendfile 优化</h3><p>基本原理：直接从内核缓冲区进入到Socket Buffer。同时，由于和用户态完全无关，减少了一次上下文切换。</p><p>适合大文件传输。</p><p>只需要一次系统调用，最少2次数据拷贝。</p><h2 id="3-netty-架构"><a href="#3-netty-架构" class="headerlink" title="3. netty 架构"></a>3. netty 架构</h2><h3 id="3-1-其他线程模型"><a href="#3-1-其他线程模型" class="headerlink" title="3.1 其他线程模型"></a>3.1 其他线程模型</h3><ul><li>传统阻塞IO模式</li><li>Reactor模式<ul><li>单Reactor单线程</li><li>单Reactor多线程</li><li>主从Reactor多线程</li></ul></li></ul><h4 id=""><a href="#" class="headerlink" title=""></a></h4><h3 id="3-2-netty线程模型"><a href="#3-2-netty线程模型" class="headerlink" title="3.2 netty线程模型"></a>3.2 netty线程模型</h3><p>基于主从Reactor多线程模型，并且对其进行了一定的改进，其中主从Reactor多线程模型有多个Reactor。</p><p><img src="/2021/05/01/netty/Reactor%E6%95%B4%E4%BD%93%E6%A8%A1%E5%BC%8F.PNG"></p><ol><li>Reactor模式，通过一个或多个输入同时传递给服务处理器的模式（基于事件驱动）</li><li>服务器端程序处理传入的多个请求，并将它们同步分派到相应的处理线程，因此Reactor模式也叫Dispatcher模式。</li><li>Reactor模式使用IO复用监听事件，收到事件后，分发给某个线程（进程），这点就是网络服务器高并发处理关键。</li></ol>]]></content>
      
      
      <categories>
          
          <category> netty </category>
          
      </categories>
      
      
        <tags>
            
            <tag> netty </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Properties类Java</title>
      <link href="2021/04/27/properties-lei-java/"/>
      <url>2021/04/27/properties-lei-java/</url>
      
        <content type="html"><![CDATA[<h1 id="Properties"><a href="#Properties" class="headerlink" title="Properties"></a>Properties</h1><p><img src="/2021/04/27/properties-lei-java/UMLProperties%E7%B1%BB%E5%9B%BE.PNG"></p><p>它提供了几个主要方法：</p><ol><li><code>getProperty(String key)</code>，用指定的键在此属性列表中搜索属性。也就是通过参数key，得到key所对应的value。</li><li><code>load(InputStream inStream)</code>，从输入流中读取属性列表（键和元素对）。</li><li><code>setProperty(String key, String value)</code>，调用Hashtable的方法put。他通过调用基类的put方法来设置键值对。</li><li><code>store(OutputStream out, String comments)</code>，使用load方法加载到Properties表中的格式，将此Properties表中的属性列表（键和元素对）写入输入流。与load方法相反，该方法将键值对写入到指定的文件中去。 </li><li><code>clear()</code>，清除所有装载的键值对。该方法在基类中提供。</li></ol><h3 id="2-读取文件"><a href="#2-读取文件" class="headerlink" title="2. 读取文件"></a>2. 读取文件</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">InputStream</span> in <span class="token operator">=</span> <span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getResourceAsStream</span><span class="token punctuation">(</span><span class="token string">"资源Name"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>dubbo</title>
      <link href="2021/04/23/dubbo/"/>
      <url>2021/04/23/dubbo/</url>
      
        <content type="html"><![CDATA[<h1 id="Dubbo"><a href="#Dubbo" class="headerlink" title="Dubbo"></a>Dubbo</h1><h2 id="1-分布式基础"><a href="#1-分布式基础" class="headerlink" title="1. 分布式基础"></a>1. 分布式基础</h2><h3 id="1-1-为什么"><a href="#1-1-为什么" class="headerlink" title="1.1 为什么"></a>1.1 为什么</h3><p>随着应用规模的不断扩大，常规的垂直应用架构已经无法应对，分布式服务架构以及流动计算架构势在必行。分布式系统规模如果做大，多台机子之间的交互如何进行处理需要一种机制进行保证，于是出现了dubbo。</p><p>如果垂直应用越来越多</p><ul><li>界面和业务逻辑的实现如何进行分离。</li><li>各个应用之间需要互相调用。</li><li>。。。</li></ul><h3 id="1-2-是什么"><a href="#1-2-是什么" class="headerlink" title="1.2 是什么"></a>1.2 是什么</h3><p>分布式系统是若干独立计算机的集合，这些计算机对于用户来说就像单个相关系统。</p><h3 id="1-3-怎么做"><a href="#1-3-怎么做" class="headerlink" title="1.3 怎么做"></a>1.3 怎么做</h3><p>两个不同的服务在两个不同的机子A、B上，A要调用B的信息，就需要使用<font color="greeb">远程过程调用</font>(RPC)。将一个大应用拆成几个独立的小应用。</p><p><img src="/2021/04/23/dubbo/RPC%E6%A1%86%E6%9E%B6.PNG"></p><center>RPC框架基本原理</center><h3 id="1-4-幂等"><a href="#1-4-幂等" class="headerlink" title="1.4 幂等"></a>1.4 幂等</h3><p>幂等（设置重置次数）【查询、删除、修改】、非幂等（不能设置重试次数）【新增】。</p><p><code>retries = "0"</code> dubbo中的<code>retries</code>中的次数，不包括第一次尝试，所以最终尝试次数=retries + 1；</p><h2 id="3-整合SpringBoot"><a href="#3-整合SpringBoot" class="headerlink" title="3. 整合SpringBoot"></a>3. 整合SpringBoot</h2><ol><li>导入dubbo-starter，在application.properties配置属性，使用@Service【暴露服务】使用@Reference【引用服务】</li><li>保留dubbo xml配置文件。导入dubbo-starter，使用@ImportResource导入dubbo的配置文件即可。</li></ol><p><code>@ImportResource("xxx.xml")</code></p><ol start="3"><li>使用注解API方式。单独写一个配置类，手动配置到容器中。让dubbo扫描其中的组件。</li></ol><h3 id="3-1-映射规则"><a href="#3-1-映射规则" class="headerlink" title="3.1 映射规则"></a>3.1 映射规则</h3><p>官网：<a href="https://dubbo.apache.org/zh/docs/v2.7/user/configuration/properties/">属性配置 | Apache Dubbo</a></p><h3 id="3-2-多版本"><a href="#3-2-多版本" class="headerlink" title="3.2 多版本"></a>3.2 多版本</h3><h3 id="3-2-1-是什么"><a href="#3-2-1-是什么" class="headerlink" title="3.2.1 是什么"></a>3.2.1 是什么</h3><p>当代码升级出现不兼容时，可以用版本号过渡，版本号不同的服务相互间不引用。</p><h3 id="3-2-1-Dubbo-架构"><a href="#3-2-1-Dubbo-架构" class="headerlink" title="3.2.1 Dubbo 架构"></a>3.2.1 Dubbo 架构</h3><p><img src="/2021/04/23/dubbo/image-20210514212315189.png" alt="image-20210514212315189"></p><p>服务提供者<code>provider</code>，将提供的服务注册到<code>Registry</code>。Registry可以通过长连接的方式将这次服务变更发送给消费者。</p><p>所以在编写代码的时候，应该先把服务写好，注册到注册中心，然后消费者进行调用。</p><h3 id="3-3-服务存根"><a href="#3-3-服务存根" class="headerlink" title="3.3 服务存根"></a>3.3 服务存根</h3><h4 id="3-3-1-为什么"><a href="#3-3-1-为什么" class="headerlink" title="3.3.1 为什么"></a>3.3.1 为什么</h4><p>主要是在调用远程服务之前，做一些判断或者实现一些小功能等。判断通过后，再去调用远程服务。</p><h4 id="3-3-2-是什么"><a href="#3-3-2-是什么" class="headerlink" title="3.3.2 是什么"></a>3.3.2 是什么</h4><p>利用本地存根在客户端执行部分逻辑。</p><p><a href="https://dubbo.apache.org/zh/docs/v2.7/user/examples/local-stub/#m-zhdocsv27userexampleslocal-stub">本地存根 | Apache Dubbo</a></p><h4 id="3-3-3-怎么做"><a href="#3-3-3-怎么做" class="headerlink" title="3.3.3. 怎么做"></a>3.3.3. 怎么做</h4><p>远程服务后，客户端通常只剩下接口，而实现全在服务器端，但提供方有些时候想在客户端也执行部分逻辑，那么就在服务消费者这一端提供了一个Stub类，然后当消费者调用provider方提供的dubbo服务时，客户端生成 Proxy 实例，这个Proxy实例就是我们正常调用dubbo远程服务要生成的代理实例，然后消费者这方会把 Proxy 通过构造函数传给消费者方的Stub ，然后把 Stub 暴露给用户，Stub 可以决定要不要去调 Proxy。会通过代理类去完成这个调用，这样在Stub类中，就可以做一些额外的事，来对服务的调用过程进行优化或者容错的处理。</p><h3 id="3-4-注解配置"><a href="#3-4-注解配置" class="headerlink" title="3.4 注解配置"></a>3.4 注解配置</h3><h4 id="3-4-1-为什么"><a href="#3-4-1-为什么" class="headerlink" title="3.4.1 为什么"></a>3.4.1 为什么</h4><p>有的时候，xml配置的方式配置很繁琐，springboot+properties的方式配置的属性又不够详细。所以出现了注解配置的方式，将xml中所有可以配置的属性全部对应到代码中进行配置即可。</p><p><a href="https://dubbo.apache.org/zh/docs/v2.7/user/configuration/annotation/">注解配置 | Apache Dubbo</a></p><h4 id="3-4-2-是什么"><a href="#3-4-2-是什么" class="headerlink" title="3.4.2 是什么"></a>3.4.2 是什么</h4><p><a href="https://dubbo.apache.org/zh/docs/v2.7/user/configuration/annotation/">注解配置 | Apache Dubbo</a></p><h4 id="3-4-2-怎么做"><a href="#3-4-2-怎么做" class="headerlink" title="3.4.2 怎么做"></a>3.4.2 怎么做</h4><p>开发中可以参考上述官网。</p><p>原理：</p><p>都是注解的那一套实现原理。</p><h2 id="4-高可用"><a href="#4-高可用" class="headerlink" title="4. 高可用"></a>4. 高可用</h2><p>通用设计，减少系统不能提供服务的时间。</p><p>zookeeper宕机与dubbo直连，还可以消费dubbo暴露的服务。</p><p>原因：</p><ul><li>监控中心宕机不影响使用，只是丢失部分采样数据。</li><li>数据库宕机后，注册中心仍能通过缓存提供服务列表查询</li><li>注册中心对等集群，任意一台宕机后，将自动切换到另一台。</li><li>注册中心全部宕机后，服务提供者和服务消费者仍能通过<font color="red"> 本地缓存</font>通讯。</li><li>服务提供者无状态，任何一台宕机后，不影响使用。</li><li>服务提供者全部宕机后，服务消费者应用将无法使用，并无限次重连等待服务提供者恢复。</li></ul><h3 id="4-1-负载均衡"><a href="#4-1-负载均衡" class="headerlink" title="4.1 负载均衡"></a>4.1 负载均衡</h3><h4 id="4-1-随机负载均衡机制"><a href="#4-1-随机负载均衡机制" class="headerlink" title="4.1 随机负载均衡机制"></a>4.1 随机负载均衡机制</h4><ol><li>基于权重的随机负载均衡机制</li></ol><p><img src="/2021/04/23/dubbo/%E9%9A%8F%E6%9C%BA%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1.PNG"></p><ol start="2"><li>基于权重的轮询负载均衡机制</li></ol><p><img src="/2021/04/23/dubbo/%E6%9D%83%E9%87%8D%E8%AE%BA%E6%96%87%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1.PNG"></p><ol start="3"><li>最少活跃数</li></ol><p><img src="/2021/04/23/dubbo/%E6%9C%80%E5%B0%91%E6%B4%BB%E8%B7%83%E6%95%B0.PNG"></p><ol start="4"><li>一致性哈希</li></ol><p><img src="/2021/04/23/dubbo/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C.PNG"></p><h4 id="4-2-服务降级"><a href="#4-2-服务降级" class="headerlink" title="4.2 服务降级"></a>4.2 服务降级</h4><p>当服务器压力剧增的情况下，根据实际业务情况及流量，对一些服务和页面有策略的不处理或换种简单的方式处理，从而释放服务器资源以保证核心交易正常运作或高效运作。</p><p>本质上就是不让他调用此服务了。</p><p>里面还有一个容错的概念，容错在调用失败时才返回为<code>null</code>。</p><h4 id="4-3-服务容错"><a href="#4-3-服务容错" class="headerlink" title="4.3 服务容错"></a>4.3 服务容错</h4><ol><li>FailFast Cluster</li></ol><p>快速失败，只发起一次调用，失败立即报错。通常用于非幂等性的写操作，比如新增记录。</p><ol start="2"><li>FailSast Cluster</li></ol><p>失败安全，出现异常则直接忽略。通常用于写入审计日志等操作。</p><ol start="3"><li>FailBack Cluster</li></ol><p>失败自动恢复，后台记录失败请求，定时重发。通常用于消息通知操作。</p><ol start="4"><li>Forcking Cluster</li></ol><p>并行调度多个服务器，只要一个成功即返回。比如一个客户端向3个提供者发起服务请求（太浪费资源了）。通常用于实时性较高的读操作，但需要浪费更多服务资源。可通过<code>forks=2</code>来设置最大并行数。</p><ol start="5"><li>Broadcast Cluster</li></ol><p>广播调用所有提供者，逐个调用，任意一台报错即报错。通常用于通知所有提供者更新缓存或日志等本地资源信息。</p><p>集群模式配置</p><p>&lt;dubbo:service cluster=”failsafe”&gt;</p><p>在实际开发中，一般整合hystrix提供更强大的容错能力。</p><p><code>&lt;HystrixCommand(fallbackMethod="hello")</code></p><h2 id="5-原理"><a href="#5-原理" class="headerlink" title="5. 原理"></a>5. 原理</h2><h3 id="5-1-RPC"><a href="#5-1-RPC" class="headerlink" title="5.1 RPC"></a>5.1 RPC</h3><ol><li>服务消费方(Client)调用以本地调用方式调用服务。</li><li>client stub 接收到调用后负责将方法、参数等组装成能够进行网络传输的消息体。</li><li>client stub 找到服务地址，并将消息发送到服务端。</li><li>serve stub 收到消息后进行解码。</li><li>server stub 根据解码结果调用本地服务。</li><li>本地服务执行并将结果返回给server stub。</li><li>serve stub 将返回结果打包成消息并发送至消费方。</li><li>client stub 接收到信息，并进行解码。</li><li>服务消费方得到最终结果。</li></ol><p>RPC 框架就是将这些步骤都封装起来。</p><h3 id="5-2-框架设计"><a href="#5-2-框架设计" class="headerlink" title="5.2 框架设计"></a>5.2 框架设计</h3><h3 id="5-3-服务暴露"><a href="#5-3-服务暴露" class="headerlink" title="5.3 服务暴露"></a>5.3 服务暴露</h3><h3 id="5-4-服务引用"><a href="#5-4-服务引用" class="headerlink" title="5.4 服务引用"></a>5.4 服务引用</h3><h3 id="5-5-服务调用"><a href="#5-5-服务调用" class="headerlink" title="5.5 服务调用"></a>5.5 服务调用</h3>]]></content>
      
      
      <categories>
          
          <category> dubbo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dubbo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTPS深入理解</title>
      <link href="2021/04/18/https-shen-ru-li-jie/"/>
      <url>2021/04/18/https-shen-ru-li-jie/</url>
      
        <content type="html"><![CDATA[<h2 id="HTTPS是什么"><a href="#HTTPS是什么" class="headerlink" title="HTTPS是什么"></a>HTTPS是什么</h2><h1 id="1-HTTP"><a href="#1-HTTP" class="headerlink" title="1. HTTP"></a>1. HTTP</h1><h2 id="1-1-HTTP-状态码"><a href="#1-1-HTTP-状态码" class="headerlink" title="1.1 HTTP 状态码"></a>1.1 HTTP 状态码</h2><table><thead><tr><th>分类</th><th>分类描述</th></tr></thead><tbody><tr><td>1**</td><td>信息，服务器收到请求，需要请求者继续执行</td></tr><tr><td>2**</td><td>成功，操作被成功接收并处理</td></tr><tr><td>3**</td><td>重定向，需要进一步的操作以完成请求</td></tr><tr><td>4**</td><td>客户端错误，请求包含语法错误或无法完成请求</td></tr><tr><td>5**</td><td>服务器错误，服务器在处理请求的过程中发生了错误</td></tr></tbody></table><table><thead><tr><th>状态码</th><th>状态码英文名称</th><th>中文描述</th></tr></thead><tbody><tr><td>100</td><td>Continue</td><td>继续，客户端应继续其请求</td></tr><tr><td>101</td><td>Switching Protocols</td><td>切换协议</td></tr><tr><td>200</td><td>OK</td><td>请求成功。一般用于GET与POST请求。</td></tr><tr><td>201</td><td>Created</td><td>已创建，成功请求并创建新的资源</td></tr><tr><td>202</td><td>Accepted</td><td>已接受，已经接收请求，但未处理完成</td></tr><tr><td>203</td><td>Non-Authoritative Information</td><td>非授权信息。请求成功，但返回的meta信息不在原始服务器，而是一个副本</td></tr><tr><td>204</td><td>No Content</td><td>无内容。服务器处理成功，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档。</td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr></tbody></table><table><thead><tr><th>状态码</th><th>状态码英文名称</th><th></th><th>中文描述</th></tr></thead><tbody><tr><td>500</td><td>Internal Server Error</td><td></td><td>服务器内部错误，无法完成请求。</td></tr><tr><td>501</td><td>Not Implemented</td><td></td><td>服务器不支持请求的功能，无法完成请求。</td></tr><tr><td>502</td><td>Bad Gateway</td><td></td><td>作为网关或者代理工作</td></tr><tr><td>503</td><td>Service Unavailable</td><td></td><td></td></tr><tr><td>504</td><td>HTTP Version not supported</td><td></td><td></td></tr><tr><td>505</td><td>GateWay Time-out</td><td></td><td></td></tr></tbody></table><h3 id="HTTP存在问题"><a href="#HTTP存在问题" class="headerlink" title="HTTP存在问题"></a>HTTP存在问题</h3><p>由于HTTP协议过于简单：</p><ul><li>通信使用明文（不加密），内容可能会被窃听。</li><li>不验证通信方的身份，因此可能遭遇伪装</li><li>无法验证报文的完整性，所以有可能已遭篡改。</li></ul><p>为了解决诸多问题，HTTPS应运而生。</p><h3 id="HTTPS的实质"><a href="#HTTPS的实质" class="headerlink" title="HTTPS的实质"></a>HTTPS的实质</h3><p>HTTP加上<strong>加密处理</strong>、<strong>认证机制</strong>、以及<strong>完整性保护</strong>后的就是HTTPS。</p><p>需要知道的是，HTTPS并非是应用层的一种新的协议。只是HTTP通信接口部分用SSL或TLS协议代替而已。也就是说，所谓的HTTPS，<strong>其实就是身披SSL协议外壳的HTTP。</strong></p><p><img src="/2021/04/18/https-shen-ru-li-jie/1460000012196647" alt="img"></p><p>值得一提的是，SSL是独立于HTTP协议的，也就是说其他运行在应用层的协议均可配合SSL协议使用。现今SSL是最为广泛的网络安全技术。</p><h3 id="SSL和TLS"><a href="#SSL和TLS" class="headerlink" title="SSL和TLS"></a>SSL和TLS</h3><p>HTTPS中使用了SSL和TLS这两个协议。</p><p>TLS以SSL3.0为基准，后又制定了TLS1.0、TLS1.1和TLS1.2。当前主流的版本是SSL3.0和TLS1.0。</p><p><strong>TLS是以SSL为原型开发的协议，有时候会统称该协议为SSL。</strong></p><h2 id="HTTPS的加密原理"><a href="#HTTPS的加密原理" class="headerlink" title="HTTPS的加密原理"></a>HTTPS的加密原理</h2><p>近代的加密算法中加密算法是公开的，而密钥是保密的。通过这种方式来保持加密方法的安全性。</p><p>加密和解密要用到密钥，如果没有密钥就没有办法对密码解密。换句话来说，任何人只要持有密钥就能够对密文进行解密。</p><p>HTTPS在加密过程中使用了<strong>非对称加密技术</strong>和<strong>对称加密技术</strong>。</p><h3 id="对称加密算法"><a href="#对称加密算法" class="headerlink" title="对称加密算法"></a>对称加密算法</h3><blockquote><p>采用单钥密码系统的加密方式，同一个密钥可以同时做信息的加密和解密，这种加密的方法称为对称加密，也称为单密钥加密。</p></blockquote><p>下面会把对称加密算法称为共享密钥加密算法。</p><p>假如现在，SSL在通信过程中，使用了对称加密算法，也就是说客户端和服务器同时共享一个密钥。</p><p>于是，以共享密钥的方式加密，必须将密钥发给对方。这个时候，假如通信过程被监听，密钥被攻击者获取了，那么这个时候也就失去了加密的意义了。</p><p><img src="/2021/04/18/https-shen-ru-li-jie/1460000012196648" alt="img"></p><p>那么，有没有办法解决这个问题呢？答案是肯定的，也就是使用两把密钥。</p><p>下面先看使用两把密钥的非对称加密算法。</p><h3 id="非对称加密算法"><a href="#非对称加密算法" class="headerlink" title="非对称加密算法"></a>非对称加密算法</h3><blockquote><p>与对称加密算法相反，非对称加密算法需要两个密钥来进行加密和解密，这两个密钥是配对的，分别是公开密钥（公钥）和私有密钥（私钥）。</p></blockquote><p>一般情况下，公钥是可以被<strong>公开</strong>的，它主要用来加密明文。而相应的，私钥<strong>不能被公开</strong>，用来解密公钥加密的密文。</p><p>值得注意的是：<strong>公钥加密后的密文只能通过对应的私钥来解密，而私钥加密的密文却可以通过对应的公钥来解密。</strong></p><p>以上，公钥加密私钥解密用来加密，私钥加密公钥解密用来签名。相关用途后面会讲到。</p><p>下面会把非对称加密算法称为公开密钥加密算法。</p><p>于是现在，假设现在由服务器来生成一对公钥和私钥。</p><p>当客户端第一次发请求和服务器协商的时候，<strong>服务器就生成了一对公钥和私钥</strong>。</p><p>紧接着，服务器把公钥发给客户端（明文，不需要做任何加密），客户端接收后，随机生成一个密钥，<strong>使用服务器发过来的公钥进行加密</strong>。</p><p>再接着，客户端把使用公钥加密的密钥发给服务器，服务器接收到了以后，<strong>用配对的私钥进行解密</strong>，就得到了客户端随机生成的那个密钥。</p><p>这个时候，客户端和服务端所持的密钥都是相同的。此时，交换密钥环节就完成了。</p><p>于是<strong>通信</strong>开始时就可进行上面所述的<strong>共享密钥加密方式</strong>来进行加密。</p><h3 id="同时使用"><a href="#同时使用" class="headerlink" title="同时使用"></a>同时使用</h3><p>可能，有小伙伴就会问，为什么要大费周章使用非对称加密的方式，然后再得到相同的密钥，进行共享密钥加密的通信呢？</p><p>由于公开密钥加密处理起来比共享密钥加密方式更为复杂，因此在通信的时候使用公开密钥加密的方式，效率很低。</p><p>于是，我们需要使用非对称加密的方式来保证密钥共享的过程中密钥的安全性，而后在通信的过程中使用对称加密算法，这是最合理的设计方式，在保证安全性的同时又保证了性能。</p><p>所以，HTTPS采用共享密钥加密和公开密钥加密两者并用的混合加密机制。<strong>在交换密钥使用环节使用公开密钥加密方式，之后建立的通信交换报文阶段则使用共享密钥加密方式。</strong></p><p>以上，大概就是使用对称加密和非对称加密的过程。看似过程很完美，其实还存在着一个问题，就是：<strong>如何保证服务器传过来的公开密钥的正确性。换句话说，就是保证它不被拦截篡改。</strong></p><h2 id="使用证书保证公钥的正确性"><a href="#使用证书保证公钥的正确性" class="headerlink" title="使用证书保证公钥的正确性"></a>使用证书保证公钥的正确性</h2><p>假如现在正准备和某台服务器建立公开密钥加密方式下的通信，如何证明客户端收到的公开密钥就是原本预想的那台服务器发行的公开密钥呢？或许，在公开密钥传输的过程中，真正的公开密钥可能已经被攻击者替换掉了。</p><p>为了解决这个问题，可以使用由数字证书机构和其相关颁发的公开密钥证书。</p><p>下面阐述一下数字证书认证机构（简称CA）的业务流程：</p><p>首先，服务器的运营人员向数字证书机构提出公开密钥的申请。数字证书认证机构在判明提出申请者的身份之后，会对已申请的公开密钥做数字签名，然后分配这个已签名的公开密钥，并将该公开密钥放入公钥证书后绑定在一起。<br>我们用<strong>白话文</strong>来翻译一下上面这段话：</p><ul><li>首先，CA会向申请者颁发一个证书，这个证书里面的内容有：签发者、证书用途、使用的HASH算法、签名所使用的算法、证书到期的时间等等。</li><li>紧接着，把上面所提到的内容，做一次HASH求值，得到一个HASH值。</li><li>再接着，用CA的<strong>私钥</strong>对这个HASH值和所使用的HASH算法加密，这样就完成了数字签名。而用CA的私钥加密后，就生成了类似人体指纹的签名，任何篡改证书的尝试，都会被数字签名发现。</li><li>最后，把数字签名，附在数字证书的末尾，传输给服务器。</li></ul><p>接下来，服务器会把这份由数字证书认证机构颁发的公钥证书发给客户端。这个时候，客户端可以使用数字证书机构的公开密钥对其进行验证。一旦验证成功，客户端便能够确定这个公开密钥是可信的。<br>我们再用<strong>白话文</strong>来翻译一下：</p><ul><li>客户端拿到这个数字证书以后，用CA私钥对应的公钥，可以解密数字证书末尾的数字签名，得到HASH值和所采用的HASH算法。</li><li>紧接着，客户端按照解密到的这个HASH算法，对证书的内容求HASH值。如果通过CA公钥解密的HASH和通过计算求得的HASH值相同，那么认证通过，否则失败。</li><li>如果认证通过，就可以取得服务器的公开密钥。</li></ul><p>那客户端上面的CA公钥是从哪里来的呢？</p><p>其实，CA除了给申请者发布证书，它自己本身也有自己的证书。CA自身的数字证书（一般由它自己生成）在我们操作系统刚安装好的时候，这些CA自身的数字证书就已经被微软（或者其它操作系统的开发机构）安装在操作系统中了。而CA的公钥就包含在其中。这样，CA就可以通过自身的私钥对发布的数字证书进行签名，而在客户端就能够用对应的公钥来对其进行解密。</p><p>其具体过程是这样子的（图中简化了数字签名的过程）：</p><p><img src="/2021/04/18/https-shen-ru-li-jie/1460000012196649" alt="img"></p><p>这里其实就用到了<strong>非对称加密算法</strong>，只不过现在这个加密算法用来<strong>签名</strong>而不是<strong>加密</strong>。</p><p>使用私钥加密，公钥解密，用于公钥的持有者验证通过私钥加密的内容是否被篡改，但是不用来保证内容是否被他人获得。</p><p>而使用公钥加密，私钥解密，则是相反的，它不保证信息被他人截获篡改，但是保证信息无法被中间人获得。</p><h3 id="客户端证书"><a href="#客户端证书" class="headerlink" title="客户端证书"></a>客户端证书</h3><p>HTTPS中不仅可以使用服务器证书，还可以使用客户端证书。以客户端证书进行客户端认证，它的作用与服务器证书是相同的。</p><p>由于客户端获取证书需要用户自行安装客户端证书，同时也面临着费用的问题。</p><p>因此，现状是，安全性极高的认证机构可办法客户端证书但是仅用于特殊用途的业务。比如那些可支撑客户端证书支出费用的业务。</p><p>例如，银行的网上银行就采用了客户端证书。在登录网银时不仅要求用户确认输入ID和密码，还会要求用户的客户端证书，以确认用户是否从特定的终端访问网银。</p><h2 id="HTTPS通信的过程"><a href="#HTTPS通信的过程" class="headerlink" title="HTTPS通信的过程"></a>HTTPS通信的过程</h2><p><img src="/2021/04/18/https-shen-ru-li-jie/1460000012196650" alt="img"></p><p>现在我们来理清一下SSL建立的过程：</p><ol><li><p>客户端通过发送Client Hello报文开始SSL通信。报文中包含客户端支持的SSL的指定版本、加密组件（Cipher Suite）列表（所使用的加密算法及密钥长度等）。<br>注意：客户端还会附加一个<strong>随机数</strong>，这里记为A。</p></li><li><p>服务器可进行SSL通信时，会以Server Hello报文作为应答。和客户端一样，在报文中包含SSL版本以及加密组件。服务器的加密组件内容是从接收到的客户端加密组件内筛选出来的。<br>注意：这里服务器同样会附加一个<strong>随机数</strong>，发给客户端，这里记为B。</p></li><li><p>之后服务器发送Certificate报文。报文中包含公开密钥证书。（具体的数字签名请看证书一节）</p></li><li><p>最后服务器发送Server Hello Done报文通知客户端，最初阶段的SSL握手协商部分结束。</p></li><li><p>SSL第一次握手结束后，客户端会对服务器发过来的证书进行验证，如果验证成功，解密取出证书中的公钥。（具体查看证书一节）<br>接着，客户端以Client Key Exchange报文作为回应。报文中包含通信加密中使用的一种被称为<code>Pre-master secret</code>的随机密码串。该报文使用从证书中解密获得的公钥进行加密（其实就是服务器的公钥）。</p></li><li><p>客户端继续发送Change Cipher Spec报文。用于告知服务端，客户端已经切换到之前协商好的加密套件（Cipher Suite）的状态，准备使用之前协商好的加密套件加密数据并传输了。</p></li><li><p>客户端发送Finished报文。该报文包含连接至今全部报文的整体校验值（也就是HASH值），用来供服务器校验。</p></li><li><p>服务器接收到客户端的请求之后，使用私钥解密报文，把<code>Pre-master secret</code>取出来。接着，服务器同样发送Change Cipher Spec报文。</p></li><li><p>服务器同样发送Finished报文，用来供客户端校验。</p></li><li><p>服务器和客户端的Finished报文交换完毕之后，SSL连接就算建立完成。当然，通信会受到SSL的保护。从此处开始进行应用层协议的通信，即发送HTTP请求。</p></li><li><p>应用层协议通信，即发送HTTP响应。</p></li><li><p>最后由客户端断开连接。断开连接时，发送close_notify报文。上图做了一些省略，这步之后再发送TCP FIN报文来关闭与TCP的通信。</p></li></ol><p>读到这里，你可能会对上面的一些细节产生很多疑惑，现在我们一个个来理清楚？</p><h4 id="问题一"><a href="#问题一" class="headerlink" title="问题一"></a>问题一</h4><p>为什么最后客户端和服务端都要发送一个Finish报文？</p><p>上面已经提及，Finish报文是对至今全部报文的整体校验值（也就是HASH值）。当客户端把这个值通过得到的公钥进行加密的时候，服务器得到之后对其进行解密，然后再对全部报文进行一个HASH求值。如果这个值跟解密得到的值相等的话，那么说明客户端是可信赖的。<br>同样的，服务器发送这样的一个整体校验值，用来客户端验证服务器是否是真正要进行通信的那一个。<br>综上，这个Finish报文就是用来校验双方的身份的。</p><h4 id="问题二"><a href="#问题二" class="headerlink" title="问题二"></a>问题二</h4><p>整个过程中产生的三个<strong>随机数</strong>有什么用呢？还有，后面进行HTTP通信的时候，是用哪一个密钥进行加密，还有怎么保证报文的完整性。</p><p>看下面这张图。</p><p><img src="/2021/04/18/https-shen-ru-li-jie/1460000012196651" alt="img"></p><p>对于<strong>客户端</strong>：<br>当其生成了<code>Pre-master secret</code>之后，会结合原来的A、B随机数，用DH算法计算出一个<code>master secret</code>，紧接着根据这个<code>master secret</code>推导出<code>hash secret</code>和<code>session secret</code>。</p><p>对于<strong>服务端</strong>：<br>当其解密获得了<code>Pre-master secret</code>之后，会结合原来的A、B随机数，用DH算法计算出一个<code>master secret</code>，紧接着根据这个<code>master secret</code>推导出<code>hash secret</code>和<code>session secret</code>。</p><blockquote><p>在客户端和服务端的<code>master secret</code>是依据三个随机数推导出来的，它是不会在网络上传输的，只有双方知道，不会有第三者知道。同时，客户端推导出来的<code>session secret</code>和<code>hash secret</code>与服务端也是完全一样的。</p></blockquote><p>那么现在双方如果开始使用对称算法加密来进行通讯，使用哪个作为共享的密钥呢？过程是这样子的：</p><p>双方使用对称加密算法进行加密，用<code>hash secret</code>对HTTP报文做一次运算生成一个<code>MAC</code>，附在HTTP报文的后面，然后用<code>session-secret</code>加密所有数据（<code>HTTP+MAC</code>），然后发送。</p><p>接收方则先用<code>session-secret</code>解密数据，然后得到<code>HTTP+MAC</code>，再用相同的算法计算出自己的<code>MAC</code>，如果两个<code>MAC</code>相等，证明数据没有被篡改。</p><blockquote><p>MAC(Message Authentication Code)称为报文摘要，能够查知报文是否遭到篡改，从而保护报文的完整性。</p></blockquote><h4 id="问题三"><a href="#问题三" class="headerlink" title="问题三"></a>问题三</h4><p>为什么要使用三个随机数呢？</p><p>网友dog250是这么解释的：</p><blockquote><p>“不管是客户端还是服务器，都需要随机数，这样生成的密钥才不会每次都一样。由于SSL协议中证书是静态的，因此十分有必要引入一种随机因素来保证协商出来的密钥的随机性。<br>对于RSA密钥交换算法来说，<code>pre-master secret</code>本身就是一个随机数，再加上hello消息中的随机，三个随机数通过一个密钥导出器最终导出一个对称密钥。<br><code>pre-master secret</code>的存在在于SSL协议不信任每个主机都能产生完全随机的随机数，如果随机数不随机，那么<code>pre-master secret</code>就有可能被猜出来，那么仅适用<code>pre-master secret</code>作为密钥就不合适了，因此必须引入新的随机因素，那么客户端和服务器加上<code>pre-master secret</code>三个随机数一同生成的密钥就不容易被猜出了，一个伪随机可能完全不随机，可是是三个伪随机就十分接近随机了，每增加一个自由度，随机性增加的可不是一。”</p></blockquote><p>注：我们在计算机所使用的随机数都是伪随机，而不是物理上所说的真正随机。</p><p>另外，黑客可能拦截了这样的一个加密的报文，他不对报文进行修改，而是不停的向报文的接受者发送重复的报文，以扰乱通信的建立。于是，就可以加这么一个随机数。只要任何一个通信方，接收到的报文中的随机数出现重复的情况，就可以知道有中间者对通信的过程进行了扰乱，可以立即中断通信。</p><h4 id="问题四"><a href="#问题四" class="headerlink" title="问题四"></a>问题四</h4><p>如果黑客拦截了服务器把证书发送给客户端，并对证书进行恶意修改，会出现什么情况？</p><p>第一种情况，假如黑客只是单纯的修改数字证书中的内容，那么由于数字签名的存在，客户端会很容易的判断出报文是否被篡改。</p><p>第二种情况，黑客不仅修改了数字证书的内容，并且把数字签名替换掉了，由于黑客不可能知道CA的私钥，于是在客户端用CA的公钥进行解密的时候，解密之后得不到正确的信息，也很容易判断出报文是否被修改。</p><p>第三种情况，黑客恶意的从相同的第三方CA申请了一个数字证书。由于这个CA是真实存在的，所以客户端是可以用CA的公钥进行解密，得到了黑客提供的数字证书中的公钥。但是，由于数字证书在申请的时候，会绑定一个<strong>域名</strong>，当客户端比如说浏览器，检测到这个数字证书中的域名和我们现在网页访问的域名不一致，便会发出警告，此时我们也能得知数字证书被替换了。发出的警告如下：</p><p><img src="/2021/04/18/https-shen-ru-li-jie/bV0FNg" alt="89294765.jpg"></p><h2 id="一定要用HTTPS吗"><a href="#一定要用HTTPS吗" class="headerlink" title="一定要用HTTPS吗"></a>一定要用HTTPS吗</h2><p>当HTTP披上SSL外壳之后，由于加入了诸多验证的机制，虽然安全性大大提高了，但是它的处理速度会变慢。慢的原因分以下两种：</p><ul><li>服务器在与客户端协商次数增多，也就是说整体上处理<strong>通信量</strong>会不可避免的增加。</li><li>SSL进行加密处理，在服务端和客户端都需要进行加密和解密的<strong>运算处理</strong>。结果会消耗更多的硬件资源，导致负载增加。</li></ul><p>可见，使用HTTPS会消耗更多的资源。如果每次通信都加密，那么平摊到一台计算机上，能够处理的请求数量也必定会减少。</p><p>同时，使用HTTPS需要向CA购买证书，于是<strong>开销</strong>也成为考虑是否使用HTTPS的原因之一。</p><p>所以，大部分的Web网站都采取了一个折中的方法。对于一些需要隐藏、私密的信息进行加密，而普通的信息不进行加密处理，以节省资源。</p><h2 id="fiddler拦截HTTPS请求的原理"><a href="#fiddler拦截HTTPS请求的原理" class="headerlink" title="fiddler拦截HTTPS请求的原理"></a>fiddler拦截HTTPS请求的原理</h2><p>很多时候我们可以通过fiddler来进行抓HTTP包，但是当遇到连接采用的是HTTPS的时候，过程可能就不那么愉快了。但实际上实现拦截也十分简单。</p><p>fiddler拦截HTTPS请求最核心的地方在于真正的<strong>客户端</strong>需要<strong>安装fiddler的证书</strong>。这样子的话，fiddler能够伪造出CA证书，达到欺骗客户端，拿到需要的信息并推算出之后双方正常通信的对称加密密钥。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>这学期刚好有《信息安全》这门课程，那就简明的介绍一下公钥密码密码体系RSA算法原理是什么。</p><p>它是这样子工作的：</p><ol><li>选取两个大素数<code>p</code>和<code>q</code>，相乘得到<code>n</code>。</li><li><code>p-1</code>和<code>q-1</code>相乘，得到<code>f(n)</code>。</li><li>随机选取一个<code>e</code>与<code>f(n)</code>互质，然后得到公钥<code>(e, n)</code>。</li><li>私钥的求法为<code>ed = 1 mod f(n)</code>。 [这是一个等价关系而不是一个表达式！也就是<code>ed</code>模<code>fn(n)</code>的结果是1，这是求模运算的逆运算，可以用欧几里德辗转相除法求得]</li><li>最后得到的私钥为<code>(d, n)</code>。</li></ol><blockquote><p>整个RSA公钥密码算法的难度其实在于分解这一个大数<code>n</code>，<code>pq=n</code>正向运算很容易，逆向运算很困难，随着这个数越来越大，想要逆向分解需要很多年的时间。</p></blockquote><p><img src="/2021/04/18/https-shen-ru-li-jie/1460000012630692" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> 网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>进程间的通信IPC</title>
      <link href="2021/04/13/jin-cheng-jian-de-tong-xin-ipc/"/>
      <url>2021/04/13/jin-cheng-jian-de-tong-xin-ipc/</url>
      
        <content type="html"><![CDATA[<h4 id="一、进程间通信的概念"><a href="#一、进程间通信的概念" class="headerlink" title="一、进程间通信的概念"></a>一、进程间通信的概念</h4><p>每个进程各自有不同的用户地址空间，任何一个进程的全局变量在另一个进程中都看不到，所以进程之间要交换数据必须通过内核，在内核中开辟一块缓冲区，进程1把数据从用户空间拷到内核缓冲区，进程2再从内核缓冲区把数据读走，内核提供的这种机制称为<strong>进程间通信（IPC，InterProcess Communication）</strong></p><p><img src="/2021/04/13/jin-cheng-jian-de-tong-xin-ipc/%E8%BF%9B%E7%A8%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1.PNG"></p><p>进程间通信模型</p><h4 id="二、进程间通信的7种方式"><a href="#二、进程间通信的7种方式" class="headerlink" title="二、进程间通信的7种方式"></a>二、进程间通信的7种方式</h4><p><strong>第一类：传统的Unix通信机制</strong><br> <strong>1. 管道/匿名管道(pipe)</strong></p><ul><li><p>管道是半双工的，数据只能向一个方向流动；需要双方通信时，需要建立起两个管道。</p></li><li><p>只能用于父子进程或者兄弟进程之间(具有亲缘关系的进程);</p></li><li><p>单独构成一种独立的文件系统：管道对于管道两端的进程而言，就是一个文件，但它不是普通的文件，它不属于某种文件系统，而是自立门户，单独构成一种文件系统，并且只存在与内存中。</p></li><li><p>数据的读出和写入：一个进程向管道中写的内容被管道另一端的进程读出。写入的内容每次都添加在管道缓冲区的末尾，并且每次都是从缓冲区的头部读出数据。</p><p><img src="/2021/04/13/jin-cheng-jian-de-tong-xin-ipc/%E7%AE%A1%E9%81%93%E9%80%9A%E4%BF%A1%E6%A8%A1%E5%9E%8B.PNG"></p><p>进程间管道通信模型</p></li></ul><p><strong>管道的实质：</strong><br> 管道的实质是一个内核缓冲区，进程以先进先出的方式从缓冲区存取数据，管道一端的进程顺序的将数据写入缓冲区，另一端的进程则顺序的读出数据。<br> 该缓冲区可以看做是一个循环队列，读和写的位置都是自动增长的，不能随意改变，一个数据只能被读一次，读出来以后在缓冲区就不复存在了。<br> 当缓冲区读空或者写满时，有一定的规则控制相应的读进程或者写进程进入等待队列，当空的缓冲区有新数据写入或者满的缓冲区有数据读出来时，就唤醒等待队列中的进程继续读写。</p><p><strong>管道的局限：</strong><br> 管道的主要局限性正体现在它的特点上：</p><ul><li>只支持单向数据流；</li><li>只能用于具有亲缘关系的进程之间；</li><li>没有名字；</li><li>管道的缓冲区是有限的（管道制存在于内存中，在管道创建时，为缓冲区分配一个页面大小）；</li><li>管道所传送的是无格式字节流，这就要求管道的读出方和写入方必须事先约定好数据的格式，比如多少字节算作一个消息（或命令、或记录）等等；</li></ul><p><strong>2. 有名管道(FIFO)</strong><br> 匿名管道，由于没有名字，只能用于亲缘关系的进程间通信。为了克服这个缺点，提出了有名管道(FIFO)。<br> 有名管道不同于匿名管道之处在于它提供了一个路径名与之关联，<strong>以有名管道的文件形式存在于文件系统中</strong>，这样，<strong>即使与有名管道的创建进程不存在亲缘关系的进程，只要可以访问该路径，就能够彼此通过有名管道相互通信</strong>，因此，通过有名管道不相关的进程也能交换数据。值的注意的是，有名管道严格遵循<strong>先进先出(first in first out)</strong>,对匿名管道及有名管道的读总是从开始处返回数据，对它们的写则把数据添加到末尾。它们不支持诸如lseek()等文件定位操作。<strong>有名管道的名字存在于文件系统中，内容存放在内存中。</strong></p><blockquote><p><strong>匿名管道和有名管道总结：</strong><br> （1）管道是特殊类型的文件，在满足先入先出的原则条件下可以进行读写，但不能进行定位读写。<br> （2）匿名管道是单向的，只能在有亲缘关系的进程间通信；有名管道以磁盘文件的方式存在，可以实现本机任意两个进程通信。<br> （3）<strong>无名管道阻塞问题：</strong>无名管道无需显示打开，创建时直接返回文件描述符，在读写时需要确定对方的存在，否则将退出。如果当前进程向无名管道的一端写数据，必须确定另一端有某一进程。如果写入无名管道的数据超过其最大值，写操作将阻塞，如果管道中没有数据，读操作将阻塞，如果管道发现另一端断开，将自动退出。<br> （4）<strong>有名管道阻塞问题：</strong>有名管道在打开时需要确实对方的存在，否则将阻塞。即以读方式打开某管道，在此之前必须一个进程以写方式打开管道，否则阻塞。此外，可以以读写（O_RDWR）模式打开有名管道，即当前进程读，当前进程写，不会阻塞。</p></blockquote><p><a href="https://link.jianshu.com/?t=http://blog.chinaunix.net/uid-26833883-id-3227144.html">延伸阅读：该博客有匿名管道和有名管道的C语言实践</a></p><p><strong>3. 信号(Signal)</strong></p><ul><li>信号是Linux系统中用于进程间互相通信或者操作的一种机制，信号可以在任何时候发给某一进程，而无需知道该进程的状态。</li><li>如果该进程当前并未处于执行状态，则该信号就有内核保存起来，知道该进程回复执行并传递给它为止。</li><li>如果一个信号被进程设置为阻塞，则该信号的传递被延迟，直到其阻塞被取消是才被传递给进程。</li></ul><blockquote><p><strong>Linux系统中常用信号：</strong><br> （1）<strong>SIGHUP：</strong>用户从终端注销，所有已启动进程都将收到该进程。系统缺省状态下对该信号的处理是终止进程。<br> （2）<strong>SIGINT：</strong>程序终止信号。程序运行过程中，按<code>Ctrl+C</code>键将产生该信号。<br> （3）<strong>SIGQUIT：</strong>程序退出信号。程序运行过程中，按<code>Ctrl+\\</code>键将产生该信号。<br> （4）<strong>SIGBUS和SIGSEGV：</strong>进程访问非法地址。<br> （5）<strong>SIGFPE：</strong>运算中出现致命错误，如除零操作、数据溢出等。<br> （6）<strong>SIGKILL：</strong>用户终止进程执行信号。shell下执行<code>kill -9</code>发送该信号。<br> （7）<strong>SIGTERM：</strong>结束进程信号。shell下执行<code>kill 进程pid</code>发送该信号。<br> （8）<strong>SIGALRM：</strong>定时器信号。<br> （9）<strong>SIGCLD：</strong>子进程退出信号。如果其父进程没有忽略该信号也没有处理该信号，则子进程退出后将形成僵尸进程。</p></blockquote><p><strong>信号来源</strong><br> 信号是软件层次上对中断机制的一种模拟，是一种异步通信方式，，信号可以在用户空间进程和内核之间直接交互，内核可以利用信号来通知用户空间的进程发生了哪些系统事件，信号事件主要有两个来源：</p><ul><li>硬件来源：用户按键输入<code>Ctrl+C</code>退出、硬件异常如无效的存储访问等。</li><li>软件终止：终止进程信号、其他进程调用kill函数、软件异常产生信号。</li></ul><p><strong>信号生命周期和处理流程</strong><br> （1）信号被某个进程产生，并设置此信号传递的对象（一般为对应进程的pid），然后传递给操作系统；<br> （2）操作系统根据接收进程的设置（是否阻塞）而选择性的发送给接收者，如果接收者阻塞该信号（且该信号是可以阻塞的），操作系统将暂时保留该信号，而不传递，直到该进程解除了对此信号的阻塞（如果对应进程已经退出，则丢弃此信号），如果对应进程没有阻塞，操作系统将传递此信号。<br> （3）目的进程接收到此信号后，将根据当前进程对此信号设置的预处理方式，暂时终止当前代码的执行，保护上下文（主要包括临时寄存器数据，当前程序位置以及当前CPU的状态）、转而执行中断服务程序，执行完成后在回复到中断的位置。当然，对于抢占式内核，在中断返回时还将引发新的调度。</p><p><img src="/2021/04/13/jin-cheng-jian-de-tong-xin-ipc/%E4%BF%A1%E5%8F%B7%E5%A3%B0%E6%98%8E%E5%91%A8%E6%9C%9F.PNG"></p><p>信号的生命周期</p><p><strong>4. 消息(Message)队列</strong></p><ul><li>消息队列是存放在内核中的消息链表，每个消息队列由消息队列标识符表示。</li><li>与管道（无名管道：只存在于内存中的文件；命名管道：存在于实际的磁盘介质或者文件系统）不同的是消息队列存放在内核中，只有在内核重启(即，操作系统重启)或者显示地删除一个消息队列时，该消息队列才会被真正的删除。</li><li>另外与管道不同的是，消息队列在某个进程往一个队列写入消息之前，并不需要另外某个进程在该队列上等待消息的到达。<a href="https://link.jianshu.com/?t=http://blog.csdn.net/yang_yulei/article/details/19772649">延伸阅读：消息队列C语言的实践</a></li></ul><blockquote><p><strong>消息队列特点总结：</strong><br> （1）消息队列是消息的链表,具有特定的格式,存放在内存中并由消息队列标识符标识.<br> （2）消息队列允许一个或多个进程向它写入与读取消息.<br> （3）管道和消息队列的通信数据都是先进先出的原则。<br> （4）消息队列可以实现消息的随机查询,消息不一定要以先进先出的次序读取,也可以按消息的类型读取.比FIFO更有优势。<br> （5）消息队列克服了信号承载信息量少，管道只能承载无格式字 节流以及缓冲区大小受限等缺。<br> （6）目前主要有两种类型的消息队列：POSIX消息队列以及System V消息队列，系统V消息队列目前被大量使用。系统V消息队列是随内核持续的，只有在内核重起或者人工删除时，该消息队列才会被删除。</p></blockquote><p><strong>5. 共享内存(share memory)</strong></p><ul><li><p>使得多个进程可以可以直接读写同一块内存空间，是最快的可用IPC形式。是针对其他通信机制运行效率较低而设计的。</p></li><li><p>为了在多个进程间交换信息，内核专门留出了一块内存区，可以由需要访问的进程将其映射到自己的私有地址空间。进程就可以直接读写这一块内存而不需要进行数据的拷贝，从而大大提高效率。</p></li><li><p>由于多个进程共享一段内存，因此需要依靠某种同步机制（如信号量）来达到进程间的同步及互斥。</p><p>延伸阅读：Linux支持的主要三种共享内存方式：mmap()系统调用、Posix共享内存，以及System V共享内存实践</p><p><img src="/2021/04/13/jin-cheng-jian-de-tong-xin-ipc/%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E5%8E%9F%E7%90%86.PNG"></p><p>共享内存原理图</p></li></ul><p><strong>6. 信号量(semaphore)</strong><br> 信号量是一个计数器，用于多进程对共享数据的访问，信号量的意图在于进程间同步。<br> 为了获得共享资源，进程需要执行下列操作：<br> （1）<strong>创建一个信号量</strong>：这要求调用者指定初始值，对于二值信号量来说，它通常是1，也可是0。<br> （2）<strong>等待一个信号量</strong>：该操作会测试这个信号量的值，如果小于0，就阻塞。也称为P操作。<br> （3）<strong>挂出一个信号量</strong>：该操作将信号量的值加1，也称为V操作。</p><p>为了正确地实现信号量，信号量值的测试及减1操作应当是原子操作。为此，信号量通常是在内核中实现的。Linux环境中，有三种类型：<strong>Posix（<a href="https://link.jianshu.com/?t=http://baike.baidu.com/link?url=hYEo6ngm9MlqsQHT3h28baIDxEooeSPX6wr_FdGF-F8mf7wDp2xJWIDtQWGEDxthtPNiJtlsw460g1_N0txJYa">可移植性操作系统接口</a>）有名信号量（使用Posix IPC名字标识）</strong>、<strong>Posix基于内存的信号量（存放在共享内存区中）</strong>、<strong>System V信号量（在内核中维护）</strong>。这三种信号量都可用于进程间或线程间的同步。</p><p><img src="/2021/04/13/jin-cheng-jian-de-tong-xin-ipc/%E8%BF%9B%E7%A8%8B%E4%BD%BF%E7%94%A8%E4%BA%8C%E5%80%BC%E4%BF%A1%E5%8F%B7%E9%87%8F.PNG"></p><p>两个进程使用一个二值信号量</p><p><img src="/2021/04/13/jin-cheng-jian-de-tong-xin-ipc/%E8%BF%9B%E7%A8%8B%E4%BD%BF%E7%94%A8Posix%E6%9C%89%E5%90%8D%E4%BA%8C%E5%80%BC%E4%BF%A1%E5%8F%B7%E9%87%8F.PNG"></p><p>两个进程所以用一个Posix有名二值信号量</p><p><img src="/2021/04/13/jin-cheng-jian-de-tong-xin-ipc/%E4%B8%80%E4%B8%AA%E8%BF%9B%E7%A8%8B%E4%B8%A4%E4%B8%AA%E7%BA%BF%E7%A8%8B%E5%85%B1%E4%BA%AB%E5%9F%BA%E4%BA%8E%E5%86%85%E5%AD%98%E7%9A%84%E4%BF%A1%E5%8F%B7%E9%87%8F.PNG"></p><p>一个进程两个线程共享基于内存的信号量</p><blockquote><p><strong>信号量与普通整型变量的区别：</strong><br> （1）信号量是非负整型变量，除了初始化之外，它只能通过两个标准原子操作：wait(semap) , signal(semap) ; 来进行访问；<br> （2）操作也被成为PV原语（P来源于荷兰语proberen”测试”，V来源于荷兰语verhogen”增加”，P表示通过的意思，V表示释放的意思），而普通整型变量则可以在任何语句块中被访问；</p></blockquote><blockquote><p><strong>信号量与互斥量之间的区别：</strong><br> （1）互斥量用于线程的互斥，信号量用于线程的同步。这是互斥量和信号量的根本区别，也就是互斥和同步之间的区别。<br> <strong>互斥：</strong>是指某一资源同时只允许一个访问者对其进行访问，具有唯一性和排它性。但互斥无法限制访问者对资源的访问顺序，即访问是无序的。<br> <strong>同步：</strong>是指在互斥的基础上（大多数情况），通过其它机制实现访问者对资源的有序访问。<br> 在大多数情况下，同步已经实现了互斥，特别是所有写入资源的情况必定是互斥的。少数情况是指可以允许多个访问者同时访问资源<br> （2）互斥量值只能为0/1，信号量值可以为非负整数。<br> 也就是说，一个互斥量只能用于一个资源的互斥访问，它不能实现多个资源的多线程互斥问题。信号量可以实现多个同类资源的多线程互斥和同步。当信号量为单值信号量是，也可以完成一个资源的互斥访问。<br> （3）互斥量的加锁和解锁必须由同一线程分别对应使用，信号量可以由一个线程释放，另一个线程得到。</p></blockquote><p><strong>7. 套接字(socket)</strong><br> 套接字是一种通信机制，凭借这种机制，客户/服务器（即要进行通信的进程）系统的开发工作既可以在本地单机上进行，也可以跨网络进行。也就是说它可以让不在同一台计算机但通过网络连接计算机上的进程进行通信。</p><p><img src="/2021/04/13/jin-cheng-jian-de-tong-xin-ipc/Socket.PNG"></p><p>Socket是应用层和传输层之间的桥梁</p><p>套接字是支持TCP/IP的网络通信的基本操作单元，可以看做是不同主机之间的进程进行双向通信的端点，简单的说就是通信的两方的一种约定，用套接字中的相关函数来完成通信过程。</p><p><strong>套接字特性</strong><br> 套接字的特性由3个属性确定，它们分别是：域、端口号、协议类型。<br> <strong>（1）套接字的域</strong><br> 它指定套接字通信中使用的网络介质，最常见的套接字域有两种：<br> <strong>一是AF_INET，它指的是Internet网络。</strong>当客户使用套接字进行跨网络的连接时，它就需要用到服务器计算机的IP地址和端口来指定一台联网机器上的某个特定服务，所以在使用socket作为通信的终点，服务器应用程序必须在开始通信之前绑定一个端口，服务器在指定的端口等待客户的连接。<br> <strong>另一个域AF_UNIX，表示UNIX文件系统，</strong>它就是文件输入/输出，而它的地址就是文件名。<br> <strong>（2）套接字的端口号</strong><br> 每一个基于TCP/IP网络通讯的程序(进程)都被赋予了唯一的端口和端口号，端口是一个信息缓冲区，用于保留Socket中的输入/输出信息，端口号是一个16位无符号整数，范围是0-65535，以区别主机上的每一个程序（端口号就像房屋中的房间号），低于256的端口号保留给标准应用程序，比如pop3的端口号就是110，每一个套接字都组合进了IP地址、端口，这样形成的整体就可以区别每一个套接字。<br> <strong>（3）套接字协议类型</strong><br> 因特网提供三种通信机制，<br> <strong>一是流套接字，</strong>流套接字在域中通过TCP/IP连接实现，同时也是AF_UNIX中常用的套接字类型。流套接字提供的是一个有序、可靠、双向字节流的连接，因此发送的数据可以确保不会丢失、重复或乱序到达，而且它还有一定的出错后重新发送的机制。<br> <strong>二个是数据报套接字，</strong>它不需要建立连接和维持一个连接，它们在域中通常是通过UDP/IP协议实现的。它对可以发送的数据的长度有限制，数据报作为一个单独的网络消息被传输,它可能会丢失、复制或错乱到达，UDP不是一个可靠的协议，但是它的速度比较高，因为它并一需要总是要建立和维持一个连接。<br> <strong>三是原始套接字，</strong>原始套接字允许对较低层次的协议直接访问，比如IP、 ICMP协议，它常用于检验新的协议实现，或者访问现有服务中配置的新设备，因为RAW SOCKET可以自如地控制Windows下的多种协议，能够对网络底层的传输机制进行控制，所以可以应用原始套接字来操纵网络层和传输层应用。比如，我们可以通过RAW SOCKET来接收发向本机的ICMP、IGMP协议包，或者接收TCP/IP栈不能够处理的IP包，也可以用来发送一些自定包头或自定协议的IP包。网络监听技术很大程度上依赖于SOCKET_RAW。</p><blockquote><p><strong>原始套接字与标准套接字的区别在于：</strong><br> 原始套接字可以读写内核没有处理的IP数据包，而流套接字只能读取TCP协议的数据，数据报套接字只能读取UDP协议的数据。因此，如果要访问其他协议发送数据必须使用原始套接字。</p></blockquote><p><strong>套接字通信的建立</strong></p><p><img src="/2021/04/13/jin-cheng-jian-de-tong-xin-ipc/Socket%E9%80%9A%E4%BF%A1%E6%B5%81%E7%A8%8B.PNG"></p><p>Socket通信基本流程</p><p><strong>服务器端</strong><br> （1）首先服务器应用程序用系统调用socket来创建一个套接字，它是系统分配给该服务器进程的类似文件描述符的资源，它不能与其他的进程共享。<br> （2）然后，服务器进程会给套接字起个名字，我们使用系统调用bind来给套接字命名。然后服务器进程就开始等待客户连接到这个套接字。<br> （3）接下来，系统调用listen来创建一个队列并将其用于存放来自客户的进入连接。<br> （4）最后，服务器通过系统调用accept来接受客户的连接。它会创建一个与原有的命名套接不同的新套接字，这个套接字只用于与这个特定客户端进行通信，而命名套接字（即原先的套接字）则被保留下来继续处理来自其他客户的连接（建立客户端和服务端的用于通信的流，进行通信）。</p><p><strong>客户端</strong><br> （1）客户应用程序首先调用socket来创建一个未命名的套接字，然后将服务器的命名套接字作为一个地址来调用connect与服务器建立连接。<br> （2）一旦连接建立，我们就可以像使用底层的文件描述符那样用套接字来实现双向数据的通信（通过流进行数据传输）。</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算代码内存消耗</title>
      <link href="2021/04/12/ji-suan-dai-ma-nei-cun-xiao-hao/"/>
      <url>2021/04/12/ji-suan-dai-ma-nei-cun-xiao-hao/</url>
      
        <content type="html"><![CDATA[<h2 id="不同语言的内存管理"><a href="#不同语言的内存管理" class="headerlink" title="不同语言的内存管理"></a>不同语言的内存管理</h2><p>不同的编程语言各自的内存管理方式。</p><ul><li>C/C++这种内存堆空间的申请和释放完全靠自己管理</li><li>Java 依赖JVM来做内存管理，不了解jvm内存管理的机制，很可能会因一些错误的代码写法而导致内存泄漏或内存溢出</li><li>Python内存管理是由私有堆空间管理的，所有的python对象和数据结构都存储在私有堆空间中。程序员没有访问堆的权限，只有解释器才能操作。</li></ul><p>例如Python万物皆对象，并且将内存操作封装的很好，<strong>所以python的基本数据类型所用的内存会要远大于存放纯数据类型所占的内存</strong>，例如，我们都知道存储int型数据需要四个字节，但是使用Python 申请一个对象来存放数据的话，所用空间要远大于四个字节。</p><h2 id="C-的内存管理"><a href="#C-的内存管理" class="headerlink" title="C++的内存管理"></a>C++的内存管理</h2><p>以C++为例来介绍一下编程语言的内存管理。</p><p>如果我们写C++的程序，就要知道栈和堆的概念，程序运行时所需的内存空间分为 固定部分，和可变部分，如下：</p><p><img src="/2021/04/12/ji-suan-dai-ma-nei-cun-xiao-hao/640" alt="图片"></p><p>固定部分的内存消耗 是不会随着代码运行产生变化的， 可变部分则是会产生变化的</p><p>更具体一些，一个由C/C++编译的程序占用的内存分为以下几个部分：</p><ul><li>栈区(Stack) ：由编译器自动分配释放，存放函数的参数值，局部变量的值等，其操作方式类似于数据结构中的栈。</li><li>堆区(Heap) ：一般由程序员分配释放，若程序员不释放，程序结束时可能由OS收回</li><li>未初始化数据区(Uninitialized Data)：存放未初始化的全局变量和静态变量</li><li>初始化数据区(Initialized Data)：存放已经初始化的全局变量和静态变量</li><li>程序代码区(Text)：存放函数体的二进制代码</li></ul><p>代码区和数据区所占空间都是固定的，而且占用的空间非常小，那么看运行时消耗的内存主要看可变部分。</p><p>在可变部分中，栈区间的数据在代码块执行结束之后，系统会自动回收，而堆区间数据是需要程序员自己回收，所以也就是造成内存泄漏的发源地。</p><p><strong>而Java、Python的话则不需要程序员去考虑内存泄漏的问题，虚拟机都做了这些事情</strong>。</p><h2 id="如何计算程序占用多大内存"><a href="#如何计算程序占用多大内存" class="headerlink" title="如何计算程序占用多大内存"></a>如何计算程序占用多大内存</h2><p>想要算出自己程序会占用多少内存就一定要了解自己定义的数据类型的大小，如下：</p><p><img src="/2021/04/12/ji-suan-dai-ma-nei-cun-xiao-hao/640" alt="图片"></p><p>注意图中有两个不一样的地方，为什么64位的指针就占用了8个字节，而32位的指针占用4个字节呢？</p><p>1个字节占8个比特，那么4个字节就是32个比特，可存放数据的大小为2^32，也就是4G空间的大小，即：可以寻找4G空间大小的内存地址。</p><p>大家现在使用的计算机一般都是64位了，所以编译器也都是64位的。</p><p>安装64位的操作系统的计算机内存都已经超过了4G，也就是指针大小如果还是4个字节的话，就已经不能寻址全部的内存地址，所以64位编译器使用8个字节的指针才能寻找所有的内存地址。</p><p>注意2^64是一个非常巨大的数，对于寻找地址来说已经足够用了。</p><h2 id="内存对齐"><a href="#内存对齐" class="headerlink" title="内存对齐"></a>内存对齐</h2><p>再介绍一下内存管理中另一个重要的知识点：<strong>内存对齐</strong>。</p><p><strong>不要以为只有C/C++才会有内存对齐，只要可以跨平台的编程语言都需要做内存对齐，Java、Python都是一样的</strong>。</p><p>而且这是面试中面试官非常喜欢问到的问题，就是：<strong>为什么会有内存对齐？</strong></p><p>主要是两个原因</p><ol><li>平台原因：不是所有的硬件平台都能访问任意内存地址上的任意数据，某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常。为了同一个程序可以在多平台运行，需要内存对齐。</li><li>硬件原因：经过内存对齐后，CPU访问内存的速度大大提升。</li></ol><p>可以看一下这段C++代码输出的各个数据类型大小是多少？</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">struct node{   int num;   char cha;}st;int main() {    int a[100];    char b[100];    cout &lt;&lt; sizeof(int) &lt;&lt; endl;    cout &lt;&lt; sizeof(char) &lt;&lt; endl;    cout &lt;&lt; sizeof(a) &lt;&lt; endl;    cout &lt;&lt; sizeof(b) &lt;&lt; endl;    cout &lt;&lt; sizeof(st) &lt;&lt; endl;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>看一下和自己想的结果一样么， 我们来逐一分析一下。</p><p>其输出的结果依次为：</p><pre class="line-numbers language-none"><code class="language-none">414001008<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此时会发现，和单纯计算字节数的话是有一些误差的。</p><p>这就是因为内存对齐的原因。</p><p>来看一下内存对齐和非内存对齐产生的效果区别。</p><p>CPU读取内存不是一次读取单个字节，而是一块一块的来读取内存，块的大小可以是2，4，8，16个字节，具体取多少个字节取决于硬件。</p><p>假设CPU把内存划分为4字节大小的块，要读取一个4字节大小的int型数据，来看一下这两种情况下CPU的工作量：</p><p>第一种就是内存对齐的情况，如图：</p><p><img src="/2021/04/12/ji-suan-dai-ma-nei-cun-xiao-hao/640" alt="图片">内存对齐</p><p>一字节的char占用了四个字节，空了三个字节的内存地址，int数据从地址4开始。</p><p>此时，直接将地址4，5，6，7处的四个字节数据读取到即可。</p><p>第二种是没有内存对齐的情况如图：</p><p><img src="/2021/04/12/ji-suan-dai-ma-nei-cun-xiao-hao/640" alt="图片">非内存对齐</p><p>char型的数据和int型的数据挨在一起，该int数据从地址1开始，那么CPU想要读这个数据的话来看看需要几步操作：</p><ol><li>因为CPU是四个字节四个字节来寻址，首先CPU读取0，1，2，3处的四个字节数据</li><li>CPU读取4，5，6，7处的四个字节数据</li><li>合并地址1，2，3，4处四个字节的数据才是本次操作需要的int数据</li></ol><p>此时一共需要两次寻址，一次合并的操作。</p><p><strong>大家可能会发现内存对齐岂不是浪费的内存资源么？</strong></p><p>是这样的，但事实上，相对来说计算机内存资源一般都是充足的，我们更希望的是提高运行速度。</p><p><strong>编译器一般都会做内存对齐的优化操作，也就是说当考虑程序真正占用的内存大小的时候，也需要认识到内存对齐的影响</strong>。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>负载均衡</title>
      <link href="2021/04/10/fu-zai-jun-heng/"/>
      <url>2021/04/10/fu-zai-jun-heng/</url>
      
        <content type="html"><![CDATA[<h1 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h1><p>概念：LB (Load Balance，负载均衡)是一种集群技术，它将特定的业务（网络服务、网络流量等）分担给多台网络设备（包括服务器、防火墙等）或多条链路，从而提高了业务处理能力，保证了业务的高可靠性。</p><p>负载均衡计数具有以下优势：</p><ol><li>高性能：负载均衡技术将业务较均衡地分担到多台设备或链路上，从而提高了整个系统的性能。</li><li>可扩展性：负载均衡技术可以方便的增加集群中设备或链路的数量，在不降低业务质量的前提下满足不断增长的业务需求。</li><li>高可靠性：单个设置多个设备或链路故障也不会导致业务中断，提高了系统的可靠性。</li><li>可管理性：大量的管理共组都集中在使用负载均衡技术的设备上，设备集群或链路集群只需要维护通过的配置即可。</li><li>透明性：对用户而言，集群等于一个或多个高可靠性、高性能的设备或链路，用户感知不到，也不关心具体的网络结构，增加或减少设备或链路数量都不会影响正常的业务。</li></ol><p>负载均衡技术分类：</p><ol><li>服务器负载均衡：在数据中心等组网环境中，可以采用服务器负载均衡，将网络服务分担给多台服务器进行处理，提高数据中心的业务处理能力。</li><li>链路负载均衡：在有多个运营商出接口的组网环境中，可以采用出方向多链路动态负载均衡，实现链路的动态选择，提高服务的可靠性。</li><li>防火墙负载均衡：在防火墙处理能力成为瓶颈的组网环境中，可以采用防火墙负载均衡，将网络流量分担给多态防火墙设备，提高防火墙的处理能力。</li></ol><h2 id="负载均衡算法"><a href="#负载均衡算法" class="headerlink" title="负载均衡算法"></a>负载均衡算法</h2><p>最简单的负载均衡算法是随机算法和轮询算法。</p><p>模拟加权随机算法</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> deviceList <span class="token operator">=</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span>            <span class="token string">"192.168.0.1"</span><span class="token punctuation">,</span>            <span class="token string">"192.168.0.2"</span><span class="token punctuation">,</span>            <span class="token string">"192.168.0.3"</span><span class="token punctuation">,</span>            <span class="token string">"192.168.0.4"</span><span class="token punctuation">,</span>            <span class="token string">"192.168.0.5"</span><span class="token punctuation">,</span>            <span class="token string">"192.168.0.6"</span>    <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> weightMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">getServer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">String</span> ip <span class="token operator">:</span> weightMap<span class="token punctuation">.</span><span class="token function">keySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">Integer</span> integer <span class="token operator">=</span> weightMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>ip<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> integer<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>ip<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token class-name">Random</span> random <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> list<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>random<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span>list<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token annotation punctuation">@Test</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">runTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token class-name">Random</span> random <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    deviceList<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span> <span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>weightMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> random<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token function">getServer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>简单的轮询就是依次遍历每台机子，把业务放在当前遍历的机子上就行。</p><p>模拟轮询：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 负载均衡 java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 负载均衡 java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pythonBase</title>
      <link href="2021/04/09/pythonbase/"/>
      <url>2021/04/09/pythonbase/</url>
      
        <content type="html"><![CDATA[<h2 id="1-Python线程模块"><a href="#1-Python线程模块" class="headerlink" title="1. Python线程模块"></a>1. Python线程模块</h2><p>GIL（Global Interpreter Lock，全局解释器锁）不是Python独有的特性，它只是在实现CPython（Python解释器）时，引入的一个概念。在官方网站中定义如下：</p><blockquote><p>In CPython, the global interpreter lock, or GIL, is a mutex that prevents multiple native threads from executing Python bytecodes at once. This lock is necessary mainly because CPython’s memory management is not thread-safe. (However, since the GIL exists, other features have grown to depend on the guarantees that it enforces.)</p></blockquote><p>由定义可知，GIL是一个互斥锁（mutex）。它阻止了 多个线程同时执行Python字节码，毫无疑问，这降低了执行效率。理解GIL的必要性，需要了解CPython对于线程安全的内存管理机制。</p><p>首先，我们来看看单核CPU下，多线程任务是如何调度的。</p><p><img src="/2021/04/09/pythonbase/v2-036bb273ba382803c29bfe075ed07b8d_1440w.jpg" alt="img"></p><p>由图可知，由于GIL的机制，单核CPU在同一时刻只有一个线程在运行。当线程遇到IO操作或Timer Tick到期，释放GIL锁。其他的两个线程去竞争这把锁，得到锁之后，才开始运行。</p><p>线程释放GIL锁有两种情况，一是遇到IO操作，二是Time Tick到期。IO操作很好理解，比如发出一个http请求，等待响应。那么Time Tick到期是什么呢？Time Tick规定了线程的最长执行时间，超过时间后自动释放GIL锁。</p><p>虽然都是释放GIL锁，但这两种情况是不一样的。比如，Thread1遇到IO操作释放GIL，由Thread2和Thread3来竞争这个GIL锁，Thread1不再参与这次竞争。如果是Thread1因为Time Tick到期释放GIL，那么三个线程可以同时竞争这把GIL锁，可能出现Thread1在竞争中胜出，再次执行的情况。单核CPU下，这种情况不算特别糟糕。因为只有1个CPU，所以CPU的利用率是很高的。</p><p>在多核CPU下，由于GIL锁的全局特性，无法发挥多核的特性，GIL锁会使得多线程任务的效率大大降低。</p><p><img src="/2021/04/09/pythonbase/v2-3577df8b9dd94d4f2075e34a67aaa919_1440w.jpg" alt="img"></p><p>Thread1在CPU1上运行，Thread2在CPU2上运行。GIL是全局的，CPU2上的Thread2需要等待CPU1上的Thread1让出GIL锁，才有可能执行。如果在多次竞争中，Thread1都胜出，Thread2没有得到GIL锁，意味着CPU2一直是闲置的，无法发挥多核的优势。</p><p>为了避免同一线程霸占CPU，在python3.x中，线程会自动的调整自己的优先级，使得多线程任务执行效率更高。</p><p>既然GIL降低了多核的效率，那保留它的目的是什么呢？这就和线程执行的安全有关。</p><p>准确的说，GIL的线程安全是粗粒度的。也就是说，有GIL都不意味着线程安全。比如下面这个例子:</p><pre class="line-numbers language-python3" data-language="python3"><code class="language-python3">def add():    global n    for i in range(10**1000):        n = n +1def sub():    global n    for i in range(10**1000):        n = n - 1n = 0import threadinga = threading.Thread(target=add,)b = threading.Thread(target=sub,)a.start()b.start()#join 用于阻塞主线程，避免过早打印na.join()b.join()print n<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面的程序对n做了同样数量的加法和减法，那么n理论上是0。但运行程序，打印n，发现它不是0。问题出在哪里呢，问题在于python的每行代码不是原子化的操作。比如n = n+1这步，不是一次性执行的。如果去查看python编译后的字节码执行过程，可以看到如下结果。</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">19 LOAD_GLOBAL              1 (n)22 LOAD_CONST               3 (1)25 BINARY_ADD          26 STORE_GLOBAL             1 (n)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>从过程可以看出，n = n +1 操作分成了四步完成。因此，n = n+1不是一个原子化操作。</p><p>1.加载全局变量n，2.加载常数1，3.进行二进制加法运算，4.将运算结果存入变量n。</p><p>根据前面的线程释放GIL锁原则，线程a执行这四步的过程中，有可能会让出GIL。如果这样，n=n+1的运算过程就被打乱了。最后的结果中，得到一个非零的n也就不足为奇。</p><p>这就是为什么我们说GIL是粗粒度的，它只保证了一定程度的安全。如果要做到线程的绝对安全，是不是所有的非IO操作，我们都需要自己再加一把锁呢？答案是否定的。在python中，有些操作是是原子级的，它本身就是一个字节码，GIL无法在执行过程中释放。对于这种原子级的方法操作，我们无需担心它的安全。比如sort方法，[1,4,2].sort()，翻译成字节码就是CALL METHOD 0。只有一行，无法再分，所以它是线程安全的。</p><p><strong>总结</strong></p><p>对于IO密集型应用，多线程的应用和多进程应用区别不大。即便有GIL存在，由于IO操作会导致GIL释放，其他线程能够获得执行权限。由于多线程的通讯成本低于多进程，因此偏向使用多线程。</p><p>对于计算密集型应用，多线程处于绝对劣势，可以采用多进程或协程。</p><h3 id="1-1-实际使用"><a href="#1-1-实际使用" class="headerlink" title="1.1 实际使用"></a>1.1 实际使用</h3><p>python主要通过<code>thread</code>和<code>threading</code>这两个模块来实现多线程支持。python的thread模块是比较底层的模块，<code>threding</code>是对thread做了一些封装，可以更方便的被使用。但是python由于GIL的存在无法使用threading充分利用GPU资源，如果想充分发挥多核CPU的计算能力需要使用<code>multiprocessing</code>模块。</p><h3 id="1-1-1-如何创建线程"><a href="#1-1-1-如何创建线程" class="headerlink" title="1.1.1 如何创建线程"></a>1.1.1 如何创建线程</h3><p><code>python3.x</code>中已经放弃了<code>python2.x</code>中采用函数式<code>thread</code>模块中的<code>start_new_thread()</code>函数来产生新线程的方式。</p><p>python3中通过threading模块创建新的线程有两种方法：</p><p>第一种是通过threading.Thread(Target=executable Method)——即传递给Thread对象一个可执行方法（或对象）。</p><p>第二种是继承threading.Thread定义子类并重写run()方法。</p><p>（1）通过threading.Thread进行创建多线程</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Socket</title>
      <link href="2021/04/09/socket/"/>
      <url>2021/04/09/socket/</url>
      
        <content type="html"><![CDATA[<h1 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h1><h3 id="1-socket读写缓冲区的工作机制"><a href="#1-socket读写缓冲区的工作机制" class="headerlink" title="1. socket读写缓冲区的工作机制"></a>1. socket读写缓冲区的工作机制</h3><p>每个socket都有两个缓冲区，一个是输入缓冲区，一个是输出缓冲区。</p><p><img src="/2021/04/09/socket/socket%E7%BC%93%E5%86%B2%E5%8C%BA.PNG"></p><p><font color="red">有这么一种特殊情况</font>，如果你的<code>socket</code>已经<code>close</code>了，你的输出缓冲区还有数据，这时TCP会继续将剩下的缓冲区数据发送给对方。</p><p>但是socket去close时输入缓冲区还有数据，这时输入缓冲区的数据就丢失了。</p><h2 id="一、I-O-模型"><a href="#一、I-O-模型" class="headerlink" title="一、I/O 模型"></a>一、I/O 模型</h2><p>一个输入操作通常包括两个阶段：</p><ul><li>等待数据准备好</li><li>从内核向进程复制数据</li></ul><p>对于一个套接字上的输入操作，第一步通常涉及等待数据从网络中到达。当所等待数据到达时，它被复制到内核中的某个缓冲区。第二步就是把数据从内核缓冲区复制到应用进程缓冲区。</p><p>Unix 有五种 I/O 模型：</p><ul><li>阻塞式 I/O</li><li>非阻塞式 I/O</li><li>I/O 复用（select 和 poll）</li><li>信号驱动式 I/O（SIGIO）</li><li>异步 I/O（AIO）</li></ul><h3 id="1-阻塞式-I-O"><a href="#1-阻塞式-I-O" class="headerlink" title="1. 阻塞式 I/O"></a>1. 阻塞式 I/O</h3><p>应用进程被阻塞，直到数据从内核缓冲区复制到应用进程缓冲区中才返回。</p><p>应该注意到，在阻塞的过程中，其它应用进程还可以执行，因此阻塞不意味着整个操作系统都被阻塞。因为其它应用进程还可以执行，所以不消耗 CPU 时间，这种模型的 CPU 利用率会比较高。</p><p>下图中，recvfrom() 用于接收 Socket 传来的数据，并复制到应用进程的缓冲区 buf 中。这里把 recvfrom() 当成系统调用。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token class-name">ssize_t</span> <span class="token function">recvfrom</span><span class="token punctuation">(</span><span class="token keyword">int</span> sockfd<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>buf<span class="token punctuation">,</span> <span class="token class-name">size_t</span> len<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">sockaddr</span> <span class="token operator">*</span>src_addr<span class="token punctuation">,</span> <span class="token class-name">socklen_t</span> <span class="token operator">*</span>addrlen<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/2021/04/09/socket/1492928416812_4.png" alt="img"></p><h3 id="2-非阻塞式-I-O"><a href="#2-非阻塞式-I-O" class="headerlink" title="2. 非阻塞式 I/O"></a>2. 非阻塞式 I/O</h3><p>应用进程执行系统调用之后，内核返回一个错误码。应用进程可以继续执行，但是需要不断的执行系统调用来获知 I/O 是否完成，这种方式称为轮询（polling）。</p><p>由于 CPU 要处理更多的系统调用，因此这种模型的 CPU 利用率比较低。</p><p><img src="/2021/04/09/socket/1492929000361_5.png" alt="img"></p><h3 id="I-O-复用"><a href="#I-O-复用" class="headerlink" title="I/O 复用"></a>I/O 复用</h3><p>因为在多线程中上下文切换代价太高，将其转换为单线程的思路。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//单线程轮询的方式，如果数据没读完就一直读下去</span><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>fdx in <span class="token punctuation">(</span>cache<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>fdx have data<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">//这里的判断还是我们自己的程序做的，效率可能不是很高，用上系统内部的东西就好了</span>            <span class="token function">read</span><span class="token punctuation">(</span>fdx<span class="token punctuation">)</span><span class="token punctuation">;</span>            process<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="1-select-函数的代码"><a href="#1-select-函数的代码" class="headerlink" title="1. select 函数的代码"></a><strong>1. select 函数的代码</strong></h4><p><img src="/2021/04/09/socket/selectCode.PNG"></p><p>select函数实现I/O端口的复用，传递给select函数的参数会告诉内核：</p><ol><li>我们所关心的文件描述符</li><li>对每个文件描述符，我们所关心的状态</li><li>我们要等待多长时间</li></ol><p>从select函数返回后，内核告诉我们以下信息：</p><ol><li>对我们的要求已经做好准备的描述符个数</li><li>对于三种条件哪些描述符已经做好准备（读，写，异常）。</li></ol><p>Linux select 函数接口：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;sys/select.h&gt;int select(int maxfdp1, fd_set *readset, fd_set *writeset, fd_set *exceptset, struct timeval *timeout);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>其中的timeval结构定义如下：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">struct timeval {    long tv_sec;//秒    long tv_usec;//微秒}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>有三种情况</p><ol><li>timeout == NULL 等待无限长的时间</li><li>timeout -&gt; tv_sec == 0 &amp;&amp; timeout -&gt; tv_usec == 0 不等待，直接返回。（非阻塞）</li><li>timeout -&gt; tv_sec != 0 &amp;&amp; timeout -&gt; tv_usec != 0 等待指定的时间。</li></ol><p>中间的三个参数readset，writeset和exceptset，指向描述符集。这些参数指明了我们关心哪些描述符，和满足什么条件（可写，可读，异常）。</p><p>一个文件描述符存储在fd_set类型中，fd_set其实就是位图(bitmap)；这个fd_set的长度是1024，但是有的时候我们仅仅需要个位数的读取，所以使用maxfdp1来设置最大真正的有效位。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">fdset  = 0001110000000000000000000000000......    maxfdp1 = 5 (index start from 0,和网上说的有效位数+1是一个意思)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>linux提供了一组宏，来为fd_set进行赋值等操作。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;sys/select.h&gt;// FD_ZERO宏将一个fd_set类型的所有位设置为0int FD_ZERO(fd_set *fdset);//清除某个位时用 FD_CLRint FD_CLR(int fd, fdset *fdset);//使用FD_SET将指定位置的bit值设置为1int FD_SET(int fd, fdset *fdset);//FD_ISSET 来测试某个位是否被置位int FD_ISSET(int fd, fd_set *fdset);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>参数中int maxfdp 是一个整数值，是指集合中所有文件描述符的范围，即所有文件描述符的最大值加1，不能错。</p><p>C++中使用 linux select 函数的demo</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include "sys/select.h"//socket 建立连接sockfd = socket(AF_INEF, SOCK_STREAM, 0);memset(&amp;addr, 0, sizeof(addr));addr.sin_family = AF_INET;addr.sin_port = htons(2000);addr.sin_addr.s.addr = INADDR_ANY;bind(sockfd, (struct sockaddr*)&amp;addr, sizeof(addr));listen(sockfd, s);for(int i = 0; i &lt; 5; i++) {    memset(&amp;client, 0, sizeof(client));    addrlen = sizeof(client);    fds[i] = accept(sockfd, (struct sockaddr*)&amp;client, &amp;addrlen);    if(fds[i] &gt; max) {        max = fds[i];    }}while (1) {    FD_ZERO(&amp;rset);    for (int i = 0; i &lt; 5; i++) {        FD_SET(fds[i], &amp;rset);    }    print("round again");    select(max + 1, &amp;rset, NULL, NULL, NULL);        for (int i = 0; i &lt; 5; i++) {        if (FD_ISSET(fds[i], &amp;rset)) {            memset(buffer, 0, MAXBUF);            read(fds[i], buffer, MAXBUF);            print(buffer);        }    }   }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>缺点：</p><ol><li>reset每次不能复用，需要重新设置。从用户空间复制到内核空间，总是拷贝。</li><li>fd_set 1024个大小限制。</li></ol><h4 id="2-epoll"><a href="#2-epoll" class="headerlink" title="2. epoll"></a>2. epoll</h4><p>是在2.6内核中提出的。是之前<code>select</code>和<code>poll</code>的增强版本。epoll没有描述符大小限制，使用一个文件描述符管理多个文件描述符，将用户关心的文件描述符的时间存放到内核的一个事件表中，这样在用户空间和内核空间的copy只需要一次。</p><p>大体结构：</p><p><img src="/2021/04/09/socket/epoll%E7%BB%93%E6%9E%84.PNG"></p><p>fd指定epoll里面哪个socket，epoll里面有个列表保存很多个事件（对应socket）。然后有很多个不同的epoll。</p><p>每个epoll里面有事件列表和就绪列表。就绪列表里面保存已经注册的事件信息。就绪列表主要是由<code>epoll_wait()</code>进行访问，当就绪列表里面有信息时可以直接返回，当没有信息，则需要阻塞（指定的timeout，当timeout设定为 -1 时一直阻塞直到有信息）。</p><p>————————————————</p><p>epoll过程需要三个接口：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;sys/epoll.h&gt;//这个函数是个系统函数，函数将在内核空间内开辟一块新的空间，可以理解为epoll结构空间，返回值为epoll的文件描述符编号，方便后续操作使用。int epoll_create(int size);//是epoll函数的事件注册函数，把事件放到事件列表里面。这样事件的任何改动内核可以直到，不用来回改动。（实际上事件的注册与销毁频率不会太高，所以和内核态交互不会太频繁）。epoll与select不同，select函数是调用时指定需要监听的描述符和事件，epoll先将用户感兴趣的描述符事件注册到epoll空间，此函数//是非阻塞函数，作用仅仅是增删改epoll空间内的描述符信息。//参数：epfd，指定哪个epoll，从而可以让后面的进程fd编号找到匹配的socket，函数将依靠编号找到对应的epoll结构。//op，表示当前请求类型，由三个宏定义(EPOLL_CTL_ADD:注册新的fd到epfd中、EPOLL_CTL_MOD:修改已经注册的fd的监听事件、EPOLL_CTL_DEL：从epfd中删除一个fd)int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);//epoll_wait 等待事件的产生，类似于select()调用，根据参数timeout，来决定是否阻塞。//返回回来的事件都是就绪事件，不用像select一位一位检查是否就绪。//int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>epoll_event结构：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">struct epoll_event {    _unit32_t events; //Epoll events    epoll_data_t data // User data variable}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>events可以是以下几个宏的集合：表明对哪种事件感兴趣</p><p>EPOLLIN（读事件）、EPOLLOUT、EPOLLRPI、EPOLLERR、EPOLLHUP（挂断）、EPOLLET（边缘触发）、EPOLLONESHOT（只监听一次，事件触发后自动清除该fd，从epoll列表）。</p><p><strong>工作模式：</strong></p><p>1.LT（水平触发）和ET（边缘触发）。LT是默认模式，LT模式与ET模式的区别如下：</p><p>LT：事件就绪后，用户可以选择处理或者不处理，如果用户本次未处理，那么下次调用epoll_wait时仍然会将未处理的事件打包给你。</p><p>ET：事件就绪后，用户必须处理，因为内核不给你兜底了，内核把就绪事件打包给你后，就把对应的就绪事件删除。</p><p>ET模式很大程度上减少了epoll事件被重复触发的次数，因此效率比LT模式高。</p><p><strong>代码示例：</strong></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int epfd = epoll_create(10);struct epoll_event events[5];for (int i = 0; i &lt; 5; i++) {    static struct epoll_event ev;    memset(&amp;client, 0, sizeof(client));    addlen = sizeof(client);    ev.data.fd = accept(sockfd, (struct sockaddr*)&amp;client, &amp;addrlen);    ev.events = EPOLLIN;    epoll_ctl(epfd, EPOLL_CTL_ADD, ev.data.fd, &amp;ev);}while (1) {    print("round again");    nfds = epoll_wait(epfd, events, 5, 10000);    for (int i = 0; i &lt; nfds; i++) {        memset(buffer, 0, MAXBUF);        read(events[i].data.fd, buffer, MAXBUF);        prints(buffer);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>epoll原理</strong>:</p><p><img src="/2021/04/09/socket/epoll%E5%8E%9F%E7%90%86.PNG"></p><p>监听事件列表是个红黑树，加快寻找速度。</p><p>使用 select 或者 poll 等待数据，并且可以等待多个套接字中的任何一个变为可读。这一过程会被阻塞，当某一个套接字可读时返回，之后再使用 recvfrom 把数据从内核复制到进程中。</p><p>它可以让单个进程具有处理多个 I/O 事件的能力。又被称为 Event Driven I/O，即事件驱动 I/O。</p><p>如果一个 Web 服务器没有 I/O 复用，那么每一个 Socket 连接都需要创建一个线程去处理。如果同时有几万个连接，那么就需要创建相同数量的线程。相比于多进程和多线程技术，I/O 复用不需要进程线程创建和切换的开销，系统开销更小。</p><p><img src="/2021/04/09/socket/1492929444818_6.png" alt="img"></p><p>场景：设计高性能服务器。</p><h3 id="信号驱动-I-O"><a href="#信号驱动-I-O" class="headerlink" title="信号驱动 I/O"></a>信号驱动 I/O</h3><p>应用进程使用 sigaction 系统调用，内核立即返回，应用进程可以继续执行，也就是说等待数据阶段应用进程是非阻塞的。内核在数据到达时向应用进程发送 SIGIO 信号，应用进程收到之后在信号处理程序中调用 recvfrom 将数据从内核复制到应用进程中。</p><p>相比于非阻塞式 I/O 的轮询方式，信号驱动 I/O 的 CPU 利用率更高。</p><p><img src="/2021/04/09/socket/1492929553651_7.png" alt="img"></p><h3 id="异步-I-O"><a href="#异步-I-O" class="headerlink" title="异步 I/O"></a>异步 I/O</h3><p>应用进程执行 aio_read 系统调用会立即返回，应用进程可以继续执行，不会被阻塞，内核会在所有操作完成之后向应用进程发送信号。</p><p>异步 I/O 与信号驱动 I/O 的区别在于，异步 I/O 的信号是通知应用进程 I/O 完成，而信号驱动 I/O 的信号是通知应用进程可以开始 I/O。</p><p><img src="/2021/04/09/socket/1492930243286_8.png" alt="img"></p><h3 id="五大-I-O-模型比较"><a href="#五大-I-O-模型比较" class="headerlink" title="五大 I/O 模型比较"></a>五大 I/O 模型比较</h3><ul><li>同步 I/O：将数据从内核缓冲区复制到应用进程缓冲区的阶段（第二阶段），应用进程会阻塞。</li><li>异步 I/O：第二阶段应用进程不会阻塞。</li></ul><p>同步 I/O 包括阻塞式 I/O、非阻塞式 I/O、I/O 复用和信号驱动 I/O ，它们的主要区别在第一个阶段。</p><p>非阻塞式 I/O 、信号驱动 I/O 和异步 I/O 在第一阶段不会阻塞。</p><p><img src="/2021/04/09/socket/1492928105791_3.png" alt="img"></p><h2 id="二、I-O-复用"><a href="#二、I-O-复用" class="headerlink" title="二、I/O 复用"></a>二、I/O 复用</h2><p>select/poll/epoll 都是 I/O 多路复用的具体实现，select 出现的最早，之后是 poll，再是 epoll。</p><h3 id="select"><a href="#select" class="headerlink" title="select"></a>select</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">select</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> fd_set <span class="token operator">*</span>readfds<span class="token punctuation">,</span> fd_set <span class="token operator">*</span>writefds<span class="token punctuation">,</span> fd_set <span class="token operator">*</span>exceptfds<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">timeval</span> <span class="token operator">*</span>timeout<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>select 允许应用程序监视一组文件描述符，等待一个或者多个描述符成为就绪状态，从而完成 I/O 操作。</p><ul><li>fd_set 使用数组实现，数组大小使用 FD_SETSIZE 定义，所以只能监听少于 FD_SETSIZE 数量的描述符。有三种类型的描述符类型：readset、writeset、exceptset，分别对应读、写、异常条件的描述符集合。</li><li>timeout 为超时参数，调用 select 会一直阻塞直到有描述符的事件到达或者等待的时间超过 timeout。</li><li>成功调用返回结果大于 0，出错返回结果为 -1，超时返回结果为 0。</li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c">fd_set fd_in<span class="token punctuation">,</span> fd_out<span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">timeval</span> tv<span class="token punctuation">;</span><span class="token comment">// Reset the sets</span><span class="token function">FD_ZERO</span><span class="token punctuation">(</span> <span class="token operator">&amp;</span>fd_in <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">FD_ZERO</span><span class="token punctuation">(</span> <span class="token operator">&amp;</span>fd_out <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// Monitor sock1 for input events</span><span class="token function">FD_SET</span><span class="token punctuation">(</span> sock1<span class="token punctuation">,</span> <span class="token operator">&amp;</span>fd_in <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// Monitor sock2 for output events</span><span class="token function">FD_SET</span><span class="token punctuation">(</span> sock2<span class="token punctuation">,</span> <span class="token operator">&amp;</span>fd_out <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// Find out which socket has the largest numeric value as select requires it</span><span class="token keyword">int</span> largest_sock <span class="token operator">=</span> sock1 <span class="token operator">&gt;</span> sock2 <span class="token operator">?</span> sock1 <span class="token operator">:</span> sock2<span class="token punctuation">;</span><span class="token comment">// Wait up to 10 seconds</span>tv<span class="token punctuation">.</span>tv_sec <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>tv<span class="token punctuation">.</span>tv_usec <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">// Call the select</span><span class="token keyword">int</span> ret <span class="token operator">=</span> <span class="token function">select</span><span class="token punctuation">(</span> largest_sock <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>fd_in<span class="token punctuation">,</span> <span class="token operator">&amp;</span>fd_out<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>tv <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// Check if select actually succeed</span><span class="token keyword">if</span> <span class="token punctuation">(</span> ret <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token punctuation">)</span>    <span class="token comment">// report error and abort</span><span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span> ret <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">)</span>    <span class="token comment">// timeout; no event detected</span><span class="token keyword">else</span><span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token function">FD_ISSET</span><span class="token punctuation">(</span> sock1<span class="token punctuation">,</span> <span class="token operator">&amp;</span>fd_in <span class="token punctuation">)</span> <span class="token punctuation">)</span>        <span class="token comment">// input event on sock1</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token function">FD_ISSET</span><span class="token punctuation">(</span> sock2<span class="token punctuation">,</span> <span class="token operator">&amp;</span>fd_out <span class="token punctuation">)</span> <span class="token punctuation">)</span>        <span class="token comment">// output event on sock2</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">poll</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">pollfd</span> <span class="token operator">*</span>fds<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> nfds<span class="token punctuation">,</span> <span class="token keyword">int</span> timeout<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>poll 的功能与 select 类似，也是等待一组描述符中的一个成为就绪状态。</p><p>poll 中的描述符是 pollfd 类型的数组，pollfd 的定义如下：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">pollfd</span> <span class="token punctuation">{</span>               <span class="token keyword">int</span>   fd<span class="token punctuation">;</span>         <span class="token comment">/* file descriptor */</span>               <span class="token keyword">short</span> events<span class="token punctuation">;</span>     <span class="token comment">/* requested events */</span>               <span class="token keyword">short</span> revents<span class="token punctuation">;</span>    <span class="token comment">/* returned events */</span>           <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment">// The structure for two events</span><span class="token keyword">struct</span> <span class="token class-name">pollfd</span> fds<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">// Monitor sock1 for input</span>fds<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>fd <span class="token operator">=</span> sock1<span class="token punctuation">;</span>fds<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>events <span class="token operator">=</span> POLLIN<span class="token punctuation">;</span><span class="token comment">// Monitor sock2 for output</span>fds<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>fd <span class="token operator">=</span> sock2<span class="token punctuation">;</span>fds<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>events <span class="token operator">=</span> POLLOUT<span class="token punctuation">;</span><span class="token comment">// Wait 10 seconds</span><span class="token keyword">int</span> ret <span class="token operator">=</span> <span class="token function">poll</span><span class="token punctuation">(</span> <span class="token operator">&amp;</span>fds<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">10000</span> <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// Check if poll actually succeed</span><span class="token keyword">if</span> <span class="token punctuation">(</span> ret <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token punctuation">)</span>    <span class="token comment">// report error and abort</span><span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span> ret <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">)</span>    <span class="token comment">// timeout; no event detected</span><span class="token keyword">else</span><span class="token punctuation">{</span>    <span class="token comment">// If we detect the event, zero it out so we can reuse the structure</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span> fds<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>revents <span class="token operator">&amp;</span> POLLIN <span class="token punctuation">)</span>        fds<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>revents <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token comment">// input event on sock1</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span> fds<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>revents <span class="token operator">&amp;</span> POLLOUT <span class="token punctuation">)</span>        fds<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>revents <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token comment">// output event on sock2</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h3><h4 id="1-功能"><a href="#1-功能" class="headerlink" title="1. 功能"></a>1. 功能</h4><p>select 和 poll 的功能基本相同，不过在一些实现细节上有所不同。</p><ul><li>select 会修改描述符，而 poll 不会；</li><li>select 的描述符类型使用数组实现，FD_SETSIZE 大小默认为 1024，因此默认只能监听少于 1024 个描述符。如果要监听更多描述符的话，需要修改 FD_SETSIZE 之后重新编译；而 poll 没有描述符数量的限制；</li><li>poll 提供了更多的事件类型，并且对描述符的重复利用上比 select 高。</li><li>如果一个线程对某个描述符调用了 select 或者 poll，另一个线程关闭了该描述符，会导致调用结果不确定。</li></ul><h4 id="2-速度"><a href="#2-速度" class="headerlink" title="2. 速度"></a>2. 速度</h4><p>select 和 poll 速度都比较慢，每次调用都需要将全部描述符从应用进程缓冲区复制到内核缓冲区。</p><h4 id="3-可移植性"><a href="#3-可移植性" class="headerlink" title="3. 可移植性"></a>3. 可移植性</h4><p>几乎所有的系统都支持 select，但是只有比较新的系统支持 poll。</p><h3 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">epoll_create</span><span class="token punctuation">(</span><span class="token keyword">int</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">epoll_ctl</span><span class="token punctuation">(</span><span class="token keyword">int</span> epfd<span class="token punctuation">,</span> <span class="token keyword">int</span> op<span class="token punctuation">,</span> <span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">epoll_event</span> <span class="token operator">*</span>event<span class="token punctuation">)</span>；<span class="token keyword">int</span> <span class="token function">epoll_wait</span><span class="token punctuation">(</span><span class="token keyword">int</span> epfd<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">epoll_event</span> <span class="token operator">*</span> events<span class="token punctuation">,</span> <span class="token keyword">int</span> maxevents<span class="token punctuation">,</span> <span class="token keyword">int</span> timeout<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>epoll_ctl() 用于向内核注册新的描述符或者是改变某个文件描述符的状态。已注册的描述符在内核中会被维护在一棵红黑树上，通过回调函数内核会将 I/O 准备好的描述符加入到一个链表中管理，进程调用 epoll_wait() 便可以得到事件完成的描述符。</p><p>从上面的描述可以看出，epoll 只需要将描述符从进程缓冲区向内核缓冲区拷贝一次，并且进程不需要通过轮询来获得事件完成的描述符。</p><p>epoll 仅适用于 Linux OS。</p><p>epoll 比 select 和 poll 更加灵活而且没有描述符数量限制。</p><p>epoll 对多线程编程更有友好，一个线程调用了 epoll_wait() 另一个线程关闭了同一个描述符也不会产生像 select 和 poll 的不确定情况。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// Create the epoll descriptor. Only one is needed per app, and is used to monitor all sockets.</span><span class="token comment">// The function argument is ignored (it was not before, but now it is), so put your favorite number here</span><span class="token keyword">int</span> pollingfd <span class="token operator">=</span> <span class="token function">epoll_create</span><span class="token punctuation">(</span> <span class="token number">0xCAFE</span> <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span> pollingfd <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token punctuation">)</span> <span class="token comment">// report error</span><span class="token comment">// Initialize the epoll structure in case more members are added in future</span><span class="token keyword">struct</span> <span class="token class-name">epoll_event</span> ev <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment">// Associate the connection class instance with the event. You can associate anything</span><span class="token comment">// you want, epoll does not use this information. We store a connection class pointer, pConnection1</span>ev<span class="token punctuation">.</span>data<span class="token punctuation">.</span>ptr <span class="token operator">=</span> pConnection1<span class="token punctuation">;</span><span class="token comment">// Monitor for input, and do not automatically rearm the descriptor after the event</span>ev<span class="token punctuation">.</span>events <span class="token operator">=</span> EPOLLIN <span class="token operator">|</span> EPOLLONESHOT<span class="token punctuation">;</span><span class="token comment">// Add the descriptor into the monitoring list. We can do it even if another thread is</span><span class="token comment">// waiting in epoll_wait - the descriptor will be properly added</span><span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token function">epoll_ctl</span><span class="token punctuation">(</span> epollfd<span class="token punctuation">,</span> EPOLL_CTL_ADD<span class="token punctuation">,</span> pConnection1<span class="token operator">-&gt;</span><span class="token function">getSocket</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>ev <span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">)</span>    <span class="token comment">// report error</span><span class="token comment">// Wait for up to 20 events (assuming we have added maybe 200 sockets before that it may happen)</span><span class="token keyword">struct</span> <span class="token class-name">epoll_event</span> pevents<span class="token punctuation">[</span> <span class="token number">20</span> <span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">// Wait for 10 seconds, and retrieve less than 20 epoll_event and store them into epoll_event array</span><span class="token keyword">int</span> ready <span class="token operator">=</span> <span class="token function">epoll_wait</span><span class="token punctuation">(</span> pollingfd<span class="token punctuation">,</span> pevents<span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">,</span> <span class="token number">10000</span> <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// Check if epoll actually succeed</span><span class="token keyword">if</span> <span class="token punctuation">(</span> ret <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token punctuation">)</span>    <span class="token comment">// report error and abort</span><span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span> ret <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">)</span>    <span class="token comment">// timeout; no event detected</span><span class="token keyword">else</span><span class="token punctuation">{</span>    <span class="token comment">// Check if any events detected</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> ready<span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span> pevents<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>events <span class="token operator">&amp;</span> EPOLLIN <span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token comment">// Get back our connection pointer</span>            Connection <span class="token operator">*</span> c <span class="token operator">=</span> <span class="token punctuation">(</span>Connection<span class="token operator">*</span><span class="token punctuation">)</span> pevents<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>data<span class="token punctuation">.</span>ptr<span class="token punctuation">;</span>            c<span class="token operator">-&gt;</span><span class="token function">handleReadEvent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="工作模式"><a href="#工作模式" class="headerlink" title="工作模式"></a>工作模式</h3><p>epoll 的描述符事件有两种触发模式：LT（level trigger）和 ET（edge trigger）。</p><h4 id="1-LT-模式"><a href="#1-LT-模式" class="headerlink" title="1. LT 模式"></a>1. LT 模式</h4><p>当 epoll_wait() 检测到描述符事件到达时，将此事件通知进程，进程可以不立即处理该事件，下次调用 epoll_wait() 会再次通知进程。是默认的一种模式，并且同时支持 Blocking 和 No-Blocking。</p><h4 id="2-ET-模式"><a href="#2-ET-模式" class="headerlink" title="2. ET 模式"></a>2. ET 模式</h4><p>和 LT 模式不同的是，通知之后进程必须立即处理事件，下次再调用 epoll_wait() 时不会再得到事件到达的通知。</p><p>很大程度上减少了 epoll 事件被重复触发的次数，因此效率要比 LT 模式高。只支持 No-Blocking，以避免由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死。</p><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>很容易产生一种错觉认为只要用 epoll 就可以了，select 和 poll 都已经过时了，其实它们都有各自的使用场景。</p><h4 id="1-select-应用场景"><a href="#1-select-应用场景" class="headerlink" title="1. select 应用场景"></a>1. select 应用场景</h4><p>select 的 timeout 参数精度为微秒，而 poll 和 epoll 为毫秒，因此 select 更加适用于实时性要求比较高的场景，比如核反应堆的控制。</p><p>select 可移植性更好，几乎被所有主流平台所支持。</p><h4 id="2-poll-应用场景"><a href="#2-poll-应用场景" class="headerlink" title="2. poll 应用场景"></a>2. poll 应用场景</h4><p>poll 没有最大描述符数量的限制，如果平台支持并且对实时性要求不高，应该使用 poll 而不是 select。</p><h4 id="3-epoll-应用场景"><a href="#3-epoll-应用场景" class="headerlink" title="3. epoll 应用场景"></a>3. epoll 应用场景</h4><p>只需要运行在 Linux 平台上，有大量的描述符需要同时轮询，并且这些连接最好是长连接。</p><p>需要同时监控小于 1000 个描述符，就没有必要使用 epoll，因为这个应用场景下并不能体现 epoll 的优势。</p><p>需要监控的描述符状态变化多，而且都是非常短暂的，也没有必要使用 epoll。因为 epoll 中的所有描述符都存储在内核中，造成每次需要对描述符的状态改变都需要通过 epoll_ctl() 进行系统调用，频繁系统调用降低效率。并且 epoll 的描述符存储在内核，不容易调试。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python+flask</title>
      <link href="2021/04/08/python-flask/"/>
      <url>2021/04/08/python-flask/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Redis基础</title>
      <link href="2021/04/06/redis-ji-chu/"/>
      <url>2021/04/06/redis-ji-chu/</url>
      
        <content type="html"><![CDATA[<h2 id="1-NoSQL-数据模型"><a href="#1-NoSQL-数据模型" class="headerlink" title="1. NoSQL 数据模型"></a>1. NoSQL 数据模型</h2><h3 id="1-1聚合模型"><a href="#1-1聚合模型" class="headerlink" title="1.1聚合模型"></a>1.1聚合模型</h3><ol><li>KV键值</li><li>Bson</li><li>列族 （列的形式扩展）</li><li>图形 （网络结构）</li></ol><h3 id="1-2-四大分类"><a href="#1-2-四大分类" class="headerlink" title="1.2 四大分类"></a>1.2 四大分类</h3><ol><li><p>KV键值</p></li><li><p>文档型数据库（bson格式比较多）</p><ol><li><p>CouchDB</p></li><li><p>MongoDB</p><p>基于分布式文件存储的数据库。由C++语言编写，旨在为WEB应用提供可扩展的高性能数据存储解决方案。MongoDB是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的。</p></li></ol></li><li><p>列存储数据库</p><ol><li>Cassandra,HBase</li><li>分布式文件系统</li></ol></li><li><p>图关系数据库</p><ol><li>Neo4J,InfoGrid</li><li>不是放图形的，放的是关系比如：朋友圈社交网络、广告推荐系统。构建关系图谱。</li></ol></li></ol><h3 id="1-3-CAP-BASE"><a href="#1-3-CAP-BASE" class="headerlink" title="1.3 CAP + BASE"></a>1.3 CAP + BASE</h3><p>C：Consistency（强一致性）</p><p>A：Availability（可用性）</p><p>P：Partition tolerance（分区容错性）</p><p>三选二。在分布式中，P是必须要实现的。</p><p><img src="/2021/04/06/redis-ji-chu/CAP.PNG"></p><p><strong>BASE</strong>：为了解决关系数据库强一致性引起的问题而引起的可用性降低而提出的解决方案。</p><p>基本可用(Basically Available)</p><p>软状态(Soft state)</p><p>最终一致(Eventually consistent)</p><p>它的思想是通过让系统放松对某一时刻数据一致性的要求来换取系统整体伸缩性和性能上改观。缘由就在于大型系统往往由于地域分布和极高性能的要求，不可能采用分布式事务来完成这些指标，要想获得这些指标，base是一种解决方案。</p><h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><h2 id="1-benchmark-性能测试"><a href="#1-benchmark-性能测试" class="headerlink" title="1. benchmark 性能测试"></a>1. benchmark 性能测试</h2><p><img src="/2021/04/06/redis-ji-chu/redis%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E5%8F%82%E6%95%B0.PNG"></p><h2 id="2-基础"><a href="#2-基础" class="headerlink" title="2. 基础"></a>2. 基础</h2><p>Redis默认16个数据库。默认使用第0个数据库。</p><p>Redis是单线程的，Redis是基于内存操作，CPU不是Redis性能瓶颈，Redis的瓶颈是根据机器的内存和网络带宽，既然可以使用单线程，就是用了单线程。</p><p>Redis是c语言写的，官方提供的数据是100000+的QPS，这个不比Memecache差！</p><h3 id="2-1-Redis数据类型"><a href="#2-1-Redis数据类型" class="headerlink" title="2.1 Redis数据类型"></a>2.1 Redis数据类型</h3><h4 id="2-1-1-Redis-Key"><a href="#2-1-1-Redis-Key" class="headerlink" title="2.1.1 Redis-Key"></a>2.1.1 Redis-Key</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">keys * <span class="token comment">#查看所有</span>EXPIRE name <span class="token number">10</span> <span class="token comment">#过期时间</span>ttl name <span class="token comment">#剩余时间</span><span class="token builtin class-name">type</span> name <span class="token comment"># 查看类型</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-1-2-String"><a href="#2-1-2-String" class="headerlink" title="2.1.2 String"></a>2.1.2 String</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">步长<span class="token builtin class-name">set</span> views <span class="token number">1</span> <span class="token comment">#设置</span>get viewsincr views<span class="token comment">#增加</span>decr views <span class="token comment">#减少</span>decrby views <span class="token number">10</span>incrby views <span class="token number">10</span>getrange views <span class="token number">0</span> <span class="token number">3</span> <span class="token comment">#截取views中的1-3位字符</span>getrange views <span class="token number">0</span> -1 <span class="token comment">#获得全部字符</span>setnx views <span class="token comment">#不存在则设置成功</span>setex views <span class="token comment">#设置过期时间 (分布式锁中常用)</span>mset k1 v1 k2 v2 k3 v3 <span class="token comment">#同时设置多个值</span>mget k1 k2 k3 <span class="token comment"># 同时得到</span>msetnx k1 v1 k4 v4<span class="token comment"># 原子操作，要么一起成功，要么一起失败</span><span class="token comment"># 对象</span><span class="token builtin class-name">set</span> user:1<span class="token punctuation">{</span>name:zhangsan,age:3<span class="token punctuation">}</span><span class="token comment">#或这么写 user:{id}:{filed}，如此设计是Redis完全ok的</span>mset user:1:name zhangsan user:1:age <span class="token number">3</span><span class="token comment">###########</span>getset db redis <span class="token comment">#如果存在值，获取原来值，设置新的值，没有的话得到nil，并set db redis</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>String类似的场景：value除了是字符串还可以是数字</p><h4 id="2-1-3-List"><a href="#2-1-3-List" class="headerlink" title="2.1.3 List"></a>2.1.3 List</h4><p>列表。list可以玩成栈、队列、或阻塞队列。</p><p>所有list命令都是l开头的。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">LPUSH list oneLPUSH list twoLPUSH list threeLRANGE list <span class="token number">0</span> -1 <span class="token comment">#全部</span>LRANGE list <span class="token number">0</span> <span class="token number">1</span> <span class="token comment"># three two</span>RPUSH list four <span class="token comment">#右边</span>LPOPRPOP<span class="token comment">############</span>LINDEX list <span class="token number">0</span> <span class="token comment">#左侧第一个值</span>Llen list <span class="token comment">#长度</span>Lrem list <span class="token number">1</span> one <span class="token comment"># 移除 one 1个</span>ltrim list <span class="token number">1</span> <span class="token number">2</span> <span class="token comment"># 通过截取指定的长度</span>rpoplpush list anotherlist <span class="token comment"># 移除list中右侧第一个数据然后放入anotherlist中</span>exists list <span class="token comment">#判断列表是否存在</span><span class="token comment">####</span>lset list <span class="token number">0</span> item <span class="token comment">#将列表中对应下标的值替换</span>linsert list before <span class="token string">"item"</span> <span class="token string">"other"</span> <span class="token comment"># 在item值前面插入other这个值</span>linsert list after <span class="token string">"item"</span> <span class="token string">"new"</span> <span class="token comment"># 在item值后面插入new这个值</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>总结：L</p><ul><li>是一个链表，before Node after left right 都可以插入值</li><li>如果key不存在，创建新链表</li><li>如果存在，新增内容</li><li>如果移除了所有值，空链表，代表不存在</li><li>在两边插入或改动，效率最高，中间元素，相对来说效率低一点。</li></ul><p>消息排队，消息队列 LPUSH RPOP 啥的</p><h4 id="2-1-4-Set"><a href="#2-1-4-Set" class="headerlink" title="2.1.4 Set"></a>2.1.4 Set</h4><p>set开头都是s</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># set 值不能重复</span>sadd myset <span class="token string">"hello"</span>smembers myset <span class="token comment">#查看元素</span>sismember myset hello <span class="token comment">#查看元素是否存在</span><span class="token comment">###</span>srem myset hello <span class="token comment">#移除set集合中的指定元素</span>scard myset <span class="token comment"># 获取set集合中的元素个数</span><span class="token comment">###</span>srandmember myset <span class="token comment"># 无需不重复集合。抽随机</span><span class="token comment">###</span>spop myset <span class="token comment"># 随机删除一个元素</span><span class="token comment">###</span><span class="token comment"># 差集 交集 并集</span>Sdiff set1 set2sinter set1 set2sunion set1 <span class="token builtin class-name">set</span> <span class="token number">2</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-1-5-Hash"><a href="#2-1-5-Hash" class="headerlink" title="2.1.5 Hash()"></a>2.1.5 Hash()</h4><p>Map集合。key-map，值是map集合</p><p>命令以h开头</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hset myhash field1 kuangshenhget myhash field1hmset myhash field1 hello field2 world <span class="token comment">#同时设置值</span>hgetall myhash <span class="token comment"># 得到全部的值</span>hdel myhash field1 <span class="token comment">#删除哈希指定的值字段！对应的value值也就消失了。</span>hlen myhash <span class="token comment">#获取hash长度</span>hexists myhash field1 <span class="token comment"># 判断hash中指定字段是否存在</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>hash保存变更数据 user name age </p><h4 id="2-1-6-Zset（有序集合）"><a href="#2-1-6-Zset（有序集合）" class="headerlink" title="2.1.6 Zset（有序集合）"></a>2.1.6 Zset（有序集合）</h4><p>在set的基础上增加了一个值， set k1 v1 , zset k1 score v1</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#增加</span>zadd myset <span class="token number">1</span> one <span class="token comment"># 中间的是1序号，表示第一个序号，自动排序</span>zrange myset <span class="token number">0</span> -1 <span class="token comment"># 查看范围，这个-1就是看的全部了</span><span class="token comment">#排序如何实现</span>zrangebyscore salary -inf +inf <span class="token comment"># 从最小值到最大值排序</span>zrevrange salary <span class="token number">0</span> -1 <span class="token comment"># 倒叙，从大到小排序</span><span class="token comment"># 获取有序集合的个数</span>zcard myset zcard myset <span class="token number">1</span> hellozcount myset <span class="token number">1</span> <span class="token number">3</span> <span class="token comment"># 获取指定区间的数量</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其余的一些API，剩下的如果工作中有需要这个时候可以去查官方文档。</p><h3 id="2-2-三种特殊的数据类型"><a href="#2-2-三种特殊的数据类型" class="headerlink" title="2.2 三种特殊的数据类型"></a>2.2 三种特殊的数据类型</h3><p>朋友的定位，附近的人，打车距离计算？</p><h4 id="2-2-1-地理空间"><a href="#2-2-1-地理空间" class="headerlink" title="2.2.1 地理空间"></a>2.2.1 地理空间</h4><p>Redis的Geo在Redis 3.2 版本就推出了。这个功能可以推算地理位置的信息，两地之间的距离，方圆几里的人！</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">GEOADD <span class="token comment">#将指定的经度、纬度、名称添加到指定的key中。地球两极无法添加，通过java程序一次性导入 参数 key</span>geoadd china:city <span class="token number">116.40</span> <span class="token number">39.90</span> beijing<span class="token comment">#############</span>GEODIST <span class="token comment"># 给定两个位置之间的距离</span><span class="token comment"># m 单位 米</span><span class="token comment"># km 单位是千米</span><span class="token comment"># mi 单位是英里</span><span class="token comment"># ft 单位是英尺</span>geodist china:city beijing chongqin km <span class="token comment">##############</span>GEOHASH <span class="token comment"># 返回一个或多个位置元素的Geohash表示</span><span class="token comment"># 返回11个字符的Geohash字符串</span>geohash china:city beijing <span class="token comment"># 将当前经纬度转换为一维的字符串，如果两个字符串越接近，那么则距离越近！</span><span class="token comment">#######################</span>GEOPOS <span class="token comment"># 获取当前定位：一定是一个坐标值</span>geopos china:city beijing <span class="token comment"># 获取指定的城市的经度和纬度</span><span class="token comment">#########################</span>GEORADIUS <span class="token comment"># 以给定的经度纬度为中心，半径内的</span>georadius china:city <span class="token number">110</span> <span class="token number">30</span> <span class="token number">1000</span> km <span class="token comment"># 以 110 30 为中心，找方圆1000km内的城市</span>georadius china:city <span class="token number">110</span> <span class="token number">30</span> <span class="token number">1000</span> km <span class="token punctuation">[</span>withcoord<span class="token punctuation">]</span> <span class="token punctuation">[</span>withdist<span class="token punctuation">]</span> <span class="token comment"># withcode打印时带上经度纬度 withdist打印时带上距离</span><span class="token comment">###########################</span>GEORADIUSBYMEMBER <span class="token comment"># 找出位于指定范围内的元素，中心点是由给定的位置元素决定的</span>georadiusbymember china:city shanghai <span class="token number">400</span> km <span class="token comment"># 找出上海附近400km的城市</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-2-2-Hyperloglog"><a href="#2-2-2-Hyperloglog" class="headerlink" title="2.2.2 Hyperloglog"></a>2.2.2 Hyperloglog</h4><p>基数：不重复的元素。比如A = {1,3,5,7,8}，基数（不重复的元素） = 5，可以接受误差。</p><p>Redis 2.8.9版本就更新了 Hyperloglog数据结构。是基数统计的算法。</p><p>网页UV（一个人访问一个网站多次，但是还是算作一个人）。我们的目的是为了计数，而不是保护用户id。</p><ul><li>优点：占用的内存是固定，2^64不同的元素的技术，只需要废12KB内存！如果要从内存的角度来比较的话，hyperloglog是首选！</li><li>0.81%错误率。</li></ul><p>这个命令都以PF开头。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 添加</span>PFadd mykey a b c d e f g h i j<span class="token comment"># 计数</span>PFcount mykey<span class="token comment"># 合并</span>PFmerge mykey3 mykey<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果业务需求不能容错，那么就换成set。</p><h3 id="2-2-3-Bitmaps"><a href="#2-2-3-Bitmaps" class="headerlink" title="2.2.3 Bitmaps"></a>2.2.3 Bitmaps</h3><p>位存储，操作二进制位进行操作，只有0和1两个状态。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">setbit sign <span class="token number">5</span> <span class="token number">0</span>bitcount sign <span class="token comment"># 统计1的个数</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="3-事务"><a href="#3-事务" class="headerlink" title="3. 事务"></a>3. 事务</h2><p>Redis单条命令要么同时成功，要么同时失败，原子性！</p><p><font color="red">但是Redis事务不保证原子性！</font>一个事务所有命令被序列化，在事务执行过程中，会按照顺序执行！</p><p>Redis事务并没有隔离级别的概念！</p><p>Redis事务：</p><ol><li>开启事务（multi)</li><li>命令入队</li><li>执行事务（exec)</li></ol><p>放弃事务：discard</p><p><strong>悲观锁</strong>：</p><p>很悲观，什么时候都要加锁。</p><p><strong>乐观锁</strong>：</p><p>很乐观，什么时候都不想加锁。更新数据时去判断以下，在此期间是否有人修改过这个数据。</p><p>Redis 监视测试：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">watch</span> money <span class="token comment">#可以当作乐观锁操作</span>multidecrby money <span class="token number">10</span>incrby out <span class="token number">10</span><span class="token builtin class-name">exec</span> <span class="token comment">#执行之前另一个线程修改了我们的值，这个时候会导致事务执行失败</span>unwatch 进行解锁<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-Jedis"><a href="#3-Jedis" class="headerlink" title="3. Jedis"></a>3. Jedis</h2><p>需要使用Java来操作Redis。</p><p>Jedis官方推荐的java连接工具，使用java操作Redis。</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencies</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>redis.clients<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>jedis<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>3.5.2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token comment">&lt;!-- https://mvnrepository.com/artifact/com.alibaba/fastjson --&gt;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>com.alibaba<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>fastjson<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>1.2.75<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependencies</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4-SpringBoot-整合"><a href="#4-SpringBoot-整合" class="headerlink" title="4. SpringBoot 整合"></a>4. SpringBoot 整合</h2><p>SpringBoot操作数据:spring-data jpa jdbc mongodb redis！</p><p>SpringData 也是和 SpringBoot齐名的项目。</p><p>在springBoot2.x之后，原来使用的jedis被替换成了lettuce</p><p>jedis:采用直连，多个线程操作不安全。如果避免不安全，需要使用jedis pool连接池！BIO</p><p>lettuce:采用netty，实例可以在多个线程共享，不存在线程不安全的情况，可以减少线程数据，更像NIO模式。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RedisAutoConfiguration</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token class-name">RedisAutoConfiguration</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token annotation punctuation">@ConditionalOnMissingBean</span><span class="token punctuation">(</span>        name <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">"redisTemplate"</span><span class="token punctuation">}</span>    <span class="token punctuation">)</span>    <span class="token annotation punctuation">@ConditionalOnSingleCandidate</span><span class="token punctuation">(</span><span class="token class-name">RedisConnectionFactory</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token class-name">RedisTemplate</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> <span class="token function">redisTemplate</span><span class="token punctuation">(</span><span class="token class-name">RedisConnectionFactory</span> redisConnectionFactory<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">RedisTemplate</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> template <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RedisTemplate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        template<span class="token punctuation">.</span><span class="token function">setConnectionFactory</span><span class="token punctuation">(</span>redisConnectionFactory<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> template<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token annotation punctuation">@ConditionalOnMissingBean</span>    <span class="token annotation punctuation">@ConditionalOnSingleCandidate</span><span class="token punctuation">(</span><span class="token class-name">RedisConnectionFactory</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token class-name">StringRedisTemplate</span> <span class="token function">stringRedisTemplate</span><span class="token punctuation">(</span><span class="token class-name">RedisConnectionFactory</span> redisConnectionFactory<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">StringRedisTemplate</span> template <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringRedisTemplate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        template<span class="token punctuation">.</span><span class="token function">setConnectionFactory</span><span class="token punctuation">(</span>redisConnectionFactory<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> template<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="5-Config"><a href="#5-Config" class="headerlink" title="5. Config"></a>5. Config</h2><ul><li>配置文件对大小写不敏感</li></ul><blockquote><p>网络</p></blockquote><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">bind</span> <span class="token number">127.0</span>.0.1 <span class="token comment">#绑定ip</span>protected-mode <span class="token function">yes</span> <span class="token comment"># 保护模式</span>port <span class="token number">6379</span> <span class="token comment"># 端口设置</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>通用</p></blockquote><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">daemonize <span class="token function">yes</span> <span class="token comment"># 以守护进程的方式运行，默认是no，我们需要自己开启为yes</span>pidfile /var/run/redis_6379.pid <span class="token comment"># 如果以后台方式运行，我们就要指定一个 pid 进程文件</span><span class="token comment"># Specify the server verbosity level.</span><span class="token comment"># This can be one of:</span><span class="token comment"># debug (a lot of information, useful for development/testing)</span><span class="token comment"># verbose (many rarely useful info, but not a mess like the debug level)</span><span class="token comment"># notice (moderately verbose, what you want in production probably) 生产环境适用</span><span class="token comment"># warning (only very important / critical messages are logged)</span>loglevel noticelogfile <span class="token string">""</span> <span class="token comment"># 日志的文件位置名</span>databases <span class="token number">16</span> <span class="token comment"># 数据库的数量，默认16个数据库</span>always-show-logo <span class="token function">yes</span> <span class="token comment">#是否显示logo</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>快照</p></blockquote><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">save <span class="token number">900</span> <span class="token number">1</span> <span class="token comment"># 900s内如何至少有一个key进行了修改，我们就进行持久化操作</span><span class="token comment"># 300s内至少10个key 进行了修改，我们及进行持久化操作</span>save <span class="token number">300</span> <span class="token number">10</span><span class="token comment"># 60s内至少10000个key进行了修改，持久化</span>save <span class="token number">60</span> <span class="token number">10000</span>stop-writes-on-bgsave-error <span class="token function">yes</span> <span class="token comment"># 持久化如果错误了，Redis是否还继续工作</span>rdbcompression <span class="token function">yes</span> <span class="token comment"># 是否压缩 rdb 文件，需要消耗一些cpu资源。</span>rdbchecksum <span class="token function">yes</span> <span class="token comment"># 保存rdb文件的时候，进行错误的检查校验</span><span class="token function">dir</span> ./ <span class="token comment"># rdb 文件保存的目录</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>持久化，在规定的时间内，执行了多少次操作，则会持久化到文件 .rdb .aof</p><p>redis是内存数据库，如果没有持久化，那么数据断电即失。</p><blockquote><p>security</p></blockquote><p>可以修改密码，默认没有设置密码！</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">config get requirepassconfig <span class="token builtin class-name">set</span> requirepass <span class="token string">"123456"</span> <span class="token comment"># 设置redis密码</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>限制clients</p></blockquote><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">maxclients <span class="token number">10000</span> <span class="token comment"># 最大连接数量</span>maxmemory <span class="token operator">&lt;</span>bytes<span class="token operator">&gt;</span> <span class="token comment"># redis 配置最大的内存容量</span>maxmemory-policy noeviction <span class="token comment"># 内存到达上限之后的处理策略，移除一些过期的key</span>maxmemory-policy 六种方式：<span class="token number">1</span>、volatile-lru：只对设置了过期时间的key进行LRU（默认值） <span class="token number">2</span>、allkeys-lru ： 删除lru算法的key   <span class="token number">3</span>、volatile-random：随机删除即将过期key   <span class="token number">4</span>、allkeys-random：随机删除   <span class="token number">5</span>、volatile-ttl ： 删除即将过期的   <span class="token number">6</span>、noeviction ： 永不过期，返回错误<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>APPEND ONLY 模式 aof配置</p></blockquote><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">appendonly no <span class="token comment"># 默认不开启，因为rdb大部分场景够用了，这个还特别慢</span>appendfilename <span class="token string">"appendonly.aof"</span> <span class="token comment"># 持久化的文件的名字 .rdb</span>appendfsync always <span class="token comment"># 每次修改都会sync，消耗性能。</span>appendfsync everysec <span class="token comment"># 每秒执行一次 sync，可能会丢失这1s的数据</span>appendfsync no <span class="token comment"># 不执行 sync，这个时候操作系统自己同步数据，速度最快</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="6-持久化"><a href="#6-持久化" class="headerlink" title="6. 持久化"></a>6. 持久化</h2><p>Redis是内存数据库。</p><h3 id="6-1-rdb"><a href="#6-1-rdb" class="headerlink" title="6.1 rdb"></a>6.1 rdb</h3><h4 id="6-1-1-是什么"><a href="#6-1-1-是什么" class="headerlink" title="6.1.1 是什么"></a>6.1.1 是什么</h4><p>rdb(Redis Database)是Redis持久化的最常用的方式。redis将内存中的数据库快照（以数据结构的形式保存数据）以二进制形式保存到磁盘上。</p><h4 id="6-1-2-为什么"><a href="#6-1-2-为什么" class="headerlink" title="6.1.2 为什么"></a>6.1.2 为什么</h4><p>防止下一次使用数据库时，当前数据库的数据仍然可以使用。</p><h4 id="6-1-3-怎么做"><a href="#6-1-3-怎么做" class="headerlink" title="6.1.3 怎么做"></a>6.1.3 怎么做</h4><p><img src="/2021/04/06/redis-ji-chu/graphviz-cd96bfa5c61ef2b8dd69a9b0a97cde047cb722a8.svg" alt="digraph persistent {      rankdir = LR;      node [shape = circle, style = filled];      edge [style = bold];      redis_object [label = &quot;内存中的\n数据对象&quot;, fillcolor = &quot;#A8E270&quot;];      rdb [label = &quot;磁盘中的\nRDB文件&quot;, fillcolor = &quot;#95BBE3&quot;];      redis_object -> rdb [label = &quot;rdbSave&quot;];      rdb -> redis_object [label = &quot;rdbLoad&quot;]; }"></p><p><img src="/2021/04/06/redis-ji-chu/rdb.PNG"></p><p>在指定的时间间隔内将内存中的数据集快照写入磁盘，也就是Snapshot快照，它恢复时是将快照文件直接读到内存里。</p><p>Redis会单独创建（fork）一个子进程来进行持久化，会先将数据写入到一个临时文件中，待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件。整个过程中，主进程是不进行任何IO操作的。这就确保了极高的性能。如果需要进行大规模数据的回复，且对于数据恢复的完整性不是非常敏感，那么RDB方式要比AOF方式更加高效。RDB的缺点是最后一次持久化后的数据可能丢失。</p><p>rdb保存的文件是dump.rdb的。</p><blockquote><p>触发机制</p></blockquote><ol><li>save的规则满足的情况下，会自动触发rdb规则。</li><li>执行flushall命令，也会触发我们的rdb规则。</li><li>推出redis，产生rdb文件。</li></ol><blockquote><p>恢复rdb文件</p></blockquote><p>只需要将rdb文件放在redis启动目录即可，redis启动的时候就会自动检查dump.rdb恢复其中的数据。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">config get <span class="token function">dir</span> <span class="token comment"># 查看启动目录</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="6-2-AOF-（Append-Only-File"><a href="#6-2-AOF-（Append-Only-File" class="headerlink" title="6.2 AOF （Append Only File)"></a>6.2 AOF （Append Only File)</h3><p>默认不开启，手动进行配置。如果aof有错误，可以使用命令 <code>redis-check-aof --fix</code>即可。（会丢弃错误的数据）</p><p>将我们所有命令都记录，</p><p><img src="/2021/04/06/redis-ji-chu/aof.PNG"></p><p>以日志形式来记录每个写操作，将Redis执行过的所有指令记录下来（读操作不记录），只许追加文件但不可以改写文件，redis启动之初会根据该文件读取重新构建数据，redis重启的话就是根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作。</p><h2 id="7-Redis发布订阅"><a href="#7-Redis发布订阅" class="headerlink" title="7. Redis发布订阅"></a>7. Redis发布订阅</h2><h3 id="7-1-是什么"><a href="#7-1-是什么" class="headerlink" title="7.1 是什么"></a>7.1 是什么</h3><p>发布订阅(pub/sub)是一种消息通信模式：发送者（pub）发送消息，订阅者（sub）接收消息。</p><h3 id="7-2-为什么"><a href="#7-2-为什么" class="headerlink" title="7.2 为什么"></a>7.2 为什么</h3><p>因为我们日常中微信公众号、微博订阅号，需要推送给订阅的客户端信息，这种行为就需要Redis的发布订阅。</p><h3 id="7-3-怎么做"><a href="#7-3-怎么做" class="headerlink" title="7.3 怎么做"></a>7.3 怎么做</h3><p>Redis客户端可以订阅任意数量的频道。</p><p>订阅/发布消息图：</p><p>第一个：消息发送者，第二个：频道 第三个：消息订阅者。</p><p><img src="/2021/04/06/redis-ji-chu/%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85.PNG"></p><p>作为例子， 下图展示了频道 <code>channel1</code> ， 以及订阅这个频道的三个客户端 —— <code>client2</code> 、 <code>client5</code> 和 <code>client1</code> 之间的关系：</p><p><img src="/2021/04/06/redis-ji-chu/graphviz-58f7b1f1f52b28f59291d194555fc9f4b1462a4c.svg"></p><p>当有新消息通过 <a href="http://redis.readthedocs.org/en/latest/pub_sub/publish.html#publish">PUBLISH</a> 命令发送给频道 <code>channel1</code> 时， 这个消息就会被发送给订阅它的三个客户端：</p><p><img src="/2021/04/06/redis-ji-chu/graphviz-84c95abf88d6c0ac55b007da08805a4b9a582fdf.svg"></p><p>在后面的内容中， 我们将探讨 <a href="http://redis.readthedocs.org/en/latest/pub_sub/subscribe.html#subscribe">SUBSCRIBE</a> 和 <a href="http://redis.readthedocs.org/en/latest/pub_sub/publish.html#publish">PUBLISH</a> 命令的实现， 以及这套订阅与发布机制的运作原理。</p><h4 id="7-3-1-订阅机制"><a href="#7-3-1-订阅机制" class="headerlink" title="7.3.1 订阅机制"></a>7.3.1 订阅机制</h4><p>每个 Redis 服务器进程都维持着一个表示服务器状态的 <code>redis.h/redisServer</code> 结构， 结构的 <code>pubsub_channels</code> 属性是一个字典， 这个字典就用于保存订阅频道的信息：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">redisServer</span> <span class="token punctuation">{</span>    <span class="token comment">// ...</span>    dict <span class="token operator">*</span>pubsub_channels<span class="token punctuation">;</span>    <span class="token comment">// ...</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中，字典的键为正在被订阅的频道， 而字典的值则是一个链表， 链表中保存了所有订阅这个频道的客户端。</p><p>比如说，在下图展示的这个 <code>pubsub_channels</code> 示例中， <code>client2</code> 、 <code>client5</code> 和 <code>client1</code> 就订阅了 <code>channel1</code> ， 而其他频道也分别被别的客户端所订阅：</p><p><img src="/2021/04/06/redis-ji-chu/graphviz-241c988b86bb9bed6bf26537e654baaab4eef77b.svg"></p><p>当客户端调用 <a href="http://redis.readthedocs.org/en/latest/pub_sub/subscribe.html#subscribe">SUBSCRIBE</a> 命令时， 程序就将客户端和要订阅的频道在 <code>pubsub_channels</code> 字典中关联起来。</p><p>举个例子，如果客户端 <code>client10086</code> 执行命令 <code>SUBSCRIBE channel1 channel2 channel3</code> ，那么前面展示的 <code>pubsub_channels</code> 将变成下面这个样子：</p><p><img src="/2021/04/06/redis-ji-chu/graphviz-cb250b1be4aaaedc9d5ddde113a80998d7f9c480-1618619828704.svg"></p><p><a href="http://redis.readthedocs.org/en/latest/pub_sub/subscribe.html#subscribe">SUBSCRIBE</a> 命令的行为可以用伪代码表示如下：</p><pre class="line-numbers language-none"><code class="language-none">def SUBSCRIBE(client, channels):    # 遍历所有输入频道    for channel in channels:        # 将客户端添加到链表的末尾        redisServer.pubsub_channels[channel].append(client)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过 <code>pubsub_channels</code> 字典， 程序只要检查某个频道是否为字典的键， 就可以知道该频道是否正在被客户端订阅； 只要取出某个键的值， 就可以得到所有订阅该频道的客户端的信息。</p><h4 id="7-3-2-发送信息到频道"><a href="#7-3-2-发送信息到频道" class="headerlink" title="7.3.2 发送信息到频道"></a>7.3.2 发送信息到频道</h4><p>了解了 <code>pubsub_channels</code> 字典的结构之后， 解释 <a href="http://redis.readthedocs.org/en/latest/pub_sub/publish.html#publish">PUBLISH</a> 命令的实现就非常简单了： 当调用 <code>PUBLISH channel message</code> 命令， 程序首先根据 <code>channel</code> 定位到字典的键， 然后将信息发送给字典值链表中的所有客户端。</p><p>比如说，对于以下这个 <code>pubsub_channels</code> 实例， 如果某个客户端执行命令 <code>PUBLISH channel1 "hello moto"</code> ，那么 <code>client2</code> 、 <code>client5</code> 和 <code>client1</code> 三个客户端都将接收到 <code>"hello moto"</code> 信息：</p><p><img src="/2021/04/06/redis-ji-chu/graphviz-241c988b86bb9bed6bf26537e654baaab4eef77b.svg"></p><p><a href="http://redis.readthedocs.org/en/latest/pub_sub/publish.html#publish">PUBLISH</a> 命令的实现可以用以下伪代码来描述：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">PUBLISH</span><span class="token punctuation">(</span>channel<span class="token punctuation">,</span> message<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment"># 遍历所有订阅频道 channel 的客户端</span>    <span class="token keyword">for</span> client <span class="token keyword">in</span> server<span class="token punctuation">.</span>pubsub_channels<span class="token punctuation">[</span>channel<span class="token punctuation">]</span><span class="token punctuation">:</span>        <span class="token comment"># 将信息发送给它们</span>        send_message<span class="token punctuation">(</span>client<span class="token punctuation">,</span> message<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="7-3-3-退订频道"><a href="#7-3-3-退订频道" class="headerlink" title="7.3.3 退订频道"></a>7.3.3 退订频道</h4><p>使用 <a href="http://redis.readthedocs.org/en/latest/pub_sub/unsubscribe.html#unsubscribe">UNSUBSCRIBE</a> 命令可以退订指定的频道， 这个命令执行的是订阅的反操作： 它从 <code>pubsub_channels</code> 字典的给定频道（键）中， 删除关于当前客户端的信息， 这样被退订频道的信息就不会再发送给这个客户端。</p><h4 id="7-3-4-模式的订阅与信息发送"><a href="#7-3-4-模式的订阅与信息发送" class="headerlink" title="7.3.4 模式的订阅与信息发送"></a>7.3.4 模式的订阅与信息发送</h4><p>当使用 <a href="http://redis.readthedocs.org/en/latest/pub_sub/publish.html#publish">PUBLISH</a> 命令发送信息到某个频道时， 不仅所有订阅该频道的客户端会收到信息， 如果有某个/某些模式和这个频道匹配的话， 那么所有订阅这个/这些频道的客户端也同样会收到信息。</p><p>下图展示了一个带有频道和模式的例子， 其中 <code>tweet.shop.*</code> 模式匹配了 <code>tweet.shop.kindle</code> 频道和 <code>tweet.shop.ipad</code> 频道， 并且有不同的客户端分别订阅它们三个：</p><p><img src="/2021/04/06/redis-ji-chu/graphviz-49c2b60cc3c2b52ec1623fbd8a9002eb6f335a54.svg"></p><p>当有信息发送到 <code>tweet.shop.kindle</code> 频道时， 信息除了发送给 <code>clientX</code> 和 <code>clientY</code> 之外， 还会发送给订阅 <code>tweet.shop.*</code> 模式的 <code>client123</code> 和 <code>client256</code> ：</p><p><img src="/2021/04/06/redis-ji-chu/graphviz-3d1f513ee0718a326d53152b2b97f82977e38ad6.svg"></p><p>另一方面， 如果接收到信息的是频道 <code>tweet.shop.ipad</code> ， 那么 <code>client123</code> 和 <code>client256</code> 同样会收到信息：</p><p><img src="/2021/04/06/redis-ji-chu/graphviz-ba8c4d4dd538464659aeb52d6c366f23ad3d0dc1.svg"></p><h4 id="7-3-5-订阅模式"><a href="#7-3-5-订阅模式" class="headerlink" title="7.3.5 订阅模式"></a>7.3.5 订阅模式</h4><p><code>redisServer.pubsub_patterns</code> 属性是一个链表，链表中保存着所有和模式相关的信息：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">redisServer</span> <span class="token punctuation">{</span>    <span class="token comment">// ...</span>    list <span class="token operator">*</span>pubsub_patterns<span class="token punctuation">;</span>    <span class="token comment">// ...</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>链表中的每个节点都包含一个 <code>redis.h/pubsubPattern</code> 结构：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">pubsubPattern</span> <span class="token punctuation">{</span>    redisClient <span class="token operator">*</span>client<span class="token punctuation">;</span>    robj <span class="token operator">*</span>pattern<span class="token punctuation">;</span><span class="token punctuation">}</span> pubsubPattern<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><code>client</code> 属性保存着订阅模式的客户端，而 <code>pattern</code> 属性则保存着被订阅的模式。</p><p>每当调用 <code>PSUBSCRIBE</code> 命令订阅一个模式时， 程序就创建一个包含客户端信息和被订阅模式的 <code>pubsubPattern</code> 结构， 并将该结构添加到 <code>redisServer.pubsub_patterns</code> 链表中。</p><p>作为例子，下图展示了一个包含两个模式的 <code>pubsub_patterns</code> 链表， 其中 <code>client123</code> 和 <code>client256</code> 都正在订阅 <code>tweet.shop.*</code> 模式：</p><p><img src="/2021/04/06/redis-ji-chu/graphviz-b8d101c1b582531bce2b0daef87adbaf30ebc195.svg"></p><p>如果这时客户端 <code>client10086</code> 执行 <code>PSUBSCRIBE broadcast.list.*</code> ， 那么 <code>pubsub_patterns</code> 链表将被更新成这样：</p><p><img src="/2021/04/06/redis-ji-chu/graphviz-a84f3abf466ca19297faaa4e11d37f9257355c60.svg"></p><p>通过遍历整个 <code>pubsub_patterns</code> 链表，程序可以检查所有正在被订阅的模式，以及订阅这些模式的客户端。</p><h4 id="7-3-6-发送信息到模式"><a href="#7-3-6-发送信息到模式" class="headerlink" title="7.3.6 发送信息到模式"></a>7.3.6 发送信息到模式</h4><p>发送信息到模式的工作也是由 <a href="http://redis.readthedocs.org/en/latest/pub_sub/publish.html#publish">PUBLISH</a> 命令进行的， 在前面讲解频道的时候， 我们给出了这样一段伪代码， 说它定义了 <a href="http://redis.readthedocs.org/en/latest/pub_sub/publish.html#publish">PUBLISH</a> 命令的行为：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">PUBLISH</span><span class="token punctuation">(</span>channel<span class="token punctuation">,</span> message<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment"># 遍历所有订阅频道 channel 的客户端</span>    <span class="token keyword">for</span> client <span class="token keyword">in</span> server<span class="token punctuation">.</span>pubsub_channels<span class="token punctuation">[</span>channel<span class="token punctuation">]</span><span class="token punctuation">:</span>        <span class="token comment"># 将信息发送给它们</span>        send_message<span class="token punctuation">(</span>client<span class="token punctuation">,</span> message<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>但是，这段伪代码并没有完整描述 <a href="http://redis.readthedocs.org/en/latest/pub_sub/publish.html#publish">PUBLISH</a> 命令的行为， 因为 <a href="http://redis.readthedocs.org/en/latest/pub_sub/publish.html#publish">PUBLISH</a> 除了将 <code>message</code> 发送到所有订阅 <code>channel</code> 的客户端之外， 它还会将 <code>channel</code> 和 <code>pubsub_patterns</code> 中的模式进行对比， 如果 <code>channel</code> 和某个模式匹配的话， 那么也将 <code>message</code> 发送到订阅那个模式的客户端。</p><p>完整描述 <a href="http://redis.readthedocs.org/en/latest/pub_sub/publish.html#publish">PUBLISH</a> 功能的伪代码定于如下：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">PUBLISH</span><span class="token punctuation">(</span>channel<span class="token punctuation">,</span> message<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment"># 遍历所有订阅频道 channel 的客户端</span>    <span class="token keyword">for</span> client <span class="token keyword">in</span> server<span class="token punctuation">.</span>pubsub_channels<span class="token punctuation">[</span>channel<span class="token punctuation">]</span><span class="token punctuation">:</span>        <span class="token comment"># 将信息发送给它们</span>        send_message<span class="token punctuation">(</span>client<span class="token punctuation">,</span> message<span class="token punctuation">)</span>    <span class="token comment"># 取出所有模式，以及订阅模式的客户端</span>    <span class="token keyword">for</span> pattern<span class="token punctuation">,</span> client <span class="token keyword">in</span> server<span class="token punctuation">.</span>pubsub_patterns<span class="token punctuation">:</span>        <span class="token comment"># 如果 channel 和模式匹配</span>        <span class="token keyword">if</span> match<span class="token punctuation">(</span>channel<span class="token punctuation">,</span> pattern<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token comment"># 那么也将信息发给订阅这个模式的客户端</span>            send_message<span class="token punctuation">(</span>client<span class="token punctuation">,</span> message<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>举个例子，如果 Redis 服务器的 <code>pubsub_patterns</code> 状态如下：</p><p><img src="/2021/04/06/redis-ji-chu/graphviz-a84f3abf466ca19297faaa4e11d37f9257355c60.svg"></p><p>那么当某个客户端发送信息 <code>"Amazon Kindle, $69."</code> 到 <code>tweet.shop.kindle</code> 频道时， 除了所有订阅了 <code>tweet.shop.kindle</code> 频道的客户端会收到信息之外， 客户端 <code>client123</code> 和 <code>client256</code> 也同样会收到信息， 因为这两个客户端订阅的 <code>tweet.shop.*</code> 模式和 <code>tweet.shop.kindle</code> 频道匹配。</p><h4 id="7-3-7-退订模式"><a href="#7-3-7-退订模式" class="headerlink" title="7.3.7 退订模式"></a>7.3.7 退订模式</h4><p>使用 <a href="http://redis.readthedocs.org/en/latest/pub_sub/punsubscribe.html#punsubscribe">PUNSUBSCRIBE</a> 命令可以退订指定的模式， 这个命令执行的是订阅模式的反操作： 程序会删除 <code>redisServer.pubsub_patterns</code> 链表中， 所有和被退订模式相关联的 <code>pubsubPattern</code> 结构， 这样客户端就不会再收到和模式相匹配的频道发来的信息。</p><h2 id="8-主从复制"><a href="#8-主从复制" class="headerlink" title="8. 主从复制"></a>8. 主从复制</h2><h3 id="8-1-是什么"><a href="#8-1-是什么" class="headerlink" title="8.1 是什么"></a>8.1 是什么</h3><p>主从复制，指的是将一台Redis服务器的数据，复制到其他的Redis服务器。前者称为主节点（master/leader），后者称为从节点（slave/follower）；数据的复制都是单向的，只能由主节点到从节点。Master以写为主，Slave以读为主。</p><h3 id="8-2-为什么"><a href="#8-2-为什么" class="headerlink" title="8.2 为什么"></a>8.2 为什么</h3><ol><li>数据冗余：主从复制实现了数据的热备份，是持久化之外的一种数据冗余方式。</li><li>故障恢复：当主节点出现了问题，可以由从节点提供服务，实现快速的故障恢复；实际上是一种服务的冗余。</li><li>负载均衡：主从复制的基础上，配合读写分离，可以由主节点提供写服务，从节点提供读服务（即写Redis数据时应用连接主节点，读Redis数据时应用连接从节点），分担服务器负载；尤其是在写少读多的场景下，通过多个从节点分担负载，可以大大提高Redis服务器的并发量。</li><li>高可用基石：除了上述作用以外，主从复制还是哨兵和集群能够实施的基础，因此主从复制是Redis高可用的基础。</li></ol><h3 id="8-3-怎么做"><a href="#8-3-怎么做" class="headerlink" title="8.3 怎么做"></a>8.3 怎么做</h3><p>Slave启动成功成功连接到master会发送一个sync同步命令。</p><p>Master收到同步命令，启动后台存盘进程，同时收集所有接收到的用于修改数据集命令，在后台进程执行完毕之后，master将传送整个数据文件到slave，并完成一次完全同步。</p><p>全量复制：slave服务在接收到master数据库文件数据，将其存盘并加载到内存中。</p><p>增量复制：Master继续将新的所有收集到的修改命令依次传给slave，完成同步。</p><h2 id="9-哨兵模式"><a href="#9-哨兵模式" class="headerlink" title="9. 哨兵模式"></a>9. 哨兵模式</h2><h3 id="9-1-是什么"><a href="#9-1-是什么" class="headerlink" title="9.1 是什么"></a>9.1 是什么</h3><p>自动选择Master。能够让后台监控主机是否故障，如果故障了根据投票数自动将从库转换为主库。</p><h3 id="9-2-为什么"><a href="#9-2-为什么" class="headerlink" title="9.2 为什么"></a>9.2 为什么</h3><p>主从切换技术，当主服务器宕机后，需要手动把一台服务器切换为主服务器，这就需要人工干预，费时费力，还会造成一段时间内服务不可用。这不是一种推荐的方式，更多时候，优先考虑哨兵模式。Redis2.8正式提供了Sentinel（哨兵）架构来解决这个问题。</p><h3 id="9-3-怎么做"><a href="#9-3-怎么做" class="headerlink" title="9.3 怎么做"></a>9.3 怎么做</h3><p><img src="/2021/04/06/redis-ji-chu/%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F.PNG"></p><p>假设主服务器宕机，哨兵1先检测到这个结果，系统并不会马上进行failover过程，仅仅是哨兵1主观的认为主服务器不可用，这个现象称为主观下线。</p><p>当后面的哨兵也检测到主服务器不可用，并且数量达到一定值时，那么哨兵之间就会进行一次投票，投票的结果由一个哨兵发起，进行failover（故障转移）操作。切换成功后，就会发布订阅模式，让各个哨兵把自己监控的从服务器实现切换主机，这个过程称为客观下线。</p><h2 id="10-Redis-缓存穿透和雪崩"><a href="#10-Redis-缓存穿透和雪崩" class="headerlink" title="10. Redis 缓存穿透和雪崩"></a>10. Redis 缓存穿透和雪崩</h2><p>都是高可用问题。</p><h3 id="10-1-缓存穿透"><a href="#10-1-缓存穿透" class="headerlink" title="10.1 缓存穿透"></a>10.1 缓存穿透</h3><h4 id="10-1-1-是什么"><a href="#10-1-1-是什么" class="headerlink" title="10.1.1 是什么"></a>10.1.1 是什么</h4><p>用户想要查询的数据缓存（redis内存数据库）没有，于是向持久层数据库查询。很多用户出现时，都向持久层数据库去查询，给持久层数据库造成很大压力，这就是缓存穿透。</p><h4 id="10-1-2-为什么"><a href="#10-1-2-为什么" class="headerlink" title="10.1.2 为什么"></a>10.1.2 为什么</h4><p>因为不得不要解决这个问题。</p><h4 id="10-1-3-怎么做"><a href="#10-1-3-怎么做" class="headerlink" title="10.1.3 怎么做"></a>10.1.3 怎么做</h4><p>怎么防止：</p><ul><li>方案一：布隆过滤器</li></ul><p>布隆过滤器是一种数据结构，对所有可能查询的参数以hash形式存储，在控制层先进行校验，不符合则丢弃，从而笔迷拿了对底层存储系统的查询压力。</p><ul><li>方案二：缓存空对象</li></ul><p><img src="/2021/04/06/redis-ji-chu/%E7%BC%93%E5%AD%98%E7%A9%BA%E5%AF%B9%E8%B1%A1.PNG"></p><p>这种方法有两个问题：</p><ol><li>空值能够被缓存，意味着缓存需要更多的空间存储更多的键，因为这当中可能会有很多的空值键。</li><li>即使对空值设置过期时间，还是会存在缓存层和存储层数据会有一段时间不一致，这对于保持一致性的业务会有影响。</li></ol><h3 id="10-2-缓存击穿"><a href="#10-2-缓存击穿" class="headerlink" title="10.2 缓存击穿"></a>10.2 缓存击穿</h3><h4 id="10-2-1-是什么"><a href="#10-2-1-是什么" class="headerlink" title="10.2.1 是什么"></a>10.2.1 是什么</h4><p>一个key非常热点，key对应的数据存在，但在redis中正好过期。在过期的时间段内若有大量并发请求过来，这些请求发现缓存过期一般都会从后端DB加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端DB压垮。</p><h4 id="10-2-2-为什么"><a href="#10-2-2-为什么" class="headerlink" title="10.2.2 为什么"></a>10.2.2 为什么</h4><h4 id="10-2-3-怎么做"><a href="#10-2-3-怎么做" class="headerlink" title="10.2.3 怎么做"></a>10.2.3 怎么做</h4><ul><li>方案一：SETNX 使用互斥锁。只有不存在的时候才设置，可以利用它来实现锁的效果。</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token class-name">String</span> value <span class="token operator">=</span> redis<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>value <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">//代表缓存值过期</span>          <span class="token comment">//设置3min的超时，防止del操作失败的时候，下次缓存过期一直不能load db</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>redis<span class="token punctuation">.</span><span class="token function">setnx</span><span class="token punctuation">(</span>key_mutex<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span> <span class="token operator">*</span> <span class="token number">60</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment">//代表设置成功</span>               value <span class="token operator">=</span> db<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>                      redis<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> expire_secs<span class="token punctuation">)</span><span class="token punctuation">;</span>                      redis<span class="token punctuation">.</span><span class="token function">del</span><span class="token punctuation">(</span>key_mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>  <span class="token comment">//这个时候代表同时候的其他线程已经load db并回设到缓存了，这时候重试获取缓存值即可</span>                      <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                      <span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//重试</span>              <span class="token punctuation">}</span>          <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>              <span class="token keyword">return</span> value<span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>方案二：设置数据永不过期。（内存需要很大）</li></ul><h3 id="10-3-雪崩"><a href="#10-3-雪崩" class="headerlink" title="10.3 雪崩"></a>10.3 雪崩</h3><h4 id="10-3-1-是什么"><a href="#10-3-1-是什么" class="headerlink" title="10.3.1 是什么"></a>10.3.1 是什么</h4><p>当缓存服务器重启或者大量缓存集中在某一个时间段失效，这样在失效的时候，也会给后端系统(比如DB)带来很大压力。</p><h4 id="10-3-2-为什么"><a href="#10-3-2-为什么" class="headerlink" title="10.3.2 为什么"></a>10.3.2 为什么</h4><h4 id="10-3-3-怎么做"><a href="#10-3-3-怎么做" class="headerlink" title="10.3.3 怎么做"></a>10.3.3 怎么做</h4><ul><li>方案一：redis高可用</li></ul><p>既然redis有可能挂掉，那我多几台redis，这样一台挂掉后其他还可以继续工作，其实就是搭建的集群。</p><ul><li>方案二：限流降级</li></ul><p>缓存失效后，通过加锁或者队列来控制数据库写缓存的线程数量。比如对某个key只允许一个线程查询数据和写缓存，其他线程等待。</p><ul><li>方案三：数据预热</li></ul><p>在正式部署之前，把所有可能加载到的数据预先访问一遍，这样部分可能大量访问的数据就会加载到缓存中。即将发生大并发访问前手动触发加载缓存不同的key，设置不同的过期时间，让缓存的时间点尽量均匀。</p><h2 id="11-数据不一致问题"><a href="#11-数据不一致问题" class="headerlink" title="11. 数据不一致问题"></a>11. 数据不一致问题</h2><p>Redis和MySQL的数据不一致产生的根源是业务需要进行更新(写入)操作。</p><p>先操作Redis 还是 先操作MySQL是个问题，操作时序不同产生的影响也不同。</p><p>尺有所短，寸有所长，说到底是一种权衡，哪一种组合产生的负面影响对业务最小，就倾向于哪种方案。</p><p>缓存系统的数据不一致问题，是个经典的问题，因此肯定有很多解决问题的套路，所以让我们带着分析和思考去看看，各个方案的利弊。</p><p><strong>思路一：设置缓存过期时间</strong></p><p>当向Redis写入一条数据时，同时设置过期时间x秒，业务不同过期时间不同。</p><p>过期时间到达时Redis就会删掉这条数据，后续读请求Redis出现Cache Miss，进而读取MySQL，然后把数据写到Redis。</p><p>如果发生更新操作时，只操作MySQL，那么Redis中的数据更新就只是依赖于过期时间来保底，淘汰后再被加载就是新数据了。</p><p>画外音：这种方案是最简单的，如果业务对短时间不一致问题并不在意，设置过期时间的方案就足够了，没有必要搞太复杂。</p><p><strong>思路二：先淘汰缓存&amp;再更新主存</strong></p><p>进行更新操作时，为了防止其他线程读到缓存中的旧数据，干脆淘汰掉，然后把数据更新到主存储，后续的请求再次读取时触发Cache Miss，从而读取MySQL再将新数据更新到Redis。</p><p><a href="https://s5.51cto.com/oss/202104/18/32ced2ae2665c3a2482d7eaa2d880cfa.png"><img src="/2021/04/06/redis-ji-chu/32ced2ae2665c3a2482d7eaa2d880cfa.png" alt="img"></a></p><ul><li>在T1时刻：Redis和MySQL对于age的值都是18，二者一致;</li><li>在T2时刻：有更新请求需要设置age=20，此时Redis中就没有age这个数据了;在完成Redis淘汰后，进行MySQL数据更新age=20;</li></ul><p>这个方案听着还不错的样子，但是读写请求都是并发的，先后顺序完全无法预测，甚至后发出的请求先处理完成，也是很常见的。</p><p>可见一个明显的漏洞：在淘汰Redis的数据完成后，更新MySQL完成之前，这个时间段内如果有新的读请求过来，发现Cache Miss了，就会把旧数据重新写到Redis中，再次造成不一致，并且毫无察觉后续读的都是旧数据。</p><p><a href="https://s3.51cto.com/oss/202104/18/222bab6d0ea863ad4e2e97c39c4ed5e4.png"><img src="/2021/04/06/redis-ji-chu/222bab6d0ea863ad4e2e97c39c4ed5e4.png" alt="img"></a></p><p>画外音：这个方案其实不能说完全没有用，但是至少不完美吧。</p><h3 id="思路三：先更新主存-amp-再淘汰缓存"><a href="#思路三：先更新主存-amp-再淘汰缓存" class="headerlink" title="思路三：先更新主存&amp;再淘汰缓存"></a>思路三：先更新主存&amp;再淘汰缓存</h3><p>进行更新操作时，先更新MySQL，成功之后，淘汰缓存，后续读取请求时触发Cache Miss再将新数据回写Redis。</p><p><a href="https://s5.51cto.com/oss/202104/18/7b22bb7a62cff14508fd7009905828d7.png"><img src="/2021/04/06/redis-ji-chu/7b22bb7a62cff14508fd7009905828d7.png" alt="img"></a></p><p>这种模式在更新MySQL和淘汰Redis这段时间内，请求读取的还是Redis的旧数据，不过等MySQL更新完成，就可以立刻恢复一致，影响相对比较小。</p><p><a href="https://s4.51cto.com/oss/202104/18/4d460d288713e562d017f8f2cdb2cb8b.png"><img src="/2021/04/06/redis-ji-chu/4d460d288713e562d017f8f2cdb2cb8b.png" alt="img"></a></p><p>上述是在缓存中有数据的情况，也就是T2时刻的读请求没有触发Cache Miss，也就不会更新缓存，因此问题不大。</p><p>但是，假如T2时刻读取的数据在缓存没有，那么触发Cache Miss后会产生回写，假如这个回写动作是在T4时刻完成，那么写入的还是老数据，如图：</p><p><a href="https://s4.51cto.com/oss/202104/18/5985e39605da8ddbe03ebfe3dffd8946.png-wh_600x-s_290050075.png"><img src="/2021/04/06/redis-ji-chu/5985e39605da8ddbe03ebfe3dffd8946.png-wh_600x-s_290050075.png" alt="img"></a></p><p>这种情况确实有问题，但是真是太巧了吧，分析一下：</p><ul><li>事件A：淘汰Redis前来了一个读请求;</li><li>事件B：T2时刻的读请求触发了Cache Miss;</li><li>事件C：回写Redis发生在淘汰缓存之后;</li></ul><p>那么发生问题的概率就是P(A)*P(B)*P(C)，从实际考虑这种综合事件发生的概率非常低，因为写操作远慢于读操作，也就是图上的T4事件大概率是发生在T3事件之前的。</p><p>画外音：先更新MySQL再淘汰Redis的方案，虽然存在小概率不一致问题，但是总体来说工程上是可用的，比如非要说写完MySQL挂了，Redis就没淘汰，这种情况只能说确实有问题。</p><h3 id="思路四：延时双删-淘汰"><a href="#思路四：延时双删-淘汰" class="headerlink" title="思路四：延时双删(淘汰)"></a>思路四：延时双删(淘汰)</h3><p>前面提到的思路二和思路三都只有一次Redis淘汰操作，这里要说的延时双删本质上是思路二和思路三的结合：</p><p><a href="https://s2.51cto.com/oss/202104/18/debdfb9c6c6e7d93e0959d240ce75d54.png-wh_600x-s_3948280338.png"><img src="/2021/04/06/redis-ji-chu/debdfb9c6c6e7d93e0959d240ce75d54.png-wh_600x-s_3948280338.png" alt="img"></a></p><p>说实话个人觉得，这个方案有点堆操作的感觉，而且设置延时的目的是为了避免思路三的小概率问题，延时设置多久不好确定，二来延时降低了并发性能，同时前置的删除缓存操作起到的作用并不大。</p><p>这个方案倒是透露出一种思想：多删几次，可能一致性更有保证，那确实如此，但是命中率也就低了，命中率和一致性看来也是一对矛盾。</p><p>画外音：这个方案也不是说不行，其实有点麻烦，并且在复杂高并发场景中反而影响性能，要是一般的场景或许也能用起来。</p><h3 id="思路五：异步更新缓存"><a href="#思路五：异步更新缓存" class="headerlink" title="思路五：异步更新缓存"></a>思路五：异步更新缓存</h3><p>既然直接操作MySQL和Redis都多少存在一些问题，那么能不能引入中间层来解决问题呢?</p><p>把MySQL的更新操作完成后不直接操作Redis，而是把这个操作命令(消息)扔到一个中间层，然后由Redis自己来消费更新数据，这是一种解耦的异步方案。</p><p><a href="https://s5.51cto.com/oss/202104/18/a098eb9f48abb2d5e3be936259d1ee56.png-wh_600x-s_2588560741.png"><img src="/2021/04/06/redis-ji-chu/a098eb9f48abb2d5e3be936259d1ee56.png-wh_600x-s_2588560741.png" alt="img"></a></p><p>单纯为了更新缓存引入中间件确实有些复杂，但是像MySQL提供了binlog的同步机制，此时Redis就作为Slave进行主从同步，实现数据的更新，成本也还可以接受。</p><h3 id="12-面试题（1）"><a href="#12-面试题（1）" class="headerlink" title="12. 面试题（1）"></a>12. 面试题（1）</h3><h4 id="12-1-Redis与Memcached"><a href="#12-1-Redis与Memcached" class="headerlink" title="12.1 Redis与Memcached"></a>12.1 Redis与Memcached</h4>]]></content>
      
      
      <categories>
          
          <category> database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> database </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java中hashMap原理</title>
      <link href="2021/04/01/java-zhong-hash-yuan-li/"/>
      <url>2021/04/01/java-zhong-hash-yuan-li/</url>
      
        <content type="html"><![CDATA[<h3 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h3><p><strong>Hash，一般翻译做“散列”，也有直接音译为“哈希”的，就是把任意长度的输入，通过散列算法，变换成固定长度的输出，该输出就是散列值。</strong>这种转换是一种压缩映射，也就是，散列值的空间通常远小于输入的空间，不同的输入可能会散列成相同的输出，所以不可能从散列值来唯一的确定输入值。简单的说就是一种将任意长度的消息压缩到某一固定长度的消息摘要的函数。</p><p>所有散列函数都有如下一个基本特性：<strong>根据同一散列函数计算出的散列值如果不同，那么输入值肯定也不同。但是，根据同一散列函数计算出的散列值如果相同，输入值不一定相同。</strong></p><p><strong>两个不同的输入值，根据同一散列函数计算出的散列值相同的现象叫做碰撞。</strong></p><p>常见的Hash函数有以下几个：</p><blockquote><p>直接定址法：直接以关键字k或者k加上某个常数（k+c）作为哈希地址。</p><p>数字分析法：提取关键字中取值比较均匀的数字作为哈希地址。</p><p>除留余数法：用关键字k除以某个不大于哈希表长度m的数p，将所得余数作为哈希表地址。</p><p>分段叠加法：按照哈希表地址位数将关键字分成位数相等的几部分，其中最后一部分可以比较短。然后将这几部分相加，舍弃最高进位后的结果就是该关键字的哈希地址。</p><p>平方取中法：如果关键字各个部分分布都不均匀的话，可以先求出它的平方值，然后按照需求取中间的几位作为哈希地址。</p><p>伪随机数法：采用一个伪随机数当作哈希函数。</p></blockquote><p>上面介绍过碰撞。衡量一个哈希函数的好坏的重要指标就是发生碰撞的概率以及发生碰撞的解决方案。任何哈希函数基本都无法彻底避免碰撞，常见的解决碰撞的方法有以下几种：</p><ul><li>开放定址法：<ul><li>开放定址法就是一旦发生了冲突，就去寻找下一个空的散列地址，只要散列表足够大，空的散列地址总能找到，并将记录存入。</li></ul></li><li>链地址法<ul><li>将哈希表的每个单元作为链表的头结点，所有哈希地址为i的元素构成一个同义词链表。即发生冲突时就把该关键字链在以该单元为头结点的链表的尾部。</li></ul></li><li>再哈希法<ul><li>当哈希地址发生冲突用其他的函数计算另一个哈希函数地址，直到冲突不再产生为止。</li></ul></li><li>建立公共溢出区<ul><li>将哈希表分为基本表和溢出表两部分，发生冲突的元素都放入溢出表中。</li></ul></li></ul><h2 id="1-HashMap-的数据结构"><a href="#1-HashMap-的数据结构" class="headerlink" title="1. HashMap 的数据结构"></a>1. HashMap 的数据结构</h2><p>在Java中，保存数据有两种比较简单的数据结构：数组和链表。<strong>数组的特点是：寻址容易，插入和删除困难；而链表的特点是：寻址困难，插入和删除容易。</strong>上面我们提到过，常用的哈希函数的冲突解决办法中有一种方法叫做链地址法，其实就是将数组和链表组合在一起，发挥了两者的优势，我们可以将其理解为链表的数组。</p><p><a href="http://www.hollischuang.com/wp-content/uploads/2018/03/640.png"><img src="/2021/04/01/java-zhong-hash-yuan-li/640.png" alt="640"></a></p><p>我们可以从上图看到，左边很明显是个数组，数组的每个成员是一个链表。该数据结构所容纳的所有元素均包含一个指针，用于元素间的链接。我们根据元素的自身特征把元素分配到不同的链表中去，反过来我们也正是通过这些特征找到正确的链表，再从链表中找出正确的元素。其中，根据元素特征计算元素数组下标的方法就是哈希算法，即本文的主角hash()函数（当然，还包括indexOf()函数）。</p><h3 id="1-自动扩容"><a href="#1-自动扩容" class="headerlink" title="1. 自动扩容"></a>1. 自动扩容</h3><blockquote><p>最小可用原则，容量超过一定阈值便自动进行扩容。</p></blockquote><p>扩容是通过<code>resize()</code>方法实现的。扩容放生在putVal方法的最后，即写入元素之后才会判断是否需要扩容，当自增后数组的size大于之前所计算好的<code>threshold</code>，即执行<code>resize</code>操作。</p><p><img src="/2021/04/01/java-zhong-hash-yuan-li/hashmap1.PNG"></p><p>扩容(resize)就是重新计算容量，向HashMap对象里不停的添加元素，而HashMap对象内部的数组无法装载更多的元素时，对象就需要扩大数组的长度，以便能装入更多的元素。当然Java里的数组是无法自动扩容的，方法是使用一个新的数组代替已有的容量小的数组，就像我们用一个小桶装水，如果想装更多的水，就得换大水桶。</p><p>我们分析下resize的源码，鉴于JDK1.8融入了红黑树，较复杂，为了便于理解使用JDK1.7的代码，好理解一些，本质上区别不大，具体区别后文再说。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"> <span class="token number">1</span> <span class="token keyword">void</span> <span class="token function">resize</span><span class="token punctuation">(</span><span class="token keyword">int</span> newCapacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token comment">//传入新的容量</span> <span class="token number">2</span>     <span class="token class-name">Entry</span><span class="token punctuation">[</span><span class="token punctuation">]</span> oldTable <span class="token operator">=</span> table<span class="token punctuation">;</span>    <span class="token comment">//引用扩容前的Entry数组</span> <span class="token number">3</span>     <span class="token keyword">int</span> oldCapacity <span class="token operator">=</span> oldTable<span class="token punctuation">.</span>length<span class="token punctuation">;</span>          <span class="token number">4</span>     <span class="token keyword">if</span> <span class="token punctuation">(</span>oldCapacity <span class="token operator">==</span> MAXIMUM_CAPACITY<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment">//扩容前的数组大小如果已经达到最大(2^30)了</span> <span class="token number">5</span>         threshold <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">;</span> <span class="token comment">//修改阈值为int的最大值(2^31-1)，这样以后就不会扩容了</span> <span class="token number">6</span>         <span class="token keyword">return</span><span class="token punctuation">;</span> <span class="token number">7</span>     <span class="token punctuation">}</span> <span class="token number">8</span>   <span class="token number">9</span>     <span class="token class-name">Entry</span><span class="token punctuation">[</span><span class="token punctuation">]</span> newTable <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Entry</span><span class="token punctuation">[</span>newCapacity<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">//初始化一个新的Entry数组</span><span class="token number">10</span>     <span class="token function">transfer</span><span class="token punctuation">(</span>newTable<span class="token punctuation">)</span><span class="token punctuation">;</span>                         <span class="token comment">//！！将数据转移到新的Entry数组里</span><span class="token number">11</span>     table <span class="token operator">=</span> newTable<span class="token punctuation">;</span>                           <span class="token comment">//HashMap的table属性引用新的Entry数组</span><span class="token number">12</span>     threshold <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">(</span>newCapacity <span class="token operator">*</span> loadFactor<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//修改阈值</span><span class="token number">13</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里就是使用一个容量更大的数组来代替已有的容量小的数组，transfer()方法将原有Entry数组的元素拷贝到新的Entry数组里。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"> <span class="token number">1</span> <span class="token keyword">void</span> <span class="token function">transfer</span><span class="token punctuation">(</span><span class="token class-name">Entry</span><span class="token punctuation">[</span><span class="token punctuation">]</span> newTable<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token number">2</span>     <span class="token class-name">Entry</span><span class="token punctuation">[</span><span class="token punctuation">]</span> src <span class="token operator">=</span> table<span class="token punctuation">;</span>                   <span class="token comment">//src引用了旧的Entry数组</span> <span class="token number">3</span>     <span class="token keyword">int</span> newCapacity <span class="token operator">=</span> newTable<span class="token punctuation">.</span>length<span class="token punctuation">;</span> <span class="token number">4</span>     <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> src<span class="token punctuation">.</span>length<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">//遍历旧的Entry数组</span> <span class="token number">5</span>         <span class="token class-name">Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> e <span class="token operator">=</span> src<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>             <span class="token comment">//取得旧Entry数组的每个元素</span> <span class="token number">6</span>         <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token number">7</span>             src<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span class="token comment">//释放旧Entry数组的对象引用（for循环后，旧的Entry数组不再引用任何对象）</span> <span class="token number">8</span>             <span class="token keyword">do</span> <span class="token punctuation">{</span> <span class="token number">9</span>                 <span class="token class-name">Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> next <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">;</span><span class="token number">10</span>                 <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token function">indexFor</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash<span class="token punctuation">,</span> newCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//！！重新计算每个元素在数组中的位置</span><span class="token number">11</span>                 e<span class="token punctuation">.</span>next <span class="token operator">=</span> newTable<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//标记[1]</span><span class="token number">12</span>                 newTable<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>      <span class="token comment">//将元素放在数组上</span><span class="token number">13</span>                 e <span class="token operator">=</span> next<span class="token punctuation">;</span>             <span class="token comment">//访问下一个Entry链上的元素</span><span class="token number">14</span>             <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>e <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token number">15</span>         <span class="token punctuation">}</span><span class="token number">16</span>     <span class="token punctuation">}</span><span class="token number">17</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>newTable[i]的引用赋给了e.next，也就是使用了单链表的头插入方式，同一位置上新元素总会被放在链表的头部位置；这样先放在一个索引上的元素终会被放到Entry链的尾部(如果发生了hash冲突的话），这一点和Jdk1.8有区别，下文详解。在旧数组中同一条Entry链上的元素，通过重新计算索引位置后，有可能被放到了新数组的不同位置上。</p><p>下面举个例子说明下扩容过程。假设了我们的hash算法就是简单的用key mod 一下表的大小（也就是数组的长度）。其中的哈希桶数组table的size=2， 所以key = 3、7、5，put顺序依次为 5、7、3。在mod 2以后都冲突在table[1]这里了。这里假设负载因子 loadFactor=1，即当键值对的实际大小size 大于 table的实际大小时进行扩容。接下来的三个步骤是哈希桶数组 resize成4，然后所有的Node重新rehash的过程。</p><p><img src="/2021/04/01/java-zhong-hash-yuan-li/e5aa99e811d1814e010afa7779b759d4_b-1617780223521.png" alt="img"></p><p>下面我们讲解下JDK1.8做了哪些优化。经过观测可以发现，我们使用的是2次幂的扩展(指长度扩为原来2倍)，所以，元素的位置要么是在原位置，要么是在原位置再移动2次幂的位置。看下图可以明白这句话的意思，n为table的长度，图（a）表示扩容前的key1和key2两种key确定索引位置的示例，图（b）表示扩容后key1和key2两种key确定索引位置的示例，其中hash1是key1对应的哈希与高位运算结果。</p><p><img src="/2021/04/01/java-zhong-hash-yuan-li/a285d9b2da279a18b052fe5eed69afe9_b.png" alt="img"></p><p>元素在重新计算hash之后，因为n变为2倍，那么n-1的mask范围在高位多1bit(红色)，因此新的index就会发生这样的变化：</p><p><img src="/2021/04/01/java-zhong-hash-yuan-li/b2cb057773e3d67976c535d6ef547d51_b.png" alt="img"></p><p>因此，我们在扩充HashMap的时候，不需要像JDK1.7的实现那样重新计算hash，只需要看看原来的hash值新增的那个bit是1还是0就好了，是0的话索引没变，是1的话索引变成“原索引+oldCap”，可以看看下图为16扩充为32的resize示意图：</p><p><img src="/2021/04/01/java-zhong-hash-yuan-li/544caeb82a329fa49cc99842818ed1ba_b.png" alt="img"></p><p>这个设计确实非常的巧妙，既省去了重新计算hash值的时间，而且同时，由于新增的1bit是0还是1可以认为是随机的，因此resize的过程，均匀的把之前的冲突的节点分散到新的bucket了。这一块就是JDK1.8新增的优化点。有一点注意区别，JDK1.7中rehash的时候，旧链表迁移新链表的时候，如果在新表的数组索引位置相同，则链表元素会倒置，但是从上图可以看出，JDK1.8不会倒置。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"> <span class="token number">1</span> <span class="token keyword">final</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token number">2</span>     <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> oldTab <span class="token operator">=</span> table<span class="token punctuation">;</span> <span class="token number">3</span>     <span class="token keyword">int</span> oldCap <span class="token operator">=</span> <span class="token punctuation">(</span>oldTab <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> oldTab<span class="token punctuation">.</span>length<span class="token punctuation">;</span> <span class="token number">4</span>     <span class="token keyword">int</span> oldThr <span class="token operator">=</span> threshold<span class="token punctuation">;</span> <span class="token number">5</span>     <span class="token keyword">int</span> newCap<span class="token punctuation">,</span> newThr <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token number">6</span>     <span class="token keyword">if</span> <span class="token punctuation">(</span>oldCap <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token number">7</span>         <span class="token comment">// 超过最大值就不再扩充了，就只好随你碰撞去吧</span> <span class="token number">8</span>         <span class="token keyword">if</span> <span class="token punctuation">(</span>oldCap <span class="token operator">&gt;=</span> MAXIMUM_CAPACITY<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token number">9</span>             threshold <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">;</span><span class="token number">10</span>             <span class="token keyword">return</span> oldTab<span class="token punctuation">;</span><span class="token number">11</span>         <span class="token punctuation">}</span><span class="token number">12</span>         <span class="token comment">// 没超过最大值，就扩充为原来的2倍</span><span class="token number">13</span>         <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>newCap <span class="token operator">=</span> oldCap <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token generics"><span class="token punctuation">&lt;</span> MAXIMUM_CAPACITY <span class="token operator">&amp;</span><span class="token operator">&amp;</span>14                  oldCap <span class="token punctuation">&gt;</span></span><span class="token operator">=</span> DEFAULT_INITIAL_CAPACITY<span class="token punctuation">)</span><span class="token number">15</span>             newThr <span class="token operator">=</span> oldThr <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// double threshold</span><span class="token number">16</span>     <span class="token punctuation">}</span><span class="token number">17</span>     <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>oldThr <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment">// initial capacity was placed in threshold</span><span class="token number">18</span>         newCap <span class="token operator">=</span> oldThr<span class="token punctuation">;</span><span class="token number">19</span>     <span class="token keyword">else</span> <span class="token punctuation">{</span>               <span class="token comment">// zero initial threshold signifies using defaults</span><span class="token number">20</span>         newCap <span class="token operator">=</span> DEFAULT_INITIAL_CAPACITY<span class="token punctuation">;</span><span class="token number">21</span>         newThr <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">(</span>DEFAULT_LOAD_FACTOR <span class="token operator">*</span> DEFAULT_INITIAL_CAPACITY<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token number">22</span>     <span class="token punctuation">}</span><span class="token number">23</span>     <span class="token comment">// 计算新的resize上限</span><span class="token number">24</span>     <span class="token keyword">if</span> <span class="token punctuation">(</span>newThr <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token number">25</span> <span class="token number">26</span>         <span class="token keyword">float</span> ft <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span>newCap <span class="token operator">*</span> loadFactor<span class="token punctuation">;</span><span class="token number">27</span>         newThr <span class="token operator">=</span> <span class="token punctuation">(</span>newCap <span class="token operator">&lt;</span> MAXIMUM_CAPACITY <span class="token operator">&amp;&amp;</span> ft <span class="token operator">&lt;</span> <span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span>MAXIMUM_CAPACITY <span class="token operator">?</span><span class="token number">28</span>                   <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>ft <span class="token operator">:</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token number">29</span>     <span class="token punctuation">}</span><span class="token number">30</span>     threshold <span class="token operator">=</span> newThr<span class="token punctuation">;</span><span class="token number">31</span>     <span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token string">"rawtypes"</span>，<span class="token string">"unchecked"</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token number">32</span>         <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> newTab <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">[</span>newCap<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token number">33</span>     table <span class="token operator">=</span> newTab<span class="token punctuation">;</span><span class="token number">34</span>     <span class="token keyword">if</span> <span class="token punctuation">(</span>oldTab <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token number">35</span>         <span class="token comment">// 把每个bucket都移动到新的buckets中</span><span class="token number">36</span>         <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> oldCap<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token number">37</span>             <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> e<span class="token punctuation">;</span><span class="token number">38</span>             <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> oldTab<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token number">39</span>                 oldTab<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span class="token number">40</span>                 <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>next <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token number">41</span>                     newTab<span class="token punctuation">[</span>e<span class="token punctuation">.</span>hash <span class="token operator">&amp;</span> <span class="token punctuation">(</span>newCap <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span><span class="token number">42</span>                 <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token keyword">instanceof</span> <span class="token class-name">TreeNode</span><span class="token punctuation">)</span><span class="token number">43</span>                     <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">)</span>e<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> newTab<span class="token punctuation">,</span> j<span class="token punctuation">,</span> oldCap<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token number">44</span>                 <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token comment">// 链表优化重hash的代码块</span><span class="token number">45</span>                     <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> loHead <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">,</span> loTail <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span class="token number">46</span>                     <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> hiHead <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">,</span> hiTail <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span class="token number">47</span>                     <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> next<span class="token punctuation">;</span><span class="token number">48</span>                     <span class="token keyword">do</span> <span class="token punctuation">{</span><span class="token number">49</span>                         next <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">;</span><span class="token number">50</span>                         <span class="token comment">// 原索引</span><span class="token number">51</span>                         <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">&amp;</span> oldCap<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token number">52</span>                             <span class="token keyword">if</span> <span class="token punctuation">(</span>loTail <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token number">53</span>                                 loHead <span class="token operator">=</span> e<span class="token punctuation">;</span><span class="token number">54</span>                             <span class="token keyword">else</span><span class="token number">55</span>                                 loTail<span class="token punctuation">.</span>next <span class="token operator">=</span> e<span class="token punctuation">;</span><span class="token number">56</span>                             loTail <span class="token operator">=</span> e<span class="token punctuation">;</span><span class="token number">57</span>                         <span class="token punctuation">}</span><span class="token number">58</span>                         <span class="token comment">// 原索引+oldCap</span><span class="token number">59</span>                         <span class="token keyword">else</span> <span class="token punctuation">{</span><span class="token number">60</span>                             <span class="token keyword">if</span> <span class="token punctuation">(</span>hiTail <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token number">61</span>                                 hiHead <span class="token operator">=</span> e<span class="token punctuation">;</span><span class="token number">62</span>                             <span class="token keyword">else</span><span class="token number">63</span>                                 hiTail<span class="token punctuation">.</span>next <span class="token operator">=</span> e<span class="token punctuation">;</span><span class="token number">64</span>                             hiTail <span class="token operator">=</span> e<span class="token punctuation">;</span><span class="token number">65</span>                         <span class="token punctuation">}</span><span class="token number">66</span>                     <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> next<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token number">67</span>                     <span class="token comment">// 原索引放到bucket里</span><span class="token number">68</span>                     <span class="token keyword">if</span> <span class="token punctuation">(</span>loTail <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token number">69</span>                         loTail<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span class="token number">70</span>                         newTab<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> loHead<span class="token punctuation">;</span><span class="token number">71</span>                     <span class="token punctuation">}</span><span class="token number">72</span>                     <span class="token comment">// 原索引+oldCap放到bucket里</span><span class="token number">73</span>                     <span class="token keyword">if</span> <span class="token punctuation">(</span>hiTail <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token number">74</span>                         hiTail<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span class="token number">75</span>                         newTab<span class="token punctuation">[</span>j <span class="token operator">+</span> oldCap<span class="token punctuation">]</span> <span class="token operator">=</span> hiHead<span class="token punctuation">;</span><span class="token number">76</span>                     <span class="token punctuation">}</span><span class="token number">77</span>                 <span class="token punctuation">}</span><span class="token number">78</span>             <span class="token punctuation">}</span><span class="token number">79</span>         <span class="token punctuation">}</span><span class="token number">80</span>     <span class="token punctuation">}</span><span class="token number">81</span>     <span class="token keyword">return</span> newTab<span class="token punctuation">;</span><span class="token number">82</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上图中的putval方法可以看出，如果table还是空的，那么扩容数组大小。</p><p>如果table的在（n-1）&amp;hash的值是空，就新建一个节点插入在该位置，否则表示有冲突,开始处理冲突。检查第一个node是不是要找的值，否则需要遍历链表。如果冲突的节点数已经大于8个，需要将存储结构变为红黑树(treeifyBin(tab, hash));</p><h3 id="2-线程安全性"><a href="#2-线程安全性" class="headerlink" title="2. 线程安全性"></a>2. 线程安全性</h3><p>在多线程使用场景中，应该尽量避免使用线程不安全的HashMap，而使用线程安全的ConcurrentHashMap。那么为什么说HashMap是线程不安全的，下面举例子说明在并发的多线程使用场景中使用HashMap可能造成死循环。代码例子如下(便于理解，仍然使用JDK1.7的环境)：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HashMapInfiniteLoop</span> <span class="token punctuation">{</span>      <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token number">2</span>，<span class="token number">0.75f</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>          map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token number">5</span>， <span class="token string">"C"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token string">"Thread1"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>              <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                  map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">,</span> <span class="token string">"B"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                  <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>map<span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token punctuation">}</span><span class="token punctuation">;</span>          <span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token string">"Thread2"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>              <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                  map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> "<span class="token class-name">A</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                  <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>map<span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token punctuation">}</span><span class="token punctuation">;</span>          <span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中，map初始化为一个长度为2的数组，loadFactor=0.75，threshold=2*0.75=1，也就是说当put第二个key的时候，map就需要进行resize。</p><p>通过设置断点让线程1和线程2同时debug到transfer方法(3.3小节代码块)的首行。注意此时两个线程已经成功添加数据。放开thread1的断点至transfer方法的“Entry next = e.next;” 这一行；然后放开线程2的的断点，让线程2进行resize。结果如下图。</p><p><img src="https://pic4.zhimg.com/fa10635a66de637fe3cbd894882ff0c7_b.png" alt="img"></p><p>注意，Thread1的 e 指向了key(3)，而next指向了key(7)，其在线程二rehash后，指向了线程二重组后的链表。</p><p>线程一被调度回来执行，先是执行 newTalbe[i] = e， 然后是e = next，导致了e指向了key(7)，而下一次循环的next = e.next导致了next指向了key(3)。</p><p><img src="https://pic4.zhimg.com/d39d7eff6e8e04f98f5b53bebe2d4d7f_b.png" alt="img"></p><p>e.next = newTable[i] 导致 key(3).next 指向了 key(7)。注意：此时的key(7).next 已经指向了key(3)， 环形链表就这样出现了。</p><p><img src="https://pic2.zhimg.com/5f3cf5300f041c771a736b40590fd7b1_b.png" alt="img"></p><p>于是，当我们用线程一调用map.get(11)时，悲剧就出现了——Infinite Loop。</p><h4 id="2-1-死链"><a href="#2-1-死链" class="headerlink" title="2.1 死链"></a>2.1 死链</h4><p>在JDK1.8之前，HashMap在并发场景下扩容时存在一个bug，形成死链，导致get该位置元素的时候，会死循环，使CPU利用率高居不下。这也说明了HashMap不适于用在高并发的场景，高并发应该优先考虑JUC中的ConcurrentHashMap。然而，精益求精的JDK开发者们并没有选择绕过问题，而是选择直面问题并解决它。在JDK1.8之中，引入了高低位链表（双端链表）。</p><p>什么是高低位链表呢？在扩容时，哈希桶数组buckets会扩容一倍，以容量为8的HashMap为例，原有容量8扩容至16，将[0, 7]称为低位，[8, 15]称为高位，低位对应loHead、loTail，高位对应hiHead、hiTail。</p><p>扩容时会依次遍历旧buckets数组的每一个位置上面的元素：</p><ul><li>若不存在冲突，则重新进行hash取模，并copy到新buckets数组中的对应位置。</li><li>若存在冲突元素，则采用高低位链表进行处理。通过e.hash &amp; oldCap来判断取模后是落在高位还是低位。举个例子：假设当前元素hashCode为0001（忽略高位），其运算结果等于0，说明扩容后结果不变，取模后还是落在低位[0, 7]，即0001 &amp; 1000 = 0000，还是原位置，再用低位链表将这类的元素链接起来。假设当前元素的hashCode为1001， 其运算结果不为0，即1001 &amp; 1000 = 1000 ，扩容后会落在高位，新的位置刚好是旧数组索引（1） + 旧数据长度（8） = 9，再用高位链表将这些元素链接起来。最后，将高低位链表的头节点分别放在扩容后数组newTab的指定位置上，即完成了扩容操作。这种实现降低了对共享资源newTab的访问频次，先组织冲突节点，最后再放入newTab的指定位置。避免了JDK1.8之前每遍历一个元素就放入newTab中，从而导致并发扩容下的死链问题。</li></ul><p><img src="/2021/04/01/java-zhong-hash-yuan-li/v2-3b9a5de58b2275fa0f4b090471a6b598_b.jpg" alt="img"><img src="/2021/04/01/java-zhong-hash-yuan-li/v2-3b9a5de58b2275fa0f4b090471a6b598_1440w.jpg" alt="img"></p><h3 id="3-初始化与懒加载"><a href="#3-初始化与懒加载" class="headerlink" title="3. 初始化与懒加载"></a>3. 初始化与懒加载</h3><blockquote><p>初始化的时候只会设置默认的负载因子，并不会进行其他初始化的操作，在首次使用的时候才会进行初始化。</p></blockquote><p>当new一个新的HashMap的时候，不会立即对哈希数组进行初始化，而是在首次put元素的时候，通过resize()方法进行初始化。</p><p><img src="/2021/04/01/java-zhong-hash-yuan-li/v2-52dd5001cc4f80503f1b2c644bd55863_b.jpg" alt="img"><img src="/2021/04/01/java-zhong-hash-yuan-li/v2-52dd5001cc4f80503f1b2c644bd55863_1440w.jpg" alt="img"></p><p>resize()中会设置默认的初始化容量DEFAULT_INITIAL_CAPACITY为16，扩容的阈值为0.75*16 = 12，即哈希桶数组中元素达到12个便进行扩容操作。</p><p>最后创建容量为16的Node数组，并赋值给成员变量哈希桶table，即完成了HashMap的初始化操作。</p><p><img src="/2021/04/01/java-zhong-hash-yuan-li/v2-167705cc7c0f7dacede4345e5b38a838_b.jpg" alt="img"><img src="/2021/04/01/java-zhong-hash-yuan-li/v2-167705cc7c0f7dacede4345e5b38a838_1440w.jpg" alt="img"></p><h3 id="4-确定哈希桶数组大小"><a href="#4-确定哈希桶数组大小" class="headerlink" title="4 确定哈希桶数组大小"></a>4 确定哈希桶数组大小</h3><blockquote><p>找到大于等于给定值的最小2的整数次幂。</p></blockquote><p>tableSizeFor根据输入容量大小cap来计算最终哈希桶数组的容量大小，找到大于等于给定值cap的最小2的整数次幂。乍眼一看，这一行一行的位运算让人云里雾里，莫不如采用类似找规律的方式来探索其中的奥秘。</p><p><img src="/2021/04/01/java-zhong-hash-yuan-li/v2-f2301f2430f3ae06db4e72ff4f018e74_b.jpg" alt="img"><img src="/2021/04/01/java-zhong-hash-yuan-li/v2-f2301f2430f3ae06db4e72ff4f018e74_1440w.jpg" alt="img"></p><p>当cap为3时，计算过程如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">cap <span class="token operator">=</span> <span class="token number">3</span>n <span class="token operator">=</span> <span class="token number">2</span>n <span class="token operator">|=</span> n <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">1</span>       <span class="token number">010</span>  <span class="token operator">|</span> <span class="token number">001</span> <span class="token operator">=</span> <span class="token number">011</span>   n <span class="token operator">=</span> <span class="token number">3</span>n <span class="token operator">|=</span> n <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">2</span>       <span class="token number">011</span>  <span class="token operator">|</span> <span class="token number">000</span> <span class="token operator">=</span> <span class="token number">011</span>   n <span class="token operator">=</span> <span class="token number">3</span>n <span class="token operator">|=</span> n <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">4</span>       <span class="token number">011</span>  <span class="token operator">|</span> <span class="token number">000</span> <span class="token operator">=</span> <span class="token number">011</span>   n <span class="token operator">=</span> <span class="token number">3</span>…<span class="token punctuation">.</span>n <span class="token operator">=</span> n <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">=</span> <span class="token number">4</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当cap为5时，计算过程如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">cap <span class="token operator">=</span> <span class="token number">5</span>n <span class="token operator">=</span> <span class="token number">4</span>n <span class="token operator">|=</span> n <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">1</span>    <span class="token number">0100</span> <span class="token operator">|</span> <span class="token number">0010</span> <span class="token operator">=</span> <span class="token number">0110</span>  n <span class="token operator">=</span> <span class="token number">6</span>n <span class="token operator">|=</span> n <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">2</span>    <span class="token number">0110</span> <span class="token operator">|</span> <span class="token number">0001</span> <span class="token operator">=</span> <span class="token number">0111</span>  n <span class="token operator">=</span> <span class="token number">7</span>…<span class="token punctuation">.</span>n <span class="token operator">=</span> n <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">=</span> <span class="token number">8</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>因此，计算的意义在于找到大于等于cap的最小2的整数次幂。整个过程是找到cap对应二进制中最高位的1，然后每次以2倍的步长（依次移位1、2、4、8、16）复制最高位1到后面的所有低位，把最高位1后面的所有位全部置为1，最后进行+1，即完成了进位。</p><p>类似二进制位的变化过程如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token number">0100</span> <span class="token number">1010</span><span class="token number">0111</span> <span class="token number">1111</span><span class="token number">1000</span> <span class="token number">0000</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>找到输入cap的最小2的整数次幂作为最终容量可以理解为最小可用原则，尽可能地少占用空间，但是为什么必须要2的整数次幂呢？答案是，为了提高计算与存储效率，使每个元素对应hash值能够准确落入哈希桶数组给定的范围区间内。确定数组下标采用的算法是 hash &amp; (n - 1)，n即为哈希桶数组的大小。由于其总是2的整数次幂，这意味着n-1的二进制形式永远都是0000111111的形式，即从最低位开始，连续出现多个1，该二进制与任何值进行&amp;运算都会使该值映射到指定区间[0, n-1]。比如：当n=8时，n-1对应的二进制为0111，任何与0111进行&amp;运算都会落入[0,7]的范围内，即落入给定的8个哈希桶中，存储空间利用率100%。举个反例，当n=7，n-1对应的二进制为0110，任何与0110进行&amp;运算会落入到第0、6、4、2个哈希桶，而不是[0,6]的区间范围内，少了1、3、5三个哈希桶，这导致存储空间利用率只有不到60%，同时也增加了哈希碰撞的几率。</p><h2 id="2-ConcurrentHashMap并发"><a href="#2-ConcurrentHashMap并发" class="headerlink" title="2. ConcurrentHashMap并发"></a>2. ConcurrentHashMap并发</h2><h3 id="1-ASHIFT偏移量计算"><a href="#1-ASHIFT偏移量计算" class="headerlink" title="1 ASHIFT偏移量计算"></a>1 ASHIFT偏移量计算</h3><blockquote><p>获取给定值的最高有效位数（移位除了能够进行乘除运算，还能用于保留高、低位操作，右移保留高位，左移保留低位）。</p></blockquote><p>ConcurrentHashMap中的ABASE+ASHIFT是用来计算哈希数组中某个元素在实际内存中的初始位置，ASHIFT采取的计算方式是31与scale前导0的数量做差，也就是scale的实际位数-1。scale就是哈希桶数组Node[]中每个元素的大小，通过((long)i &lt;&lt; ASHIFT) + ABASE)进行计算，便可得到数组中第i个元素的起始内存地址。</p><p><img src="/2021/04/01/java-zhong-hash-yuan-li/v2-2c72e1ccc0fd703d7bc67db2b70f27e7_b.jpg" alt="img"><img src="/2021/04/01/java-zhong-hash-yuan-li/v2-2c72e1ccc0fd703d7bc67db2b70f27e7_1440w.jpg" alt="img"></p><p>我们继续看下前导0的数量是怎么计算出来的，numberOfLeadingZeros是Integer的静态方法，还是沿用找规律的方式一探究竟。</p><p><img src="/2021/04/01/java-zhong-hash-yuan-li/v2-1b63144ec844fbae7c5de08abbdafb17_b.jpg" alt="img"><img src="/2021/04/01/java-zhong-hash-yuan-li/v2-1b63144ec844fbae7c5de08abbdafb17_1440w.jpg" alt="img"></p><p>假设 i = 0000 0000 0000 0100 0000 0000 0000 0000，n = 1</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">i <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">16</span>  <span class="token number">0000</span> <span class="token number">0000</span> <span class="token number">0000</span> <span class="token number">0000</span> <span class="token number">0000</span> <span class="token number">0000</span> <span class="token number">0000</span> <span class="token number">0100</span>   不为<span class="token number">0</span>i <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">24</span>  <span class="token number">0000</span> <span class="token number">0000</span> <span class="token number">0000</span> <span class="token number">0000</span> <span class="token number">0000</span> <span class="token number">0000</span> <span class="token number">0000</span> <span class="token number">0000</span>   等于<span class="token number">0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>右移了24位等于0，说明24位到31位之间肯定全为0，即n = 1 + 8 = 9，由于高8位全为0，并且已经将信息记录至n中，因此可以舍弃高8位，即 i &lt;&lt;= 8。此时，</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">i <span class="token operator">=</span> <span class="token number">0000</span> <span class="token number">0100</span> <span class="token number">0000</span> <span class="token number">0000</span> <span class="token number">0000</span> <span class="token number">0000</span> <span class="token number">0000</span> <span class="token number">0000</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>类似地，i &gt;&gt;&gt; 28 也等于0，说明28位到31位全为0，n = 9 + 4 = 13，舍弃高4位。此时，</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">i <span class="token operator">=</span> <span class="token number">0100</span> <span class="token number">0000</span> <span class="token number">0000</span> <span class="token number">0000</span> <span class="token number">0000</span> <span class="token number">0000</span> <span class="token number">0000</span> <span class="token number">0000</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>继续运算，</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">i <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">30</span>  <span class="token number">0000</span> <span class="token number">0000</span> <span class="token number">0000</span> <span class="token number">0000</span> <span class="token number">0000</span> <span class="token number">0000</span> <span class="token number">0000</span> <span class="token number">0001</span>   不为<span class="token number">0</span>i <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">31</span>  <span class="token number">0000</span> <span class="token number">0000</span> <span class="token number">0000</span> <span class="token number">0000</span> <span class="token number">0000</span> <span class="token number">0000</span> <span class="token number">0000</span> <span class="token number">0000</span>   等于<span class="token number">0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>最终可得出n = 13，即有13个前导0。n -= i &gt;&gt;&gt; 31是检查最高位31位是否是1，因为n初始化为1，如果最高位是1，则不存在前置0，即n = n - 1 = 0。</p><p>总结一下，以上的操作其实是基于二分法的思想来定位二进制中1的最高位，先看高16位，若为0，说明1存在于低16位；反之存在高16位。由此将搜索范围由32位（确切的说是31位）减少至16位，进而再一分为二，校验高8位与低8位，以此类推。</p><p>计算过程中校验的位数依次为16、8、4、2、1，加起来刚好为31。为什么是31不是32呢？因为前置0的数量为32的情况下i只能为0，在前面的if条件中已经进行过滤。这样一来，非0值的情况下，前置0只能出现在高31位，因此只需要校验高31位即可。最终，用总位数减去计算出来的前导0的数量，即可得出二进制的最高有效位数。代码中使用的是31 - Integer.numberOfLeadingZeros(scale)，而不是总位数32，这是为了能够得到哈希桶数组中第i个元素的起始内存地址，方便进行CAS等操作。</p><h3 id="分段锁"><a href="#分段锁" class="headerlink" title="分段锁"></a>分段锁</h3><p>针对HashTable中锁粒度过粗的问题，在JDK1.8之前，ConcurrentHashMap引入了分段锁机制。整体的存储结构如下图所示，在原有结构的基础上拆分出多个segment，每个segment下再挂载原来的entry（上文中经常提到的哈希桶数组），每次操作只需要锁定元素所在的segment，不需要锁定整个表。因此，锁定的范围更小，并发度也会得到提升。</p><p><img src="/2021/04/01/java-zhong-hash-yuan-li/v2-ca34f88b24acf2a89af7341790d2ecc0_b.jpg" alt="img"><img src="https://pic1.zhimg.com/80/v2-ca34f88b24acf2a89af7341790d2ecc0_1440w.jpg" alt="img"></p><h3 id="2-乐观锁"><a href="#2-乐观锁" class="headerlink" title="2 乐观锁"></a>2 乐观锁</h3><h3 id="Synchronized-CAS"><a href="#Synchronized-CAS" class="headerlink" title="Synchronized+CAS"></a>Synchronized+CAS</h3><p>虽然引入了分段锁的机制，即可以保证线程安全，又可以解决锁粒度过粗导致的性能低下问题，但是对于追求极致性能的工程师来说，这还不是性能的天花板。因此，在JDK1.8中，ConcurrentHashMap摒弃了分段锁，使用了乐观锁的实现方式。放弃分段锁的原因主要有以下几点：</p><ul><li>使用segment之后，会增加ConcurrentHashMap的存储空间。</li><li>当单个segment过大时，并发性能会急剧下降。</li></ul><p>ConcurrentHashMap在JDK1.8中的实现废弃了之前的segment结构，沿用了与HashMap中的类似的Node数组结构。</p><p><img src="/2021/04/01/java-zhong-hash-yuan-li/v2-13cb919604808ab8ddebf3f0f6449123_b.jpg" alt="img"><img src="https://pic4.zhimg.com/80/v2-13cb919604808ab8ddebf3f0f6449123_1440w.jpg" alt="img"></p><p>ConcurrentHashMap中的乐观锁是采用synchronized+CAS进行实现的。这里主要看下put的相关代码。</p><p>当put的元素在哈希桶数组中不存在时，则直接CAS进行写操作。</p><p><img src="/2021/04/01/java-zhong-hash-yuan-li/v2-3d06f86c261b997aa3eb0f0f33162df1_b.jpg" alt="img"><img src="/2021/04/01/java-zhong-hash-yuan-li/v2-3d06f86c261b997aa3eb0f0f33162df1_1440w.jpg" alt="img"></p><p>这里涉及到了两个重要的操作，tabAt与casTabAt。可以看出，这里面都使用了Unsafe类的方法。Unsafe这个类在日常的开发过程中比较罕见。我们通常对Java语言的认知是：Java语言是安全的，所有操作都基于JVM，在安全可控的范围内进行。然而，Unsafe这个类会打破这个边界，使Java拥有C的能力，可以操作任意内存地址，是一把双刃剑。这里使用到了前文中所提到的ASHIFT，来计算出指定元素的起始内存地址，再通过getObjectVolatile与compareAndSwapObject分别进行取值与CAS操作。</p><p>在获取哈希桶数组中指定位置的元素时为什么不能直接get而是要使用getObjectVolatile呢？因为在JVM的内存模型中，每个线程有自己的工作内存，也就是栈中的局部变量表，它是主存的一份copy。因此，线程1对某个共享资源进行了更新操作，并写入到主存，而线程2的工作内存之中可能还是旧值，脏数据便产生了。Java中的volatile是用来解决上述问题，保证可见性，任意线程对volatile关键字修饰的变量进行更新时，会使其它线程中该变量的副本失效，需要从主存中获取最新值。虽然ConcurrentHashMap中的Node数组是由volatile修饰的，可以保证可见性，但是Node数组中元素是不具备可见性的。因此，在获取数据时通过Unsafe的方法直接到主存中拿，保证获取的数据是最新的。</p><p><img src="/2021/04/01/java-zhong-hash-yuan-li/v2-2a0ec6f2403fbf7235bb39d0bb24ae70_b.jpg" alt="img"><img src="https://pic1.zhimg.com/80/v2-2a0ec6f2403fbf7235bb39d0bb24ae70_1440w.jpg" alt="img"></p><p>继续往下看put方法的逻辑，当put的元素在哈希桶数组中存在，并且不处于扩容状态时，则使用synchronized锁定哈希桶数组中第i个位置中的第一个元素f（头节点2），接着进行double check，类似于DCL单例模式的思想。校验通过后，会遍历当前冲突链上的元素，并选择合适的位置进行put操作。此外，ConcurrentHashMap也沿用了HashMap中解决哈希冲突的方案，链表+红黑树。这里只有在发生哈希冲突的情况下才使用synchronized锁定头节点，其实是比分段锁更细粒度的锁实现，只在特定场景下锁定其中一个哈希桶，降低锁的影响范围。</p><p><img src="/2021/04/01/java-zhong-hash-yuan-li/v2-9a575ca767b29e41f94fa6665ac89b9c_b.jpg" alt="img"><img src="/2021/04/01/java-zhong-hash-yuan-li/v2-9a575ca767b29e41f94fa6665ac89b9c_1440w.jpg" alt="img"></p><p>Java Map针对并发场景解决方案的演进方向可以归结为，从悲观锁到乐观锁，从粗粒度锁到细粒度锁，这也可以作为我们在日常并发编程中的指导方针。</p><h3 id="3-并发求和"><a href="#3-并发求和" class="headerlink" title="3 并发求和"></a>3 并发求和</h3><p>CounterCell是JDK1.8中引入用来并发求和的利器，而在这之前采用的是【尝试无锁求和】+【冲突时加锁重试】的策略。看下CounterCell的注释，它是改编自LongAdder和Striped64。我们先看下求和操作，其实就是取baseCount作为初始值，然后遍历CounterCell数组中的每一个cell，将各个cell的值进行累加。这里额外说明下@sun.misc.Contender注解的作用，它是Java8中引入用来解决缓存行伪共享问题的。什么是伪共享呢？简单说下，考虑到CPU与主存之间速度的巨大差异，在CPU中引入了L1、L2、L3多级缓存，缓存中的存储单位是缓存行，缓存行大小为2的整数次幂字节，32-256个字节不等，最常见的是64字节。因此，这将导致不足64字节的变量会共享同一个缓存行，其中一个变量失效会影响到同一个缓存行中的其他变量，致使性能下降，这就是伪共享问题。考虑到不同CPU的缓存行单位的差异性，Java8中便通过该注解将这种差异性屏蔽，根据实际缓存行大小来进行填充，使被修饰的变量能够独占一个缓存行。</p><p><img src="/2021/04/01/java-zhong-hash-yuan-li/v2-54641c589fa421ad31337f0508dbb9a0_b.jpg" alt="img"><img src="/2021/04/01/java-zhong-hash-yuan-li/v2-54641c589fa421ad31337f0508dbb9a0_1440w.jpg" alt="img"></p><p><img src="/2021/04/01/java-zhong-hash-yuan-li/v2-b0653f6fa4cbfef65e7e118acf2ed6fd_b.jpg" alt="img"><img src="/2021/04/01/java-zhong-hash-yuan-li/v2-b0653f6fa4cbfef65e7e118acf2ed6fd_1440w.jpg" alt="img"></p><p>再来看下CounterCell是如何实现计数的，每当map中的容量有变化时会调用addCount进行计数，核心逻辑如下：</p><ul><li>当counterCells不为空，或counterCells为空且对baseCount进行CAS操作失败时进入到后续计数处理逻辑，否则对baseCount进行CAS操作成功，直接返回。</li><li>后续计数处理逻辑中会调用核心计数方法fullAddCount，但需要满足以下4个条件中的任意一个：1、counterCells为空；2、counterCells的size为0；3、counterCells对应位置上的counterCell为空；4、CAS更新counterCells对应位置上的counterCell失败。这些条件背后的语义是，当前情况下，计数已经或曾经出现过并发冲突，需要优先借助于CounterCell来解决。若counterCells与对应位置上的元素已经初始化（条件4），则先尝试CAS进行更新，若失败则调用fullAddCount继续处理。若counterCells与对应位置上的元素未初始化完成（条件1、2、3），也要调用AddCount进行后续处理。</li><li>这里确定cell下标时采用了ThreadLocalRandom.getProbe()作为哈希值，这个方法返回的是当前Thread中threadLocalRandomProbe字段的值。而且当哈希值冲突时，还可以通过advanceProbe方法来更换哈希值。这与HashMap中的哈希值计算逻辑不同，因为HashMap中要保证同一个key进行多次哈希计算的哈希值相同并且能定位到对应的value，即便两个key的哈希值冲突也不能随便更换哈希值，只能采用链表或红黑树处理冲突。然而在计数场景，我们并不需要维护key-value的关系，只需要在counterCells中找到一个合适的位置放入计数cell，位置的差异对最终的求和结果是没有影响的，因此当冲突时可以基于随机策略更换一个哈希值来避免冲突。</li></ul><p><img src="/2021/04/01/java-zhong-hash-yuan-li/v2-9f37662ab4a160c5058d778adeaefab2_b.jpg" alt="img"><img src="/2021/04/01/java-zhong-hash-yuan-li/v2-9f37662ab4a160c5058d778adeaefab2_1440w.jpg" alt="img"></p><p>接着，我们来看下核心计算逻辑fullAddCount，代码还是比较多的，核心流程是通过一个死循环来实现的，循环体中包含了3个处理分支，为了方便讲解我将它们依次定义A、B、C。</p><ul><li>A：表示counterCells已经初始化完成，因此可以尝试更新或创建对应位置的CounterCell。</li><li>B：表示counterCells未初始化完成，且无冲突（拿到cellsBusy锁），则加锁初始化counterCells，初始容量为2。</li><li>C：表示counterCells未初始化完成，且有冲突（未能拿到cellsBusy锁），则CAS更新baseCount，baseCount在求和时也会被算入到最终结果中，这也相当于是一种兜底策略，既然counterCells正在被其他线程锁定，那当前线程也没必要再等待了，直接尝试使用baseCount进行累加。</li></ul><p>其中，A分支中涉及到的操作又可以拆分为以下几点：</p><ul><li><p>a1：对应位置的CounterCell未创建，采用锁+Double Check的策略尝试创建CounterCell，失败的话则continue进行重试。这里面采用的锁是cellsBusy，它保证创建CounterCell并放入counterCells时一定是串行执行，避免重复创建，其实就是使用了DCL单例模式的策略。在CounterCells的创建、扩容中都需要使用该锁。</p></li><li><p>a2：冲突检测，变量wasUncontended是调用方addCount中传入的，表示前置的CAS更新cell失败，有冲突，需要更换哈希值【a7】后继续重试。</p></li><li><p>a3：对应位置的CounterCell不为空，直接CAS进行更新。</p></li><li><p>a4：</p></li><li><ul><li>冲突检测，当counterCells的引用值不等于当前线程对应的引用值时，说明有其他线程更改了counterCells的引用，出现冲突，则将collide设为false，下次迭代时可进行扩容。</li><li>容量限制，counterCells容量的最大值为大于等于NCPU（实际机器CPU核心的数量）的最小2的整数次幂，当达到容量限制时后面的扩容分支便永远不会执行。这里限制的意义在于，真实并发度是由CPU核心来决定，当counterCells容量与CPU核心数量相等时，理想情况下就算所有CPU核心在同时运行不同的计数线程时，都不应该出现冲突，每个线程选择各自的cell进行处理即可。如果出现冲突，一定是哈希值的问题，因此采取的措施是重新计算哈希值a7，而不是通过扩容来解决。时间换空间，避免不必要的存储空间浪费，非常赞的想法~</li></ul></li></ul><ul><li>a5：更新扩容标志位，下次迭代时将会进行扩容。</li><li>a6：进行加锁扩容，每次扩容1倍。</li><li>a7：更换哈希值。</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">fullAddCount</span><span class="token punctuation">(</span><span class="token keyword">long</span> x<span class="token punctuation">,</span> <span class="token keyword">boolean</span> wasUncontended<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> h<span class="token punctuation">;</span>        <span class="token comment">// 初始化probe</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>h <span class="token operator">=</span> <span class="token class-name">ThreadLocalRandom</span><span class="token punctuation">.</span><span class="token function">getProbe</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token class-name">ThreadLocalRandom</span><span class="token punctuation">.</span><span class="token function">localInit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">// force initialization</span>            h <span class="token operator">=</span> <span class="token class-name">ThreadLocalRandom</span><span class="token punctuation">.</span><span class="token function">getProbe</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            wasUncontended <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment">// 用来控制扩容操作</span>        <span class="token keyword">boolean</span> collide <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                <span class="token comment">// True if last slot nonempty</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token class-name">CounterCell</span><span class="token punctuation">[</span><span class="token punctuation">]</span> as<span class="token punctuation">;</span> <span class="token class-name">CounterCell</span> a<span class="token punctuation">;</span> <span class="token keyword">int</span> n<span class="token punctuation">;</span> <span class="token keyword">long</span> v<span class="token punctuation">;</span>            <span class="token comment">// 【A】counterCells已经初始化完毕</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>as <span class="token operator">=</span> counterCells<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>n <span class="token operator">=</span> as<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment">// 【a1】对应位置的CounterCell未创建</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>a <span class="token operator">=</span> as<span class="token punctuation">[</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> h<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token comment">// cellsBusy其实是一个锁，cellsBusy=0时表示无冲突</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>cellsBusy <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment">// Try to attach new Cell</span>                        <span class="token comment">// 创建新的CounterCell</span>                        <span class="token class-name">CounterCell</span> r <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CounterCell</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Optimistic create</span>                        <span class="token comment">// Double Check，加锁（通过CAS将cellsBusy设置1）</span>                        <span class="token keyword">if</span> <span class="token punctuation">(</span>cellsBusy <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span>                            <span class="token class-name">U</span><span class="token punctuation">.</span><span class="token function">compareAndSwapInt</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> CELLSBUSY<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                            <span class="token keyword">boolean</span> created <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                            <span class="token keyword">try</span> <span class="token punctuation">{</span>               <span class="token comment">// Recheck under lock</span>                                <span class="token class-name">CounterCell</span><span class="token punctuation">[</span><span class="token punctuation">]</span> rs<span class="token punctuation">;</span> <span class="token keyword">int</span> m<span class="token punctuation">,</span> j<span class="token punctuation">;</span>                                <span class="token comment">// Double Check</span>                                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>rs <span class="token operator">=</span> counterCells<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span>                                    <span class="token punctuation">(</span>m <span class="token operator">=</span> rs<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span>                                    rs<span class="token punctuation">[</span>j <span class="token operator">=</span> <span class="token punctuation">(</span>m <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> h<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                                    <span class="token comment">// 将新创建的CounterCell放入counterCells中</span>                                    rs<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> r<span class="token punctuation">;</span>                                    created <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                                <span class="token punctuation">}</span>                            <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>                                <span class="token comment">// 解锁，这里为什么不用CAS？因为当前流程中需要在获取锁的前提下进行，即串行执行，因此不存在并发更新问题，只需要正常更新即可</span>                                cellsBusy <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                            <span class="token punctuation">}</span>                            <span class="token keyword">if</span> <span class="token punctuation">(</span>created<span class="token punctuation">)</span>                                <span class="token keyword">break</span><span class="token punctuation">;</span>                            <span class="token comment">// 创建失败则重试</span>                            <span class="token keyword">continue</span><span class="token punctuation">;</span>           <span class="token comment">// Slot is now non-empty</span>                        <span class="token punctuation">}</span>                    <span class="token punctuation">}</span>                    <span class="token comment">// cellsBusy不为0，说明被其他线程争抢到了锁，还不能考虑扩容</span>                    collide <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token comment">//【a2】冲突检测</span>                <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>wasUncontended<span class="token punctuation">)</span>       <span class="token comment">// CAS already known to fail</span>                    <span class="token comment">// 调用方addCount中CAS更新cell失败，有冲突，则继续尝试CAS</span>                    wasUncontended <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>      <span class="token comment">// Continue after rehash</span>                <span class="token comment">//【a3】对应位置的CounterCell不为空，直接CAS进行更新</span>                <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">U</span><span class="token punctuation">.</span><span class="token function">compareAndSwapLong</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> CELLVALUE<span class="token punctuation">,</span> v <span class="token operator">=</span> a<span class="token punctuation">.</span>value<span class="token punctuation">,</span> v <span class="token operator">+</span> x<span class="token punctuation">)</span><span class="token punctuation">)</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token comment">//【a4】容量限制</span>                <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>counterCells <span class="token operator">!=</span> as <span class="token operator">||</span> n <span class="token operator">&gt;=</span> NCPU<span class="token punctuation">)</span>                    <span class="token comment">// 说明counterCells容量的最大值为大于NCPU（实际机器CPU核心的数量）最小2的整数次幂。</span>                    <span class="token comment">// 这里限制的意义在于，并发度是由CPU核心来决定，当counterCells容量与CPU核心数量相等时，理论上讲就算所有CPU核心都在同时运行不同的计数线程时，都不应该出现冲突，每个线程选择各自的cell进行处理即可。如果出现冲突，一定是哈希值的问题，因此采取的措施是重新计算哈希值（h = ThreadLocalRandom.advanceProbe(h)），而不是通过扩容来解决</span>                    <span class="token comment">// 当n大于NCPU时后面的分支就不会走到了</span>                    collide <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token comment">// At max size or stale</span>                <span class="token comment">// 【a5】更新扩容标志位</span>                <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>collide<span class="token punctuation">)</span>                    <span class="token comment">// 说明映射到cell位置不为空，并且尝试进行CAS更新时失败了，则说明有竞争，将collide设置为true，下次迭代时执行后面的扩容操作，降低竞争度</span>                    <span class="token comment">// 有竞争时，执行rehash+扩容，当容量大于CPU核心时则停止扩容只进行rehash</span>                    collide <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                <span class="token comment">// 【a6】加锁扩容</span>                <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>cellsBusy <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span>                         <span class="token class-name">U</span><span class="token punctuation">.</span><span class="token function">compareAndSwapInt</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> CELLSBUSY<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token comment">// 加锁扩容</span>                    <span class="token keyword">try</span> <span class="token punctuation">{</span>                        <span class="token keyword">if</span> <span class="token punctuation">(</span>counterCells <span class="token operator">==</span> as<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">// Expand table unless stale</span>                            <span class="token comment">// 扩容1倍</span>                            <span class="token class-name">CounterCell</span><span class="token punctuation">[</span><span class="token punctuation">]</span> rs <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CounterCell</span><span class="token punctuation">[</span>n <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>                                rs<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> as<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>                            counterCells <span class="token operator">=</span> rs<span class="token punctuation">;</span>                        <span class="token punctuation">}</span>                    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>                        cellsBusy <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                    collide <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                    <span class="token keyword">continue</span><span class="token punctuation">;</span>                   <span class="token comment">// Retry with expanded table</span>                <span class="token punctuation">}</span>                <span class="token comment">//【a7】更换哈希值</span>                h <span class="token operator">=</span> <span class="token class-name">ThreadLocalRandom</span><span class="token punctuation">.</span><span class="token function">advanceProbe</span><span class="token punctuation">(</span>h<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment">// 【B】counterCells未初始化完成，且无冲突，则加锁初始化counterCells</span>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>cellsBusy <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> counterCells <span class="token operator">==</span> as <span class="token operator">&amp;&amp;</span>                     <span class="token class-name">U</span><span class="token punctuation">.</span><span class="token function">compareAndSwapInt</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> CELLSBUSY<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">boolean</span> init <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                <span class="token keyword">try</span> <span class="token punctuation">{</span>                           <span class="token comment">// Initialize table</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>counterCells <span class="token operator">==</span> as<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        <span class="token class-name">CounterCell</span><span class="token punctuation">[</span><span class="token punctuation">]</span> rs <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CounterCell</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                        rs<span class="token punctuation">[</span>h <span class="token operator">&amp;</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CounterCell</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>                        counterCells <span class="token operator">=</span> rs<span class="token punctuation">;</span>                        init <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>                    cellsBusy <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>init<span class="token punctuation">)</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment">// 【C】counterCells未初始化完成，且有冲突，则CAS更新baseCount</span>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">U</span><span class="token punctuation">.</span><span class="token function">compareAndSwapLong</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> BASECOUNT<span class="token punctuation">,</span> v <span class="token operator">=</span> baseCount<span class="token punctuation">,</span> v <span class="token operator">+</span> x<span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>                          <span class="token comment">// Fall back on using base</span>        <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>CounterCell的设计很巧妙，它的背后其实就是JDK1.8中的LongAdder。核心思想是：在并发较低的场景下直接采用baseCount累加，否则结合counterCells，将不同的线程散列到不同的cell中进行计算，尽可能地确保访问资源的隔离，减少冲突。LongAdder相比较于AtomicLong中无脑CAS的策略，在高并发的场景下，能够减少CAS重试的次数，提高计算效率。</p><h2 id="2-hash方法"><a href="#2-hash方法" class="headerlink" title="2. hash方法"></a>2. hash方法</h2><p>我们拿JDK 1.7的HashMap为例，其中定义了一个final int hash(Object k) 方法，其主要被以下方法引用。</p><p><a href="http://www.hollischuang.com/wp-content/uploads/2018/03/hash-use.png"><img src="/2021/04/01/java-zhong-hash-yuan-li/hash-use.png" alt="hash-use"></a></p><p>上面的方法主要都是增加和删除方法，这不难理解，当我们要对一个链表数组中的某个元素进行增删的时候，首先要知道他应该保存在这个链表数组中的哪个位置，即他在这个数组中的下标。而hash()方法的功能就是根据Key来定位其在HashMap中的位置。HashTable、ConcurrentHashMap同理。</p><p>首先，在同一个版本的Jdk中，HashMap、HashTable以及ConcurrentHashMap里面的hash方法的实现是不同的。再不同的版本的JDK中（Java7 和 Java8）中也是有区别的。我会尽量全部介绍到。相信，看文这篇文章，你会彻底理解hash方法。</p><p>在上代码之前，我们先来做个简单分析。我们知道，hash方法的功能是根据Key来定位这个K-V在链表数组中的位置的。也就是hash方法的输入应该是个Object类型的Key，输出应该是个int类型的数组下标。如果让你设计这个方法，你会怎么做？</p><p>其实简单，我们只要调用Object对象的hashCode()方法，该方法会返回一个整数，然后用这个数对HashMap或者HashTable的容量进行取模就行了。没错，其实基本原理就是这个，只不过，在具体实现上，由两个方法<code>int hash(Object k)</code>和<code>int indexFor(int h, int length)</code>来实现。但是考虑到效率等问题，HashMap的实现会稍微复杂一点。</p><blockquote><p>hash ：该方法主要是将Object转换成一个整型。</p><p>indexFor ：该方法主要是将hash生成的整型转换成链表数组中的下标。</p></blockquote><h4 id="HashMap-In-Java-7"><a href="#HashMap-In-Java-7" class="headerlink" title="HashMap In Java 7"></a>HashMap In Java 7</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">hash</span><span class="token punctuation">(</span><span class="token class-name">Object</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> h <span class="token operator">=</span> hashSeed<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token number">0</span> <span class="token operator">!=</span> h <span class="token operator">&amp;&amp;</span> k <span class="token keyword">instanceof</span> <span class="token class-name">String</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token class-name"><span class="token namespace">sun<span class="token punctuation">.</span>misc<span class="token punctuation">.</span></span>Hashing</span><span class="token punctuation">.</span><span class="token function">stringHash32</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">)</span> k<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    h <span class="token operator">^=</span> k<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    h <span class="token operator">^=</span> <span class="token punctuation">(</span>h <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">20</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">12</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> h <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">7</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">indexFor</span><span class="token punctuation">(</span><span class="token keyword">int</span> h<span class="token punctuation">,</span> <span class="token keyword">int</span> length<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> h <span class="token operator">&amp;</span> <span class="token punctuation">(</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>前面我说过，<code>indexFor</code>方法其实主要是将hash生成的整型转换成链表数组中的下标。那么<code>return h &amp; (length-1);</code>是什么意思呢？其实，他就是取模。Java之所有使用位运算(&amp;)来代替取模运算(%)，最主要的考虑就是效率。<strong>位运算(&amp;)效率要比代替取模运算(%)高很多，主要原因是位运算直接对内存数据进行操作，不需要转成十进制，因此处理速度非常快。</strong></p><p>那么，为什么可以使用位运算(&amp;)来实现取模运算(%)呢？这实现的原理如下：</p><blockquote><p>X % 2^n = X &amp; (2^n – 1)</p><p>2^n表示2的n次方，也就是说，一个数对2^n取模 == 一个数和(2^n – 1)做按位与运算 。</p><p>假设n为3，则2^3 = 8，表示成2进制就是1000。2^3 = 7 ，即0111。</p><p>此时X &amp; (2^3 – 1) 就相当于取X的2进制的最后三位数。</p><p>从2进制角度来看，X / 8相当于 X &gt;&gt; 3，即把X右移3位，此时得到了X / 8的商，而被移掉的部分(后三位)，则是X % 8，也就是余数。</p></blockquote><p>上面的解释不知道你有没有看懂，没看懂的话其实也没关系，你只需要记住这个技巧就可以了。或者你可以找几个例子试一下。</p><blockquote><p>6 % 8 = 6 ，6 &amp; 7 = 6</p><p>10 &amp; 8 = 2 ，10 &amp; 7 = 2</p></blockquote><p><a href="http://www.hollischuang.com/wp-content/uploads/2018/03/640-1.png"><img src="/2021/04/01/java-zhong-hash-yuan-li/640-1.png" alt="640 (1)"></a></p><p>所以，<code>return h &amp; (length-1);</code>只要保证length的长度是<code>2^n</code>的话，就可以实现取模运算了。而HashMap中的length也确实是2的倍数，初始值是16，之后每次扩充为原来的2倍。</p><p>分析完<code>indexFor</code>方法后，我们接下来准备分析<code>hash</code>方法的具体原理和实现。在深入分析之前，至此，先做个总结。</p><p>HashMap的数据是存储在链表数组里面的。在对HashMap进行插入/删除等操作时，都需要根据K-V对的键值定位到他应该保存在数组的哪个下标中。而这个通过键值求取下标的操作就叫做哈希。HashMap的数组是有长度的，Java中规定这个长度只能是2的倍数，初始值为16。简单的做法是先求取出键值的hashcode，然后在将hashcode得到的int值对数组长度进行取模。为了考虑性能，Java总采用按位与操作实现取模操作。</p><p>接下来我们会发现，无论是用取模运算还是位运算都无法直接解决冲突较大的问题。比如：<code>CA11 0000</code>和<code>0001 0000</code>在对<code>0000 1111</code>进行按位与运算后的值是相等的。<a href="http://www.hollischuang.com/wp-content/uploads/2018/03/640-2.png"><img src="/2021/04/01/java-zhong-hash-yuan-li/640-2.png" alt="640 (2)"></a></p><p>两个不同的键值，在对数组长度进行按位与运算后得到的结果相同，这不就发生了冲突吗。那么如何解决这种冲突呢，来看下Java是如何做的。</p><p>其中的主要代码部分如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">h <span class="token operator">^=</span> k<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>h <span class="token operator">^=</span> <span class="token punctuation">(</span>h <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">20</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">12</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> h <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">7</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这段代码是为了对key的hashCode进行扰动计算，防止不同hashCode的高位不同但低位相同导致的hash冲突。简单点说，就是为了把高位的特征和低位的特征组合起来，降低哈希冲突的概率，也就是说，尽量做到任何一位的变化都能对最终得到的结果产生影响。</p><p>举个例子来说，我们现在想向一个HashMap中put一个K-V对，Key的值为“hollischuang”，经过简单的获取hashcode后，得到的值为“1011000110101110011111010011011”，如果当前HashTable的大小为16，即在不进行扰动计算的情况下，他最终得到的index结果值为11。由于15的二进制扩展到32位为“00000000000000000000000000001111”，所以，一个数字在和他进行按位与操作的时候，前28位无论是什么，计算结果都一样（因为0和任何数做与，结果都为0）。如下图所示。</p><p><a href="http://www.hollischuang.com/wp-content/uploads/2018/03/640-3.png"><img src="http://www.hollischuang.com/wp-content/uploads/2018/03/640-3.png" alt="640 (3)"></a></p><p>可以看到，后面的两个hashcode经过位运算之后得到的值也是11 ，虽然我们不知道哪个key的hashcode是上面例子中的那两个，但是肯定存在这样的key，这就产生了冲突。</p><p>那么，接下来，我看看一下经过扰动的算法最终的计算结果会如何。</p><p><a href="http://www.hollischuang.com/wp-content/uploads/2018/03/640-4.png"><img src="/2021/04/01/java-zhong-hash-yuan-li/640-4.png" alt="640 (4)"></a></p><p>从上面图中可以看到，之前会产生冲突的两个hashcode，经过扰动计算之后，最终得到的index的值不一样了，这就很好的避免了冲突。</p><blockquote><p>其实，使用位运算代替取模运算，除了性能之外，还有一个好处就是可以很好的解决负数的问题。因为我们知道，hashcode的结果是int类型，而int的取值范围是-2^31 ~ 2^31 – 1，即[ -2147483648, 2147483647]；这里面是包含负数的，我们知道，对于一个负数取模还是有些麻烦的。如果使用二进制的位运算的话就可以很好的避免这个问题。首先，不管hashcode的值是正数还是负数。length-1这个值一定是个正数。那么，他的二进制的第一位一定是0（有符号数用最高位作为符号位，“0”代表“+”，“1”代表“-”），这样里两个数做按位与运算之后，第一位一定是个0，也就是，得到的结果一定是个正数。</p></blockquote><h3 id="3-HashTable-In-Java-7"><a href="#3-HashTable-In-Java-7" class="headerlink" title="3.HashTable In Java 7"></a>3.HashTable In Java 7</h3><p>上面是Java 7中HashMap的<code>hash</code>方法以及<code>indexOf</code>方法的实现，那么接下来我们要看下，线程安全的HashTable是如何实现的，和HashMap有何不同，并试着分析下不同的原因。以下是Java 7中HashTable的hash方法的实现。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">hash</span><span class="token punctuation">(</span><span class="token class-name">Object</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// hashSeed will be zero if alternative hashing is disabled.</span>    <span class="token keyword">return</span> hashSeed <span class="token operator">^</span> k<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>我们可以发现，很简单，相当于只是对k做了个简单的hash，取了一下其hashCode。而HashTable中也没有<code>indexOf</code>方法，取而代之的是这段代码：<code>int index = (hash &amp; 0x7FFFFFFF) % tab.length;</code>。也就是说，HashMap和HashTable对于计算数组下标这件事，采用了两种方法。HashMap采用的是位运算，而HashTable采用的是直接取模。</p><blockquote><p>为啥要把hash值和0x7FFFFFFF做一次按位与操作呢，主要是为了保证得到的index的第一位为0，也就是为了得到一个正数。因为有符号数第一位0代表正数，1代表负数。</p></blockquote><p>我们前面说过，HashMap之所以不用取模的原因是为了提高效率。有人认为，因为HashTable是个线程安全的类，本来就慢，所以Java并没有考虑效率问题，就直接使用取模算法了呢？但是其实并不完全是，Java这样设计还是有一定的考虑在的，虽然这样效率确实是会比HashMap慢一些。</p><p>其实，HashTable采用简单的取模是有一定的考虑在的。这就要涉及到HashTable的构造函数和扩容函数了。由于篇幅有限，这里就不贴代码了，直接给出结论：</p><blockquote><p>HashTable默认的初始大小为11，之后每次扩充为原来的2n+1。</p><p>也就是说，HashTable的链表数组的默认大小是一个素数、奇数。之后的每次扩充结果也都是奇数。</p><p>由于HashTable会尽量使用素数、奇数作为容量的大小。当哈希表的大小为素数时，简单的取模哈希的结果会更加均匀。（这个是可以证明出来的，由于不是本文重点，暂不详细介绍，可参考：<a href="http://zhaox.github.io/algorithm/2015/06/29/hash%EF%BC%89">http://zhaox.github.io/algorithm/2015/06/29/hash）</a></p></blockquote><p>至此，我们看完了Java 7中HashMap和HashTable中对于hash的实现，我们来做个简单的总结。</p><ul><li>HashMap默认的初始化大小为16，之后每次扩充为原来的2倍。</li><li>HashTable默认的初始大小为11，之后每次扩充为原来的2n+1。</li><li>当哈希表的大小为素数时，简单的取模哈希的结果会更加均匀，所以单从这一点上看，HashTable的哈希表大小选择，似乎更高明些。因为hash结果越分散效果越好。</li><li>在取模计算时，如果模数是2的幂，那么我们可以直接使用位运算来得到结果，效率要大大高于做除法。所以从hash计算的效率上，又是HashMap更胜一筹。</li><li>但是，HashMap为了提高效率使用位运算代替哈希，这又引入了哈希分布不均匀的问题，所以HashMap为解决这问题，又对hash算法做了一些改进，进行了扰动计算。</li></ul><h3 id="4-ConcurrentHashMap-In-Java-7"><a href="#4-ConcurrentHashMap-In-Java-7" class="headerlink" title="4.ConcurrentHashMap In Java 7"></a>4.ConcurrentHashMap In Java 7</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">hash</span><span class="token punctuation">(</span><span class="token class-name">Object</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> h <span class="token operator">=</span> hashSeed<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">0</span> <span class="token operator">!=</span> h<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>k <span class="token keyword">instanceof</span> <span class="token class-name">String</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token class-name"><span class="token namespace">sun<span class="token punctuation">.</span>misc<span class="token punctuation">.</span></span>Hashing</span><span class="token punctuation">.</span><span class="token function">stringHash32</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">)</span> k<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    h <span class="token operator">^=</span> k<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// Spread bits to regularize both segment and index locations,</span>    <span class="token comment">// using variant of single-word Wang/Jenkins hash.</span>    h <span class="token operator">+=</span> <span class="token punctuation">(</span>h <span class="token operator">&lt;&lt;</span>  <span class="token number">15</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token number">0xffffcd7d</span><span class="token punctuation">;</span>    h <span class="token operator">^=</span> <span class="token punctuation">(</span>h <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    h <span class="token operator">+=</span> <span class="token punctuation">(</span>h <span class="token operator">&lt;&lt;</span>   <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    h <span class="token operator">^=</span> <span class="token punctuation">(</span>h <span class="token operator">&gt;&gt;&gt;</span>  <span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    h <span class="token operator">+=</span> <span class="token punctuation">(</span>h <span class="token operator">&lt;&lt;</span>   <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">(</span>h <span class="token operator">&lt;&lt;</span> <span class="token number">14</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> h <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token punctuation">(</span>hash <span class="token operator">&gt;&gt;&gt;</span> segmentShift<span class="token punctuation">)</span> <span class="token operator">&amp;</span> segmentMask<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面这段关于ConcurrentHashMap的hash实现其实和HashMap如出一辙。都是通过位运算代替取模，然后再对hashcode进行扰动。区别在于，ConcurrentHashMap 使用了一种变种的Wang/Jenkins 哈希算法，其主要母的也是为了把高位和低位组合在一起，避免发生冲突。至于为啥不和HashMap采用同样的算法进行扰动，我猜这只是程序员自由意志的选择吧。至少我目前没有办法证明哪个更优。</p><h3 id="5-HashMap-In-Java-8"><a href="#5-HashMap-In-Java-8" class="headerlink" title="5.HashMap In Java 8"></a>5.HashMap In Java 8</h3><p>在Java 8 之前，HashMap和其他基于map的类都是通过链地址法解决冲突，它们使用单向链表来存储相同索引值的元素。在最坏的情况下，这种方式会将HashMap的get方法的性能从<code>O(1)</code>降低到<code>O(n)</code>。为了解决在频繁冲突时hashmap性能降低的问题，Java 8中使用平衡树来替代链表存储冲突的元素。这意味着我们可以将最坏情况下的性能从<code>O(n)</code>提高到<code>O(logn)</code>。关于HashMap在Java 8中的优化，我后面会有文章继续深入介绍。</p><p>如果恶意程序知道我们用的是Hash算法，则在纯链表情况下，它能够发送大量请求导致哈希碰撞，然后不停访问这些key导致HashMap忙于进行线性查找，最终陷入瘫痪，即形成了拒绝服务攻击（DoS）。</p><p>关于Java 8中的hash函数，原理和Java 7中基本类似。Java 8中这一步做了优化，只做一次16位右位移异或混合，而不是四次，但原理是不变的。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">hash</span><span class="token punctuation">(</span><span class="token class-name">Object</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> h<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>key <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> <span class="token punctuation">(</span>h <span class="token operator">=</span> key<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>在JDK1.8的实现中，优化了高位运算的算法，通过hashCode()的高16位异或低16位实现的：(h = k.hashCode()) ^ (h &gt;&gt;&gt; 16)，主要是从速度、功效、质量来考虑的。以上方法得到的int的hash值，然后再通过<code>h &amp; (table.length -1)</code>来得到该对象在数据中保存的位置。</p><p>HashTable In Java 8</p><p>在Java 8的HashTable中，已经不在有hash方法了。但是哈希的操作还是在的，比如在put方法中就有如下实现：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">int</span> hash <span class="token operator">=</span> key<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token punctuation">(</span>hash <span class="token operator">&amp;</span> <span class="token number">0x7FFFFFFF</span><span class="token punctuation">)</span> <span class="token operator">%</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这其实和Java 7中的实现几乎无差别，就不做过多的介绍了。</p><h3 id="6-ConcurrentHashMap-In-Java-8"><a href="#6-ConcurrentHashMap-In-Java-8" class="headerlink" title="6.ConcurrentHashMap In Java 8"></a>6.ConcurrentHashMap In Java 8</h3><p>Java 8 里面的求hash的方法从hash改为了spread。实现方式如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">spread</span><span class="token punctuation">(</span><span class="token keyword">int</span> h<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>h <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> HASH_BITS<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Java 8的ConcurrentHashMap同样是通过Key的哈希值与数组长度取模确定该Key在数组中的索引。同样为了避免不太好的Key的hashCode设计，它通过如下方法计算得到Key的最终哈希值。不同的是，Java 8的ConcurrentHashMap作者认为引入红黑树后，即使哈希冲突比较严重，寻址效率也足够高，所以作者并未在哈希值的计算上做过多设计，只是将Key的hashCode值与其高16位作异或并保证最高位为0（从而保证最终结果为正整数）。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Arrays.sort底层源码</title>
      <link href="2021/04/01/arrays-sort-di-ceng-yuan-ma/"/>
      <url>2021/04/01/arrays-sort-di-ceng-yuan-ma/</url>
      
        <content type="html"><![CDATA[<h1 id="Java的Arrays-sort-方法到底用的什么排序算法"><a href="#Java的Arrays-sort-方法到底用的什么排序算法" class="headerlink" title="Java的Arrays.sort()方法到底用的什么排序算法"></a>Java的Arrays.sort()方法到底用的什么排序算法</h1><p>数组一进来，会碰到第一个阀值QUICKSORT_THRESHOLD（286），注解上说，小过这个阀值的进入Quicksort （快速排序），其实并不全是，点进去sort(a, left, right, true);方法：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// Use Quicksort on small arrays</span><span class="token keyword">if</span> <span class="token punctuation">(</span>right <span class="token operator">-</span> left <span class="token operator">&lt;</span> QUICKSORT_THRESHOLD<span class="token punctuation">)</span><span class="token punctuation">{</span>       <span class="token comment">//QUICKSORT_THRESHOLD = 286</span>        <span class="token function">sort</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> left<span class="token punctuation">,</span> right<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="1-元素少于47用插入排序"><a href="#1-元素少于47用插入排序" class="headerlink" title="1. 元素少于47用插入排序"></a>1. 元素少于47用插入排序</h2><p>点进去后我们看到第二个阀值INSERTION_SORT_THRESHOLD（47），如果元素少于47这个阀值，就用插入排序，往下看确实如此：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// Use insertion sort on tiny arrays</span><span class="token keyword">if</span> <span class="token punctuation">(</span>length <span class="token operator">&lt;</span> INSERTION_SORT_THRESHOLD<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>leftmost<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/* * Traditional (without sentinel) insertion sort, * optimized for server VM, is used in case of * the leftmost part. */</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> left<span class="token punctuation">,</span> j <span class="token operator">=</span> i<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> right<span class="token punctuation">;</span> j <span class="token operator">=</span> <span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">{</span>     <span class="token keyword">int</span> ai <span class="token operator">=</span> a<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>     <span class="token keyword">while</span> <span class="token punctuation">(</span>ai <span class="token operator">&lt;</span> a<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span>     <span class="token punctuation">{</span>          a<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>          <span class="token keyword">if</span> <span class="token punctuation">(</span>j<span class="token operator">--</span> <span class="token operator">==</span> left<span class="token punctuation">)</span>          <span class="token punctuation">{</span>               <span class="token keyword">break</span><span class="token punctuation">;</span>           <span class="token punctuation">}</span>      <span class="token punctuation">}</span>      a<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> ai<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-快速排序（Quick-Sort）47-286"><a href="#2-快速排序（Quick-Sort）47-286" class="headerlink" title="2. 快速排序（Quick Sort）47-286"></a>2. 快速排序（Quick Sort）47-286</h2><p>　　至于大过INSERTION_SORT_THRESHOLD（47）的，用一种快速排序的方法：</p><p>　　1.从数列中挑出五个元素，称为 “基准”（pivot）；</p><p>　　2.重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</p><p>　　3.递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。</p><p>这是少于阀值QUICKSORT_THRESHOLD（286）的两种情况，至于大于286的，它会进入归并排序（Merge Sort），但在此之前，它有个小动作：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// Check if the array is nearly sorted</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> left<span class="token punctuation">;</span> k <span class="token operator">&lt;</span> right<span class="token punctuation">;</span> run<span class="token punctuation">[</span>count<span class="token punctuation">]</span> <span class="token operator">=</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">&lt;</span> a<span class="token punctuation">[</span>k <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// ascending</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">++</span>k <span class="token operator">&lt;=</span> right <span class="token operator">&amp;&amp;</span> a<span class="token punctuation">[</span>k <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&lt;=</span> a<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">&gt;</span> a<span class="token punctuation">[</span>k <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// descending</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">++</span>k <span class="token operator">&lt;=</span> right <span class="token operator">&amp;&amp;</span> a<span class="token punctuation">[</span>k <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&gt;=</span> a<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> lo <span class="token operator">=</span> run<span class="token punctuation">[</span>count<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> hi <span class="token operator">=</span> k<span class="token punctuation">;</span> <span class="token operator">++</span>lo <span class="token operator">&lt;</span> <span class="token operator">--</span>hi<span class="token punctuation">;</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">int</span> t <span class="token operator">=</span> a<span class="token punctuation">[</span>lo<span class="token punctuation">]</span><span class="token punctuation">;</span> a<span class="token punctuation">[</span>lo<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>hi<span class="token punctuation">]</span><span class="token punctuation">;</span> a<span class="token punctuation">[</span>hi<span class="token punctuation">]</span> <span class="token operator">=</span> t<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token comment">// equal</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> m <span class="token operator">=</span> MAX_RUN_LENGTH<span class="token punctuation">;</span> <span class="token operator">++</span>k <span class="token operator">&lt;=</span> right <span class="token operator">&amp;&amp;</span> a<span class="token punctuation">[</span>k <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> a<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">--</span>m <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token function">sort</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> left<span class="token punctuation">,</span> right<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">return</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment">/*         * The array is not highly structured,         * use Quicksort instead of merge sort.         */</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">++</span>count <span class="token operator">==</span> MAX_RUN_COUNT<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">sort</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> left<span class="token punctuation">,</span> right<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里主要作用是看他数组具不具备结构：实际逻辑是分组排序，每降序为一个组，像1,9,8,7,6,8。9到6是降序，为一个组，然后把降序的一组排成升序：1,6,7,8,9,8。然后最后的8后面继续往后面找。</p><p>　　每遇到这样一个降序组，++count，当count大于MAX_RUN_COUNT（67），被判断为这个数组不具备结构（也就是这数据时而升时而降），然后送给之前的sort(里面的快速排序)的方法（The array is not highly structured,use Quicksort instead of merge sort.）</p><p>　　如果count少于MAX_RUN_COUNT（67）的，说明这个数组还有点结构，就继续往下走下面的归并排序。</p><p>总结：</p><p>　　从上面分析，Arrays.sort并不是单一的排序，而是插入排序，快速排序，归并排序三种排序的组合，为此我画了个流程图：</p><p><img src="/2021/04/01/arrays-sort-di-ceng-yuan-ma/1701765-20191126153931611-191817306.png" alt="img"></p><h2 id="3-归并排序-gt-286"><a href="#3-归并排序-gt-286" class="headerlink" title="3. 归并排序 >286"></a>3. 归并排序 &gt;286</h2><p>O(nlogn)只代表增长量级，同一个量级前面的常数也可以不一样，不同数量下面的实际运算时间也可以不一样。</p><p>　　数量非常小的情况下（就像上面说到的，少于47的），插入排序等可能会比快速排序更快。 所以数组少于47的会进入插入排序。  </p><p>　　快排数据越无序越快（加入随机化后基本不会退化），平均常数最小，不需要额外空间，不稳定排序。</p><p>　　归排速度稳定，常数比快排略大，需要额外空间，稳定排序。</p><p>　　所以大于或等于47或少于286会进入快排，而在大于或等于286后，会有个小动作：“// Check if the array is nearly sorted”。这里第一个作用是先梳理一下数据方便后续的归并排序，第二个作用就是即便大于286，但在降序组太多的时候（被判断为没有结构的数据，The array is not highly structured,use Quicksort instead of merge sort.），要转回快速排序。</p><blockquote><p>在JDK 1.7中，<code>DualQuickSort</code>被首次引入，在1.8中做了一些优化，具体的变化我这里就不再对比了，有兴趣的同学可以去自己对比一下。接下来的分析基于JDK 1.8.1 u121的代码</p></blockquote><h4 id="3-1双轴快排-DualQuickSort"><a href="#3-1双轴快排-DualQuickSort" class="headerlink" title="3.1双轴快排 - DualQuickSort"></a>3.1双轴快排 - <code>DualQuickSort</code></h4><blockquote><p>入口函数是<code>+Arrays.sort(int[] a)</code>，涉及到的函数有</p><ul><li><code>~DualPivotQuicksort.sort(int[] a, int left, int right, int[] work, int workBase, int workLen)</code></li><li><code>-DualPivotQuicksort.sort(int[] a, int left, int right, boolean leftmost)</code></li></ul></blockquote><p>实际的执行函数有两个，我们依次来看。</p><p>双轴快排对外入口 - <code>~DualPivotQuicksort.sort(int[] a, int left, int right, int[] work, int workBase, int workLen)</code></p><p>我们先看一下它的调用流程</p><p><img src="/2021/04/01/arrays-sort-di-ceng-yuan-ma/1.PNG"></p><p>从图中可以看出，虽然本身的类名是双轴快排(<code>DualPivotQuicksort</code>)。但是还会综合其它排序方法。比如上图中，如果检测出数组比较有序的情况下，则会使用<code>merge sort</code>的思路来进行处理。</p><p>接下来，我们来看一下图中<code>E</code>, <code>J</code>是如何实现的。</p><p>我们先参考一下这部分的原始代码</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/* * Index run[i] is the start of i-th run * (ascending or descending sequence). */</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> run <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>MAX_RUN_COUNT <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// MAX_RUN_COUNT = 67</span><span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> run<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> left<span class="token punctuation">;</span><span class="token comment">// Check if the array is nearly sorted</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> left<span class="token punctuation">;</span> k <span class="token operator">&lt;</span> right<span class="token punctuation">;</span> run<span class="token punctuation">[</span>count<span class="token punctuation">]</span> <span class="token operator">=</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">&lt;</span> a<span class="token punctuation">[</span>k <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// ascending</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">++</span>k <span class="token operator">&lt;=</span> right <span class="token operator">&amp;&amp;</span> a<span class="token punctuation">[</span>k <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&lt;=</span> a<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">&gt;</span> a<span class="token punctuation">[</span>k <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// descending</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">++</span>k <span class="token operator">&lt;=</span> right <span class="token operator">&amp;&amp;</span> a<span class="token punctuation">[</span>k <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&gt;=</span> a<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> lo <span class="token operator">=</span> run<span class="token punctuation">[</span>count<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> hi <span class="token operator">=</span> k<span class="token punctuation">;</span> <span class="token operator">++</span>lo <span class="token operator">&lt;</span> <span class="token operator">--</span>hi<span class="token punctuation">;</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> t <span class="token operator">=</span> a<span class="token punctuation">[</span>lo<span class="token punctuation">]</span><span class="token punctuation">;</span> a<span class="token punctuation">[</span>lo<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>hi<span class="token punctuation">]</span><span class="token punctuation">;</span> a<span class="token punctuation">[</span>hi<span class="token punctuation">]</span> <span class="token operator">=</span> t<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token comment">// equal</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> m <span class="token operator">=</span> MAX_RUN_LENGTH<span class="token punctuation">;</span> <span class="token operator">++</span>k <span class="token operator">&lt;=</span> right <span class="token operator">&amp;&amp;</span> a<span class="token punctuation">[</span>k <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> a<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment">// MAX_RUN_LENGTH = 33</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">--</span>m <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">sort</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> left<span class="token punctuation">,</span> right<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">return</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment">/*     * The array is not highly structured,     * use Quicksort instead of merge sort.     */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">++</span>count <span class="token operator">==</span> MAX_RUN_COUNT<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">sort</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> left<span class="token punctuation">,</span> right<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment">// Check special cases</span><span class="token comment">// Implementation note: variable "right" is increased by 1.</span><span class="token keyword">if</span> <span class="token punctuation">(</span>run<span class="token punctuation">[</span>count<span class="token punctuation">]</span> <span class="token operator">==</span> right<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// The last run contains one element</span>    run<span class="token punctuation">[</span><span class="token operator">++</span>count<span class="token punctuation">]</span> <span class="token operator">=</span> right<span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// The array is already sorted</span>    <span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在上述代码中，搞清楚变量<code>run</code>, <code>count</code>, <code>k</code>, <code>m</code>这4个变量的含义就比较容易理解代码的实现了。</p><p>我理解下来，它们分别的含义如下</p><ul><li><code>run</code> - 记录每一个连续区间，对应的开始元素的下标</li><li><code>count</code> - 记录到目前为止，已经检测到有多少个递增的区间，同时也是for循环的次数。注意其值从0开始，所以第1个区间的范围是<code>[run[0], run[1])</code>，以此类推</li><li><code>k</code> - 游标，整个for循环中，指向当前所遍历到的元素</li><li><code>m</code> - 用于辅助判断一段连续相等的元素区间的的长度是否已经达到指定的上限</li></ul><p>上面几个变量虽然用文字解释了一下，依然比较晦涩。这里我画一个简单的示意图，你就明白到底是如何检测是否有序，以及所谓有序的标准是什么了。</p><p><img src="/2021/04/01/arrays-sort-di-ceng-yuan-ma/2.PNG"></p><blockquote><p>至于两个常量<code>MAX_RUN_COUNT</code>与<code>MAX_RUN_LENGTH</code>的值是怎么来的，猜测依然是经验值吧。有清楚的同学可以告诉我。</p></blockquote><p>for循环开始有<code>if-elseif-else</code>的语句。是把当前元素与下一个元素做比较，将结果分成了3种情况</p><ul><li>当前元素 &lt; 下一个元素</li><li>当前元素 &gt; 下一个元素</li><li>当前元素 = 下一个元素</li></ul><p>其中<code>&lt;</code>这种情况最简单，已经是期望的升序区间。该block里边的<code>while</code>循环则用于向右移动游标，直到找到第一个降序的元素。即</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">++</span>k <span class="token operator">&lt;=</span> right <span class="token operator">&amp;&amp;</span> a<span class="token punctuation">[</span>k <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&lt;=</span> a<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>&gt;</code>这种情况相对复杂一些，这个block里边是找一个连续的降序区间。然后将该区间从两端到中间的方向首尾交换元素，从而将原本的降序区间转变成一个升序区间。即</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">++</span>k <span class="token operator">&lt;=</span> right <span class="token operator">&amp;&amp;</span> a<span class="token punctuation">[</span>k <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&gt;=</span> a<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> lo <span class="token operator">=</span> run<span class="token punctuation">[</span>count<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> hi <span class="token operator">=</span> k<span class="token punctuation">;</span> <span class="token operator">++</span>lo <span class="token operator">&lt;</span> <span class="token operator">--</span>hi<span class="token punctuation">;</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> t <span class="token operator">=</span> a<span class="token punctuation">[</span>lo<span class="token punctuation">]</span><span class="token punctuation">;</span> a<span class="token punctuation">[</span>lo<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>hi<span class="token punctuation">]</span><span class="token punctuation">;</span> a<span class="token punctuation">[</span>hi<span class="token punctuation">]</span> <span class="token operator">=</span> t<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><code>=</code>这种情况下有一个特殊的处理，当侦测到连续相等区间的长度<code>&gt;=33</code>的时候，即上图中的某个区间<code>有大量连续相等元素</code>的时候，停止后续的侦测，直接转用<code>双轴快排</code>。代码如下</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> m <span class="token operator">=</span> MAX_RUN_LENGTH<span class="token punctuation">;</span> <span class="token operator">++</span>k <span class="token operator">&lt;=</span> right <span class="token operator">&amp;&amp;</span> a<span class="token punctuation">[</span>k <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> a<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">--</span>m <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">sort</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> left<span class="token punctuation">,</span> right<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在for循环接下来的逻辑里，判断<code>count</code>的值是否已经达到<code>67</code>这个上限。即我们到目前为止已经找出了<code>67</code>个递增的区间，但是还没有遍历结束，那么就认为当前数组<code>不是很有序</code>，那么就会转用<code>双轴快排</code>进行处理。代码如下</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/* * The array is not highly structured, * use Quicksort instead of merge sort. */</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">++</span>count <span class="token operator">==</span> MAX_RUN_COUNT<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">sort</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> left<span class="token punctuation">,</span> right<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>for循环结束后，如果没有return，那说明递增区间划分完成。接下来的代码比较简单</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// Check special cases</span><span class="token comment">// Implementation note: variable "right" is increased by 1.</span><span class="token keyword">if</span> <span class="token punctuation">(</span>run<span class="token punctuation">[</span>count<span class="token punctuation">]</span> <span class="token operator">==</span> right<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// The last run contains one element</span>    run<span class="token punctuation">[</span><span class="token operator">++</span>count<span class="token punctuation">]</span> <span class="token operator">=</span> right<span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// The array is already sorted</span>    <span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>else-if</code> 的条件判断 <code>count == 1</code>说明只有一个递增区间，即数组已经完全有序，直接return，比较很容易理解。</p><p>但是与其对应的<code>if</code>逻辑不太容易理解，有些文章解读为添加一个哨兵元素，但是仔细阅读下来其实并不是这样的。就像注释里边说的，它是用于处理特殊情况 - 最后一个区间只包括一个元素。</p><p>我们仔细观察整个for循环可以发现，每执行完1次循环，count计数加1，run[count]则记录的是刚刚测量过的区间的结束位置(不包含)。当最后一个区间只有一个元素的时候，run[count]其实记录的是最后一个区间的开始的位置(包含)，没有记录其对应的结束位置，即<code>right+1</code>。所以这里的逻辑是对种情况的补充处理，并不是什么哨兵。</p><h4 id="3-2-J"><a href="#3-2-J" class="headerlink" title="3.2 J"></a>3.2 J</h4><p>这部分代码是将前边检测出来的升序区间，即一个一个有序小数组，合并最终成为一个有序的大数组。所以其实它是<code>merge sort</code>中合并函数的<code>迭代版本</code>。</p><p>它简单可以分成两部分逻辑：</p><ul><li>确定并创建临时数组<code>b</code>，以供合并时使用</li><li>迭代而非递归进行合并</li></ul><p>在写文章的时候我也参考过其他人的分析，但很多都是一笔带过或者语焉不详，并没有讲得很清楚，所以我准备自己把它搞明白。</p><p>我们先来看看第一部分 - 确定并创建临时数组<code>b</code>，以供合并时使用</p><p>这里是原始代码</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// Determine alternation base for merge</span><span class="token keyword">byte</span> odd <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;&lt;=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> count<span class="token punctuation">;</span> odd <span class="token operator">^=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">;</span><span class="token comment">// Use or create temporary array b for merging</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> b<span class="token punctuation">;</span>                 <span class="token comment">// temp array; alternates with a</span><span class="token keyword">int</span> ao<span class="token punctuation">,</span> bo<span class="token punctuation">;</span>              <span class="token comment">// array offsets from 'left'</span><span class="token keyword">int</span> blen <span class="token operator">=</span> right <span class="token operator">-</span> left<span class="token punctuation">;</span> <span class="token comment">// space needed for b</span><span class="token keyword">if</span> <span class="token punctuation">(</span>work <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> workLen <span class="token operator">&lt;</span> blen <span class="token operator">||</span> workBase <span class="token operator">+</span> blen <span class="token operator">&gt;</span> work<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>    work <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>blen<span class="token punctuation">]</span><span class="token punctuation">;</span>    workBase <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">if</span> <span class="token punctuation">(</span>odd <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">arraycopy</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> left<span class="token punctuation">,</span> work<span class="token punctuation">,</span> workBase<span class="token punctuation">,</span> blen<span class="token punctuation">)</span><span class="token punctuation">;</span>    b <span class="token operator">=</span> a<span class="token punctuation">;</span>    bo <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    a <span class="token operator">=</span> work<span class="token punctuation">;</span>    ao <span class="token operator">=</span> workBase <span class="token operator">-</span> left<span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>    b <span class="token operator">=</span> work<span class="token punctuation">;</span>    ao <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    bo <span class="token operator">=</span> workBase <span class="token operator">-</span> left<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上边的代码中最让人困惑的可能就是变量<code>odd</code>的含义了。</p><p>经过多次调试，明白了作者的意图是想计算出针对<code>count</code>个有序的子数组，需要循环合并多少次才能变为1个大数组，是奇数次还是偶数次。</p><p>为什么只关心奇偶呢？</p><p>我们先看下合并的实现逻辑，再回过来思考这个问题。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// Merging</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> last<span class="token punctuation">;</span> count <span class="token operator">&gt;</span> <span class="token number">1</span><span class="token punctuation">;</span> count <span class="token operator">=</span> last<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token punctuation">(</span>last <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">;</span> k <span class="token operator">&lt;=</span> count<span class="token punctuation">;</span> k <span class="token operator">+=</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> hi <span class="token operator">=</span> run<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">,</span> mi <span class="token operator">=</span> run<span class="token punctuation">[</span>k <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> run<span class="token punctuation">[</span>k <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> p <span class="token operator">=</span> i<span class="token punctuation">,</span> q <span class="token operator">=</span> mi<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> hi<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>q <span class="token operator">&gt;=</span> hi <span class="token operator">||</span> p <span class="token operator">&lt;</span> mi <span class="token operator">&amp;&amp;</span> a<span class="token punctuation">[</span>p <span class="token operator">+</span> ao<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> a<span class="token punctuation">[</span>q <span class="token operator">+</span> ao<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                b<span class="token punctuation">[</span>i <span class="token operator">+</span> bo<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>p<span class="token operator">++</span> <span class="token operator">+</span> ao<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                b<span class="token punctuation">[</span>i <span class="token operator">+</span> bo<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>q<span class="token operator">++</span> <span class="token operator">+</span> ao<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        run<span class="token punctuation">[</span><span class="token operator">++</span>last<span class="token punctuation">]</span> <span class="token operator">=</span> hi<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>count <span class="token operator">&amp;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> right<span class="token punctuation">,</span> lo <span class="token operator">=</span> run<span class="token punctuation">[</span>count <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token operator">--</span>i <span class="token operator">&gt;=</span> lo<span class="token punctuation">;</span>             b<span class="token punctuation">[</span>i <span class="token operator">+</span> bo<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>i <span class="token operator">+</span> ao<span class="token punctuation">]</span>            <span class="token punctuation">)</span><span class="token punctuation">;</span>        run<span class="token punctuation">[</span><span class="token operator">++</span>last<span class="token punctuation">]</span> <span class="token operator">=</span> right<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> t <span class="token operator">=</span> a<span class="token punctuation">;</span> a <span class="token operator">=</span> b<span class="token punctuation">;</span> b <span class="token operator">=</span> t<span class="token punctuation">;</span>    <span class="token keyword">int</span> o <span class="token operator">=</span> ao<span class="token punctuation">;</span> ao <span class="token operator">=</span> bo<span class="token punctuation">;</span> bo <span class="token operator">=</span> o<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里从外到内共有3层循环，其中</p><ul><li>最内层循环 - 是将两个有序的子数组合并成一个有序的数组，结果会被写入到临时数组<code>b</code>中</li><li>中间层循环 - 将目前的子数组序列两两合并</li><li>最外层循环 - 中间层循环执行完毕后，如果有<code>落单</code>的子数组，则直接将其复制过来(参考<code>(count &amp; 1) != 0</code>处的逻辑)，然后交换<code>a</code>/<code>b</code>数组的引用。<strong>注意，这是执行过一次<code>循环合并</code>的效果 - 即将原始的<code>count</code>个子数组“压缩合并”为<code>(count+1)/2</code>个数组</strong>。当最后<code>count</code>变为<code>1</code>的时候，整个循环结束，完成排序。</li></ul><p>从上面的分析中可以发现，每执行1次<code>循环合并</code>，<code>a</code>/<code>b</code>数组的引用会交换1次。我们把上边的整个合并过程当中<code>循环合并</code>的次数记为<code>loop_merge_times</code>，那么在这个过程当中<code>a</code>/<code>b</code>数组的引用共交换了<code>loop_merge_times</code>次。</p><p>引用交换1次意味着什么呢？</p><blockquote><p>主要是为下一次<code>循环合并</code>做准备，因为本次<code>循环合并</code>是把结果写入了临时数组<code>b</code>中，那么交换<code>a</code>/<code>b</code>的引用之后，下次<code>循环合并</code>就会把结果写入真正的数组<code>a</code>中。这里的“真正”指的是形参<code>a</code>所对应的实参。(这里有点绕，可以仔细体会一下)</p><p>所以，交换偶数次引用后，合并后的结果是写入到了原始的<code>a</code>中，这也是我们所期望的。</p></blockquote><p>经过上面的分析，我们就明白了合并之前计算<code>odd</code>的作用了。<code>loop_merge_times</code>的值是一个<code>&gt;=1</code>的正整数，当它为偶数时，我们不需要做什么额外处理。但是为奇数时，我们需要怎么处理才能保证最后合并完成之后<code>a</code>存储的是最终合并的结果呢？</p><p>答案也很简单，我们在合并之前做一次预处理，先将<code>a</code>/<code>b</code>的引用交换1次就可以满足需求了。</p><p>但是合并之前的代码中的<code>odd</code>其实记录的是比实际的<code>循环合并</code>少1次的结果。因为终止条件<code>(n &lt;&lt;= 1) &lt; count</code>终止后，仍需要再进行1次<code>循环合并</code>，才会完成全部合并。所以在代码里边当<code>odd == 0</code>时才执行<code>a</code>/<code>b</code>的引用交换。</p><p>我们可以将此处的逻辑改写一下，更加便于理解</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// Determine alternation base for merge</span><span class="token keyword">byte</span> odd <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">int</span> loop_merge_times <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;&lt;=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> count<span class="token punctuation">;</span> odd <span class="token operator">^=</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">++</span>loop_merge_times<span class="token punctuation">)</span> <span class="token punctuation">;</span>loop_merge_times <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>loop_merge_times <span class="token operator">&amp;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// swap a and b</span><span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>    <span class="token comment">// ...</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>关于<code>loop_merge_times</code>的计算，也可以使用数学公式直接计算出来 - 将<code>log2(count)</code>的结果向上取整。</p><p>为什么作者使用位运算而不是直接求解数值的方法？原因还是源自对速度的追求。你可以使用下面的代码对比一下两者的运行时间。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">compareCalcSpeed</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">66</span><span class="token punctuation">;</span>    <span class="token keyword">byte</span> odd <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment">// Approach 1</span>    <span class="token keyword">long</span> start <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">nanoTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;&lt;=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> count<span class="token punctuation">;</span> odd <span class="token operator">^=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">;</span>    odd <span class="token operator">^=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">long</span> period <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">nanoTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> start<span class="token punctuation">;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"loop time: %d ns\n"</span><span class="token punctuation">,</span> period<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// Approach 2</span>    start <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">nanoTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">double</span> logValue <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>count<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> mergeLoopTimes <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">ceil</span><span class="token punctuation">(</span>logValue<span class="token punctuation">)</span><span class="token punctuation">;</span>    period <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">nanoTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> start<span class="token punctuation">;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"calc time: %d ns\n"</span><span class="token punctuation">,</span> period<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>双轴快排函数 - <code>-DualPivotQuicksort.sort(int[] a, int left, int right, boolean leftmost)</code></p><p>函数<code>~DualPivotQuicksort.sort(int[] a, int left, int right, boolean leftmost)</code>的调用流程</p><p><img src="/2021/04/01/arrays-sort-di-ceng-yuan-ma/3.PNG"></p><p>前边分析了那么多，其实还没有真正到<code>双轴快排</code>，上图才是<code>双轴快排</code>代码所在的地方。</p><p>接下来，我们分别看看<code>C</code>, <code>D</code>, <code>H</code>, <code>G</code>是怎么实现的。</p><h3 id="3-3-代码实现"><a href="#3-3-代码实现" class="headerlink" title="3.3 代码实现"></a>3.3 代码实现</h3><p>这里的插入排序会分成两种情况</p><ul><li>要排序的<code>[left, right]</code>区间是数组<code>a</code>的最左侧部分，即<code>left==0</code></li><li>另一种就是要排序的<code>[left, right]</code>区间在数组<code>a</code>的非最左侧部分，即<code>left&gt;0</code></li></ul><p>第一种情况的代码比较简单，如下</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/* * Traditional (without sentinel) insertion sort, * optimized for server VM, is used in case of * the leftmost part. */</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> left<span class="token punctuation">,</span> j <span class="token operator">=</span> i<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> right<span class="token punctuation">;</span> j <span class="token operator">=</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> ai <span class="token operator">=</span> a<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>ai <span class="token operator">&lt;</span> a<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        a<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>j<span class="token operator">--</span> <span class="token operator">==</span> left<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    a<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> ai<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>正如注释中所说的，使用<code>传统</code>的插入排序，即不使用<code>哨兵</code>。</p><p>同样的，我们搞明白变量<code>i</code>和<code>j</code>的作用之后代码就非常容易理解。</p><ul><li><code>i</code> - 该变量将<code>[left, right]</code>区间划分为两部分 - 已排序区间<code>[left, i]</code>与未排序区间<code>(i, right]</code></li><li><code>j</code> - 游标，从已排序区间<code>[left, i]</code>的最右侧开始，向左查找元素<code>a[i+1]</code>合适的位置；并且在查找的过程当中，依次将元素向右移动1位</li></ul><p>第二种情况的代码相比就复杂很多，如下</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/* * Skip the longest ascending sequence. */</span><span class="token keyword">do</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">&gt;=</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span><span class="token operator">++</span>left<span class="token punctuation">]</span> <span class="token operator">&gt;=</span> a<span class="token punctuation">[</span>left <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/* * Every element from adjoining part plays the role * of sentinel, therefore this allows us to avoid the * left range check on each iteration. Moreover, we use * the more optimized algorithm, so called pair insertion * sort, which is faster (in the context of Quicksort) * than traditional implementation of insertion sort. */</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> left<span class="token punctuation">;</span> <span class="token operator">++</span>left <span class="token operator">&lt;=</span> right<span class="token punctuation">;</span> k <span class="token operator">=</span> <span class="token operator">++</span>left<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> a1 <span class="token operator">=</span> a<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">,</span> a2 <span class="token operator">=</span> a<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>a1 <span class="token operator">&lt;</span> a2<span class="token punctuation">)</span> <span class="token punctuation">{</span>        a2 <span class="token operator">=</span> a1<span class="token punctuation">;</span> a1 <span class="token operator">=</span> a<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>a1 <span class="token operator">&lt;</span> a<span class="token punctuation">[</span><span class="token operator">--</span>k<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        a<span class="token punctuation">[</span>k <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    a<span class="token punctuation">[</span><span class="token operator">++</span>k <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> a1<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>a2 <span class="token operator">&lt;</span> a<span class="token punctuation">[</span><span class="token operator">--</span>k<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        a<span class="token punctuation">[</span>k <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    a<span class="token punctuation">[</span>k <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> a2<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> last <span class="token operator">=</span> a<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span>last <span class="token operator">&lt;</span> a<span class="token punctuation">[</span><span class="token operator">--</span>right<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    a<span class="token punctuation">[</span>right <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span>a<span class="token punctuation">[</span>right <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> last<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里使用一种改进的插入排序 - <code>成对插入排序(pair insertion sort)</code>的方法。</p><p>这个方法的基本思想是在普通插入排序的基础上</p><ol><li>1次从未排序区间取出2个元素 - <code>a1</code>和<code>a2</code>，并且保证<code>a1&gt;=a2</code>（即如果<code>a1&lt;a2</code>，则交换两者的值）</li><li>从右向左找到<code>a1</code>的合适位置；并且在查找的过程当中，依次将元素向右移动1位</li><li>然后从<code>a1</code>开始，继续向左找到<code>a2</code>的合适位置；同样，在查找的过程当中，依次将元素向右移动1位</li></ol><p>这里边的关键点在于(…, left)区间的值都是<code>&lt;a[left]</code>的，这也就是注释中所说的连接部分的每一个元素都天然扮演着哨兵的角色，所以我们不需要额外的去显式判断游标<code>k</code>是否已经移出了左边界。</p><h4 id="3-3-1-D"><a href="#3-3-1-D" class="headerlink" title="3.3.1 D"></a>3.3.1 D</h4><p>这部分的代码相对比较直观，如下</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// Inexpensive approximation of length / 7</span><span class="token keyword">int</span> seventh <span class="token operator">=</span> <span class="token punctuation">(</span>length <span class="token operator">&gt;&gt;</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">(</span>length <span class="token operator">&gt;&gt;</span> <span class="token number">6</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">/* * Sort five evenly spaced elements around (and including) the * center element in the range. These elements will be used for * pivot selection as described below. The choice for spacing * these elements was empirically determined to work well on * a wide variety of inputs. */</span><span class="token keyword">int</span> e3 <span class="token operator">=</span> <span class="token punctuation">(</span>left <span class="token operator">+</span> right<span class="token punctuation">)</span> <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// The midpoint</span><span class="token keyword">int</span> e2 <span class="token operator">=</span> e3 <span class="token operator">-</span> seventh<span class="token punctuation">;</span><span class="token keyword">int</span> e1 <span class="token operator">=</span> e2 <span class="token operator">-</span> seventh<span class="token punctuation">;</span><span class="token keyword">int</span> e4 <span class="token operator">=</span> e3 <span class="token operator">+</span> seventh<span class="token punctuation">;</span><span class="token keyword">int</span> e5 <span class="token operator">=</span> e4 <span class="token operator">+</span> seventh<span class="token punctuation">;</span><span class="token comment">// Sort these elements using insertion sort</span><span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>e2<span class="token punctuation">]</span> <span class="token operator">&lt;</span> a<span class="token punctuation">[</span>e1<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">int</span> t <span class="token operator">=</span> a<span class="token punctuation">[</span>e2<span class="token punctuation">]</span><span class="token punctuation">;</span> a<span class="token punctuation">[</span>e2<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>e1<span class="token punctuation">]</span><span class="token punctuation">;</span> a<span class="token punctuation">[</span>e1<span class="token punctuation">]</span> <span class="token operator">=</span> t<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>e3<span class="token punctuation">]</span> <span class="token operator">&lt;</span> a<span class="token punctuation">[</span>e2<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">int</span> t <span class="token operator">=</span> a<span class="token punctuation">[</span>e3<span class="token punctuation">]</span><span class="token punctuation">;</span> a<span class="token punctuation">[</span>e3<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>e2<span class="token punctuation">]</span><span class="token punctuation">;</span> a<span class="token punctuation">[</span>e2<span class="token punctuation">]</span> <span class="token operator">=</span> t<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">&lt;</span> a<span class="token punctuation">[</span>e1<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> a<span class="token punctuation">[</span>e2<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>e1<span class="token punctuation">]</span><span class="token punctuation">;</span> a<span class="token punctuation">[</span>e1<span class="token punctuation">]</span> <span class="token operator">=</span> t<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>e4<span class="token punctuation">]</span> <span class="token operator">&lt;</span> a<span class="token punctuation">[</span>e3<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">int</span> t <span class="token operator">=</span> a<span class="token punctuation">[</span>e4<span class="token punctuation">]</span><span class="token punctuation">;</span> a<span class="token punctuation">[</span>e4<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>e3<span class="token punctuation">]</span><span class="token punctuation">;</span> a<span class="token punctuation">[</span>e3<span class="token punctuation">]</span> <span class="token operator">=</span> t<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">&lt;</span> a<span class="token punctuation">[</span>e2<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> a<span class="token punctuation">[</span>e3<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>e2<span class="token punctuation">]</span><span class="token punctuation">;</span> a<span class="token punctuation">[</span>e2<span class="token punctuation">]</span> <span class="token operator">=</span> t<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">&lt;</span> a<span class="token punctuation">[</span>e1<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> a<span class="token punctuation">[</span>e2<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>e1<span class="token punctuation">]</span><span class="token punctuation">;</span> a<span class="token punctuation">[</span>e1<span class="token punctuation">]</span> <span class="token operator">=</span> t<span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>e5<span class="token punctuation">]</span> <span class="token operator">&lt;</span> a<span class="token punctuation">[</span>e4<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">int</span> t <span class="token operator">=</span> a<span class="token punctuation">[</span>e5<span class="token punctuation">]</span><span class="token punctuation">;</span> a<span class="token punctuation">[</span>e5<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>e4<span class="token punctuation">]</span><span class="token punctuation">;</span> a<span class="token punctuation">[</span>e4<span class="token punctuation">]</span> <span class="token operator">=</span> t<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">&lt;</span> a<span class="token punctuation">[</span>e3<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> a<span class="token punctuation">[</span>e4<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>e3<span class="token punctuation">]</span><span class="token punctuation">;</span> a<span class="token punctuation">[</span>e3<span class="token punctuation">]</span> <span class="token operator">=</span> t<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">&lt;</span> a<span class="token punctuation">[</span>e2<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> a<span class="token punctuation">[</span>e3<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>e2<span class="token punctuation">]</span><span class="token punctuation">;</span> a<span class="token punctuation">[</span>e2<span class="token punctuation">]</span> <span class="token operator">=</span> t<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">&lt;</span> a<span class="token punctuation">[</span>e1<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> a<span class="token punctuation">[</span>e2<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>e1<span class="token punctuation">]</span><span class="token punctuation">;</span> a<span class="token punctuation">[</span>e1<span class="token punctuation">]</span> <span class="token operator">=</span> t<span class="token punctuation">;</span> <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中计算<code>1/7</code>的近似值的方法比较巧妙，使用位运算然后相加，比单纯的除法会快不少 <code>int seventh = (length &gt;&gt; 3) + (length &gt;&gt; 6) + 1</code></p><p>随后以中间点为中心，向左右依次各取2个点，共5个点。然后手动地使用插入排序对上边的5个点进行排序。</p><h4 id="3-3-2H"><a href="#3-3-2H" class="headerlink" title="3.3.2H"></a>3.3.2H</h4><p>我们先来看下这个方法里边的<code>单轴快排</code>的实现，与<code>JDK 1.6</code>中的实现又不一样，这里边的实现整体较为简单，也和我们在常见书籍/文章中的实现方法一致。</p><blockquote><p>关于<code>JDK 1.6</code>中的<code>单轴快排</code>的实现，可以参考我之前的分析文章 - <a href="https://www.imooc.com/article/296820">Java SDK中的排序算法小议 - 02 单轴快排</a></p></blockquote><p>我们看一下整体的实现代码，如下</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// Pointers</span><span class="token keyword">int</span> less  <span class="token operator">=</span> left<span class="token punctuation">;</span>  <span class="token comment">// The index of the first element of center part</span><span class="token keyword">int</span> great <span class="token operator">=</span> right<span class="token punctuation">;</span> <span class="token comment">// The index before the first element of right part</span><span class="token comment">/* * Use the third of the five sorted elements as pivot. * This value is inexpensive approximation of the median. */</span><span class="token keyword">int</span> pivot <span class="token operator">=</span> a<span class="token punctuation">[</span>e3<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">/* * Partitioning degenerates to the traditional 3-way * (or "Dutch National Flag") schema: * *   left part    center part              right part * +-------------------------------------------------+ * |  &lt; pivot  |   == pivot   |     ?    |  &gt; pivot  | * +-------------------------------------------------+ *              ^              ^        ^ *              |              |        | *             less            k      great * * Invariants: * *   all in (left, less)   &lt; pivot *   all in [less, k)     == pivot *   all in (great, right) &gt; pivot * * Pointer k is the first index of ?-part. */</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> less<span class="token punctuation">;</span> k <span class="token operator">&lt;=</span> great<span class="token punctuation">;</span> <span class="token operator">++</span>k<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">==</span> pivot<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">continue</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> ak <span class="token operator">=</span> a<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>ak <span class="token operator">&lt;</span> pivot<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// Move a[k] to left part</span>        a<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>less<span class="token punctuation">]</span><span class="token punctuation">;</span>        a<span class="token punctuation">[</span>less<span class="token punctuation">]</span> <span class="token operator">=</span> ak<span class="token punctuation">;</span>        <span class="token operator">++</span>less<span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token comment">// a[k] &gt; pivot - Move a[k] to right part</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>great<span class="token punctuation">]</span> <span class="token operator">&gt;</span> pivot<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token operator">--</span>great<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>great<span class="token punctuation">]</span> <span class="token operator">&lt;</span> pivot<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// a[great] &lt;= pivot</span>            a<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>less<span class="token punctuation">]</span><span class="token punctuation">;</span>            a<span class="token punctuation">[</span>less<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>great<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token operator">++</span>less<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token comment">// a[great] == pivot</span>            <span class="token comment">/*             * Even though a[great] equals to pivot, the             * assignment a[k] = pivot may be incorrect,             * if a[great] and pivot are floating-point             * zeros of different signs. Therefore in float             * and double sorting methods we have to use             * more accurate assignment a[k] = a[great].             */</span>            a<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> pivot<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        a<span class="token punctuation">[</span>great<span class="token punctuation">]</span> <span class="token operator">=</span> ak<span class="token punctuation">;</span>        <span class="token operator">--</span>great<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment">/* * Sort left and right parts recursively. * All elements from center part are equal * and, therefore, already sorted. */</span><span class="token function">sort</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> left<span class="token punctuation">,</span> less <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> leftmost<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">sort</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> great <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> right<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里的轴点直接使用前边计算并且排序后的中间点<code>a[e3]</code>，这部分代码里边出现了几个变量，我们分别看下它们的含义是什么</p><ul><li><code>less</code> - 初始值是待排序区间的左端点<code>left</code>，它是<code>&lt;pivot</code>与<code>=pivot</code>的连接点</li><li><code>great</code> - 初始值是待排序区间的右端点<code>right</code>，它是<code>=pivot</code>与<code>&gt;pivot</code>的连接点</li><li><code>k</code> - 游标，在<code>[less, great]</code>区间内移动</li><li><code>pivot</code> - 轴心点，值为<code>a[e3]</code></li></ul><p>前边的<code>for</code>循环会将数据分成3个区间，正如注释中所说的</p><ul><li><code>[left, less) &lt; pivot</code></li><li><code>[less, k) == pivot</code></li><li><code>(great, right] &gt; pivot</code></li></ul><p>在移动游标<code>k</code>的时候，我们将<code>a[k]</code>与<code>pivot</code>作比较，那么就有3种情况</p><ol><li><code>a[k]==pivot</code></li><li><code>a[k]&lt;pivot</code></li><li><code>a[k]&gt;pivot</code></li></ol><p>第1种情况比较简单，我们什么都不做，继续下一次循环。</p><p>第2种情况会将<code>a[k]</code>的值移动到左边，即将<code>a[k]</code>与<code>a[less]</code>进行交换，然后<code>++less</code>。</p><p>第3种情况会将<code>a[k]</code>的值移动到右边，即将<code>a[k]</code>与<code>a[great]</code>进行交换，然后<code>--great</code>。但是交换过来的<code>a[great]</code>我们需要考虑它和<code>pivot</code>的大小关系，所以同样又有了3种子情况</p><ol><li><code>a[great]&gt;pivot</code></li><li><code>a[great]&lt;pivot</code></li><li><code>a[great]=pivot</code></li></ol><p>针对子情况1，我们前边将<code>a[great]</code>直接交换过来是没有意义的。所以这里边有一个小技巧，我们先找到第1个<code>&lt;=pivot</code>的<code>a[great]</code>，再进行交换，就避免了这种情况的发生。代码如下</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">while</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>great<span class="token punctuation">]</span> <span class="token operator">&gt;</span> pivot<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token operator">--</span>great<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>针对子情况2，我们需要将交换过来的<code>a[great]</code>(<code>a[k]</code>)与<code>a[less]</code>进行交换，然后<code>++less</code>。其实相当于前边的情况2。</p><p>针对子情况3，我们不需要做什么特别的。即只是交换<code>a[k]</code>和<code>a[great]</code>即可。</p><p>因为子情况2, 3都需要将<code>a[k]</code>和<code>a[great]</code>进行交换，所有才会写成前边参考代码里的样子。</p><p>前边分区完成之后，分别对左右两个子区间进行递归调用即可。</p><h4 id="3-3-3G"><a href="#3-3-3G" class="headerlink" title="3.3.3G"></a>3.3.3G</h4><p>终于到了真正的<code>双轴快排</code>的代码了。这部分的代码相对较长，我们一步一步来看。</p><p>首先，选取2个轴心点，然后通过<code>for</code>循环建立3个区间，即</p><table><thead><tr><th align="left">区间</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">[left, less)</td><td align="left">&lt;pivot1</td></tr><tr><td align="left">[less, great]</td><td align="left">pivot1&lt;=x&lt;=pivot2</td></tr><tr><td align="left">(great, right]</td><td align="left">&gt;pivot2</td></tr></tbody></table><p>然后我们看一下这部分的代码，如下</p><blockquote><p>代码本身其实不算太多，中间的注释比较详细，占了不小的篇幅</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">int</span> less  <span class="token operator">=</span> left<span class="token punctuation">;</span>  <span class="token comment">// The index of the first element of center part</span><span class="token keyword">int</span> great <span class="token operator">=</span> right<span class="token punctuation">;</span> <span class="token comment">// The index before the first element of right part</span><span class="token comment">/* * Use the second and fourth of the five sorted elements as pivots. * These values are inexpensive approximations of the first and * second terciles of the array. Note that pivot1 &lt;= pivot2. */</span><span class="token keyword">int</span> pivot1 <span class="token operator">=</span> a<span class="token punctuation">[</span>e2<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span> pivot2 <span class="token operator">=</span> a<span class="token punctuation">[</span>e4<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">/* * The first and the last elements to be sorted are moved to the * locations formerly occupied by the pivots. When partitioning * is complete, the pivots are swapped back into their final * positions, and excluded from subsequent sorting. */</span>a<span class="token punctuation">[</span>e2<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">;</span>a<span class="token punctuation">[</span>e4<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">/* * Skip elements, which are less or greater than pivot values. */</span><span class="token keyword">while</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span><span class="token operator">++</span>less<span class="token punctuation">]</span> <span class="token operator">&lt;</span> pivot1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span><span class="token operator">--</span>great<span class="token punctuation">]</span> <span class="token operator">&gt;</span> pivot2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/* * Partitioning: * *   left part           center part                   right part * +--------------------------------------------------------------+ * |  &lt; pivot1  |  pivot1 &lt;= &amp;&amp; &lt;= pivot2  |    ?    |  &gt; pivot2  | * +--------------------------------------------------------------+ *               ^                          ^       ^ *               |                          |       | *              less                        k     great * * Invariants: * *              all in (left, less)   &lt; pivot1 *    pivot1 &lt;= all in [less, k)     &lt;= pivot2 *              all in (great, right) &gt; pivot2 * * Pointer k is the first index of ?-part. */</span>outer<span class="token operator">:</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> less <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token operator">++</span>k <span class="token operator">&lt;=</span> great<span class="token punctuation">;</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> ak <span class="token operator">=</span> a<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>ak <span class="token operator">&lt;</span> pivot1<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// Move a[k] to left part</span>        a<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>less<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment">/*         * Here and below we use "a[i] = b; i++;" instead         * of "a[i++] = b;" due to performance issue.         */</span>        a<span class="token punctuation">[</span>less<span class="token punctuation">]</span> <span class="token operator">=</span> ak<span class="token punctuation">;</span>        <span class="token operator">++</span>less<span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>ak <span class="token operator">&gt;</span> pivot2<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// Move a[k] to right part</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>great<span class="token punctuation">]</span> <span class="token operator">&gt;</span> pivot2<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>great<span class="token operator">--</span> <span class="token operator">==</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">break</span> outer<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>great<span class="token punctuation">]</span> <span class="token operator">&lt;</span> pivot1<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// a[great] &lt;= pivot2</span>            a<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>less<span class="token punctuation">]</span><span class="token punctuation">;</span>            a<span class="token punctuation">[</span>less<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>great<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token operator">++</span>less<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token comment">// pivot1 &lt;= a[great] &lt;= pivot2</span>            a<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>great<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment">/*         * Here and below we use "a[i] = b; i--;" instead         * of "a[i--] = b;" due to performance issue.         */</span>        a<span class="token punctuation">[</span>great<span class="token punctuation">]</span> <span class="token operator">=</span> ak<span class="token punctuation">;</span>        <span class="token operator">--</span>great<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过代码我们可以看出变量<code>less</code>，<code>great</code>的作用</p><ul><li><code>less</code> - 指向第1个<code>&gt;=pivot1</code>的值的元素</li><li><code>great</code> - 指向最后1个<code>&lt;=pivot2</code>的值的元素</li></ul><p>开始的2个<code>while</code>循环是为了缩小我们需要遍历的区间<code>[less, great]</code>，即</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">while</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span><span class="token operator">++</span>less<span class="token punctuation">]</span> <span class="token operator">&lt;</span> pivot1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span><span class="token operator">--</span>great<span class="token punctuation">]</span> <span class="token operator">&gt;</span> pivot2<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>然后我们就在<code>label</code>为<code>outer</code>的<code>for</code>循环里使用变量<code>k</code>来遍历区间<code>[less, great]</code>。这个遍历的过程其实和前边<code>单轴快排</code>里边的分区很像。在每一步的时候，<code>a[k]</code>需要和两个<code>轴心点</code>比较以确定移动到哪个区间内。我们可以先分析下所有的可能情况，然后对比代码就非常容易理解了。</p><p><img src="/2021/04/01/arrays-sort-di-ceng-yuan-ma/4.PNG"><br>按照将<code>a[k]</code>划分到前边说的3个区间的思路，我们可以列举出所有的情况，如上图所示。</p><p>我们来看一下图中的5个叶子结点 - <code>C</code>, <code>E</code>, <code>G</code>, <code>I</code>, <code>J</code></p><ul><li><code>E</code>节点什么也不需要做，我们可以将其<code>剪枝</code>剪掉。</li><li><code>I</code>节点，我们要避免这种情况发生，可以在交换之前移动<code>great</code>，找到第一个<code>&lt;=pivot2</code>的<code>a[great]</code></li><li><code>J</code>节点虽然什么也不需要做，但是其父节点需要将<code>a[k]</code>与<code>a[great]</code>进行交换，所以可以将两者合并到一起。</li><li><code>C</code>节点和<code>G</code>节点的处理方式其实是一样的，不过<code>G</code>节点由于需要合并父节点的操作，所以代码上稍有不同。</li></ul><p>此时再看上边的<code>for</code>循环里边的代码，就比较明朗了。</p><p>完成分区之后，接下来我们需要将<code>pivot1</code>, <code>pivot2</code>放到他们应该在的位置，即区间<code>[less, great]</code>的左右端点外侧相邻的1个元素。为了腾出来这两个位置，我们需要先将这两个位置原来的值放到<code>a[left]</code>, <code>a[right]</code>这两个“空位”上。</p><p>然后对左右两个子区间分别进行递归调用，这部分的代码如下</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// Swap pivots into their final positions</span>a<span class="token punctuation">[</span>left<span class="token punctuation">]</span>  <span class="token operator">=</span> a<span class="token punctuation">[</span>less  <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span> a<span class="token punctuation">[</span>less  <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> pivot1<span class="token punctuation">;</span>a<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>great <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span> a<span class="token punctuation">[</span>great <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> pivot2<span class="token punctuation">;</span><span class="token comment">// Sort left and right parts recursively, excluding known pivots</span><span class="token function">sort</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> left<span class="token punctuation">,</span> less <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">,</span> leftmost<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">sort</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> great <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">,</span> right<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接下来是一个优化，如果中间区间<code>[less, great]</code>(即<code>pivot1&lt;=x&lt;=pivot2</code>)比较大的话(超过<code>4/7</code>的待排序区间长度)，就执行里边的代码。从而将这个区间继续划分为3部分</p><table><thead><tr><th align="left">区间</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">（, less)</td><td align="left">=pivot1</td></tr><tr><td align="left">[less, great]</td><td align="left">pivot1&lt;x&lt;pivot2</td></tr><tr><td align="left">(great, )</td><td align="left">=pivot2</td></tr></tbody></table><p>这部分具体的实现也同样可以使用上面画图的方法来进行分析，而且实际实现也与前边的非常相似，这里就不再重复了。这部分代码如下</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/* * If center part is too large (comprises &gt; 4/7 of the array), * swap internal pivot values to ends. */</span><span class="token keyword">if</span> <span class="token punctuation">(</span>less <span class="token operator">&lt;</span> e1 <span class="token operator">&amp;&amp;</span> e5 <span class="token operator">&lt;</span> great<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">/*     * Skip elements, which are equal to pivot values.     */</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>less<span class="token punctuation">]</span> <span class="token operator">==</span> pivot1<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token operator">++</span>less<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>great<span class="token punctuation">]</span> <span class="token operator">==</span> pivot2<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token operator">--</span>great<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">/*     * Partitioning:     *     *   left part         center part                  right part     * +----------------------------------------------------------+     * | == pivot1 |  pivot1 &lt; &amp;&amp; &lt; pivot2  |    ?    | == pivot2 |     * +----------------------------------------------------------+     *              ^                        ^       ^     *              |                        |       |     *             less                      k     great     *     * Invariants:     *     *              all in (*,  less) == pivot1     *     pivot1 &lt; all in [less,  k)  &lt; pivot2     *              all in (great, *) == pivot2     *     * Pointer k is the first index of ?-part.     */</span>    outer<span class="token operator">:</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> less <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token operator">++</span>k <span class="token operator">&lt;=</span> great<span class="token punctuation">;</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> ak <span class="token operator">=</span> a<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>ak <span class="token operator">==</span> pivot1<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// Move a[k] to left part</span>            a<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>less<span class="token punctuation">]</span><span class="token punctuation">;</span>            a<span class="token punctuation">[</span>less<span class="token punctuation">]</span> <span class="token operator">=</span> ak<span class="token punctuation">;</span>            <span class="token operator">++</span>less<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>ak <span class="token operator">==</span> pivot2<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// Move a[k] to right part</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>great<span class="token punctuation">]</span> <span class="token operator">==</span> pivot2<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>great<span class="token operator">--</span> <span class="token operator">==</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">break</span> outer<span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>great<span class="token punctuation">]</span> <span class="token operator">==</span> pivot1<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// a[great] &lt; pivot2</span>                a<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>less<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token comment">/*                 * Even though a[great] equals to pivot1, the                 * assignment a[less] = pivot1 may be incorrect,                 * if a[great] and pivot1 are floating-point zeros                 * of different signs. Therefore in float and                 * double sorting methods we have to use more                 * accurate assignment a[less] = a[great].                 */</span>                a<span class="token punctuation">[</span>less<span class="token punctuation">]</span> <span class="token operator">=</span> pivot1<span class="token punctuation">;</span>                <span class="token operator">++</span>less<span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token comment">// pivot1 &lt; a[great] &lt; pivot2</span>                a<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>great<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            a<span class="token punctuation">[</span>great<span class="token punctuation">]</span> <span class="token operator">=</span> ak<span class="token punctuation">;</span>            <span class="token operator">--</span>great<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最后就是针对我们的中间区间(可能已经被上边的代码优化而将区间<code>[less, great]</code>进一步缩小)进行递归调用</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// Sort center part recursively</span><span class="token function">sort</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> less<span class="token punctuation">,</span> great<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>至此，整个<code>双轴快排</code>分析就结束了。</p><p>``</p><h3 id="4-小结"><a href="#4-小结" class="headerlink" title="4. 小结"></a>4. 小结</h3><p>总结一下，我们首先从双轴快排的入口函数开始，学习了针对大数组的一种优化处理思路 - 检测数组是否有序以及使用迭代版本的<code>merge sort</code>进行排序。</p><p>那么如果数组没有达到设定的有序的标准的话，就转到真正的<code>双轴快排了</code>。但是在双轴快排里边在特殊情况下也会“退化”成<code>单轴快排</code>。</p><p>在分析的过程当中，采用了画流程图或者具体的示意图的方式方便对原始代码的理解。</p><p>在此也深深地感受到任何一种排序算法都不是孤立存在的。在实际的问题当中，更多的是对这些算法综合应用，针对不同的分支情况选取对应比较优的算法进行处理。</p><p>但是这并不是终点，2018年，<code>双轴快排</code>的作者<code>Vladimir Yaroslavskiy</code>在JDK 1.8的基础之上，又做了很多优化。据作者自己说，优化过的版本可以保证在任意输入的情况下达到<code>nlog(n)</code>的时间复杂度。感兴趣的同学，可以阅读 <a href="https://mail.openjdk.java.net/pipermail/core-libs-dev/2018-January/051000.html">The new optimized version of Dual-Pivot Quicksort</a> 以了解更多信息。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://www.imooc.com/article/297781">https://www.imooc.com/article/297781</a></li><li><a href="https://www.cnblogs.com/baichunyu/p/11935995.html">https://www.cnblogs.com/baichunyu/p/11935995.html</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ArrayList扩容机制</title>
      <link href="2021/04/01/arraylist-kuo-rong-ji-zhi/"/>
      <url>2021/04/01/arraylist-kuo-rong-ji-zhi/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/baichunyu/p/12965241.html">ArrayList扩容机制</a></p><h1 id="一、先从-ArrayList-的构造函数说起"><a href="#一、先从-ArrayList-的构造函数说起" class="headerlink" title="一、先从 ArrayList 的构造函数说起"></a>一、先从 ArrayList 的构造函数说起</h1><p>　　ArrayList有三种方式来初始化，构造方法源码如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/**     * 默认初始容量大小     */</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> DEFAULT_CAPACITY <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> DEFAULTCAPACITY_EMPTY_ELEMENTDATA <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token comment">/**     *默认构造函数，使用初始容量10构造一个空列表(无参数构造)     */</span>    <span class="token keyword">public</span> <span class="token class-name">ArrayList</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>elementData <span class="token operator">=</span> DEFAULTCAPACITY_EMPTY_ELEMENTDATA<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">/**     * 带初始容量参数的构造函数。（用户自己指定容量）     */</span>    <span class="token keyword">public</span> <span class="token class-name">ArrayList</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCapacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>initialCapacity <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">//初始容量大于0</span>            <span class="token comment">//创建initialCapacity大小的数组</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>elementData <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">[</span>initialCapacity<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>initialCapacity <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">//初始容量等于0</span>            <span class="token comment">//创建空数组</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>elementData <span class="token operator">=</span> EMPTY_ELEMENTDATA<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span><span class="token comment">//初始容量小于0，抛出异常</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"Illegal Capacity: "</span><span class="token operator">+</span>                                               initialCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>   <span class="token comment">/**    *构造包含指定collection元素的列表，这些元素利用该集合的迭代器按顺序返回    *如果指定的集合为null，throws NullPointerException。    */</span>     <span class="token keyword">public</span> <span class="token class-name">ArrayList</span><span class="token punctuation">(</span><span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>        elementData <span class="token operator">=</span> c<span class="token punctuation">.</span><span class="token function">toArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>size <span class="token operator">=</span> elementData<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>elementData<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>                elementData <span class="token operator">=</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>elementData<span class="token punctuation">,</span> size<span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token comment">// replace with empty array.</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>elementData <span class="token operator">=</span> EMPTY_ELEMENTDATA<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以无参数构造方法创建 ArrayList 时，实际上初始化赋值的是一个空数组。当真正对数组进行添加元素操作时，才真正分配容量。即向数组中添加第一个元素时，数组容量扩为10。 下面在我们分析 ArrayList 扩容时会讲到这一点内容！</p><h1 id="二、一步一步分析-ArrayList-扩容机制"><a href="#二、一步一步分析-ArrayList-扩容机制" class="headerlink" title="二、一步一步分析 ArrayList 扩容机制"></a>二、一步一步分析 ArrayList 扩容机制</h1><p>　　这里以无参构造函数创建的 ArrayList 为例分析：</p><h2 id="1、先来看-add-方法"><a href="#1、先来看-add-方法" class="headerlink" title="1、先来看 add 方法"></a>1、先来看 add 方法</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//得到最小扩容量</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">ensureCapacityInternal</span><span class="token punctuation">(</span><span class="token keyword">int</span> minCapacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>elementData <span class="token operator">==</span> DEFAULTCAPACITY_EMPTY_ELEMENTDATA<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// 获取默认的容量和传入参数的较大值</span>        minCapacity <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>DEFAULT_CAPACITY<span class="token punctuation">,</span> minCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">ensureExplicitCapacity</span><span class="token punctuation">(</span>minCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当 要 add 进第1个元素时，minCapacity为1，在Math.max()方法比较后，minCapacity 为10。</p><h2 id="2、再来看看-ensureCapacityInternal-方法"><a href="#2、再来看看-ensureCapacityInternal-方法" class="headerlink" title="2、再来看看 ensureCapacityInternal() 方法"></a>2、再来看看 ensureCapacityInternal() 方法</h2><p>　　可以看到 add 方法 首先调用了ensureCapacityInternal(size + 1)</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//得到最小扩容量</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">ensureCapacityInternal</span><span class="token punctuation">(</span><span class="token keyword">int</span> minCapacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>elementData <span class="token operator">==</span> DEFAULTCAPACITY_EMPTY_ELEMENTDATA<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// 获取默认的容量和传入参数的较大值</span>        minCapacity <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>DEFAULT_CAPACITY<span class="token punctuation">,</span> minCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">ensureExplicitCapacity</span><span class="token punctuation">(</span>minCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当 要 add 进第1个元素时，minCapacity为1，在Math.max()方法比较后，minCapacity 为10。</p><h2 id="3、ensureExplicitCapacity-方法"><a href="#3、ensureExplicitCapacity-方法" class="headerlink" title="3、ensureExplicitCapacity() 方法"></a>3、ensureExplicitCapacity() 方法</h2><p>　　如果调用 ensureCapacityInternal() 方法就一定会进过（执行）这个方法</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//判断是否需要扩容</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">ensureExplicitCapacity</span><span class="token punctuation">(</span><span class="token keyword">int</span> minCapacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>    modCount<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token comment">// overflow-conscious code</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>minCapacity <span class="token operator">-</span> elementData<span class="token punctuation">.</span>length <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token comment">//调用grow方法进行扩容，调用此方法代表已经开始扩容了</span>        <span class="token function">grow</span><span class="token punctuation">(</span>minCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们来仔细分析一下：</p><ul><li>当我们要 add 进第1个元素到 ArrayList 时，elementData.length 为0 （因为还是一个空的 list），因为执行了 ensureCapacityInternal() 方法 ，所以 minCapacity 此时为10。此时，minCapacity - elementData.length &gt; 0 成立，所以会进入 grow(minCapacity) 方法。</li><li>当add第2个元素时，minCapacity 为2，此时e lementData.length(容量)在添加第一个元素后扩容成 10 了。此时，minCapacity - elementData.length &gt; 0 不成立，所以不会进入 （执行）grow(minCapacity) 方法。</li><li>添加第3、4···到第10个元素时，依然不会执行grow方法，数组容量都为10。</li></ul><p>　　直到添加第11个元素，minCapacity(为11)比elementData.length（为10）要大。进入grow方法进行扩容。</p><h2 id="4、grow-方法"><a href="#4、grow-方法" class="headerlink" title="4、grow() 方法"></a>4、grow() 方法</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/**     * 要分配的最大数组大小     */</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> MAX_ARRAY_SIZE <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span>MAX_VALUE <span class="token operator">-</span> <span class="token number">8</span><span class="token punctuation">;</span><span class="token comment">/**     * ArrayList扩容的核心方法。     */</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">grow</span><span class="token punctuation">(</span><span class="token keyword">int</span> minCapacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// oldCapacity为旧容量，newCapacity为新容量</span>    <span class="token keyword">int</span> oldCapacity <span class="token operator">=</span> elementData<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token comment">//将oldCapacity 右移一位，其效果相当于oldCapacity /2，</span>    <span class="token comment">//我们知道位运算的速度远远快于整除运算，整句运算式的结果就是将新容量更新为旧容量的1.5倍，</span>    <span class="token keyword">int</span> newCapacity <span class="token operator">=</span> oldCapacity <span class="token operator">+</span> <span class="token punctuation">(</span>oldCapacity <span class="token operator">&gt;&gt;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//然后检查新容量是否大于最小需要容量，若还是小于最小需要容量，那么就把最小需要容量当作数组的新容量，</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>newCapacity <span class="token operator">-</span> minCapacity <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>        newCapacity <span class="token operator">=</span> minCapacity<span class="token punctuation">;</span>    <span class="token comment">// 如果新容量大于 MAX_ARRAY_SIZE,进入(执行) `hugeCapacity()` 方法来比较 minCapacity 和 MAX_ARRAY_SIZE，</span>    <span class="token comment">//如果minCapacity大于最大容量，则新容量则为`Integer.MAX_VALUE`，否则，新容量大小则为 MAX_ARRAY_SIZE 即为 `Integer.MAX_VALUE - 8`。</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>newCapacity <span class="token operator">-</span> MAX_ARRAY_SIZE <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span>        newCapacity <span class="token operator">=</span> <span class="token function">hugeCapacity</span><span class="token punctuation">(</span>minCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// minCapacity is usually close to size, so this is a win:</span>    elementData <span class="token operator">=</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>elementData<span class="token punctuation">,</span> newCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1),所以 ArrayList 每次扩容之后容量都会变为原来的 1.5 倍左右（oldCapacity为偶数就是1.5倍，否则是1.5倍左右）！ 奇偶不同，比如 ：10+10/2 = 15, 33+33/2=49。如果是奇数的话会丢掉小数.</p><p>　　我们再来通过例子探究一下grow() 方法 ：</p><ul><li>当add第1个元素时，oldCapacity 为0，经比较后第一个if判断成立，newCapacity = minCapacity(为10)。但是第二个if判断不会成立，即newCapacity 不比 MAX_ARRAY_SIZE大，则不会进入 hugeCapacity 方法。数组容量为10，add方法中 return true,size增为1。</li><li>当add第11个元素进入grow方法时，newCapacity为15，比minCapacity（为11）大，第一个if判断不成立。新容量没有大于数组最大size，不会进入hugeCapacity方法。数组容量扩为15，add方法中return true,size增为11。</li><li>以此类推······</li></ul><p>　　这里补充一点比较重要，但是容易被忽视掉的知识点：</p><p>　　①java 中的 length 属性是针对数组说的,比如说你声明了一个数组,想知道这个数组的长度则用到了 length 这个属性.</p><p>　　②java 中的 length() 方法是针对字符串说的,如果想看这个字符串的长度则用到 length() 这个方法.</p><p>　　③java 中的 size() 方法是针对泛型集合说的,如果想看这个泛型有多少个元素,就调用此方法来查看!</p><h2 id="5、hugeCapacity-方法"><a href="#5、hugeCapacity-方法" class="headerlink" title="5、hugeCapacity() 方法"></a>5、hugeCapacity() 方法</h2><p>　　从上面 grow() 方法源码我们知道： 如果新容量大于 MAX_ARRAY_SIZE,进入(执行) hugeCapacity() 方法来比较 minCapacity 和 MAX_ARRAY_SIZE，如果minCapacity大于最大容量，则新容量则为Integer.MAX_VALUE，否则，新容量大小则为 MAX_ARRAY_SIZE 即为 Integer.MAX_VALUE - 8。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">hugeCapacity</span><span class="token punctuation">(</span><span class="token keyword">int</span> minCapacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>minCapacity <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment">// overflow</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">OutOfMemoryError</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//对minCapacity和MAX_ARRAY_SIZE进行比较</span>    <span class="token comment">//若minCapacity大，将Integer.MAX_VALUE作为新数组的大小</span>    <span class="token comment">//若MAX_ARRAY_SIZE大，将MAX_ARRAY_SIZE作为新数组的大小</span>    <span class="token comment">//MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>minCapacity <span class="token operator">&gt;</span> MAX_ARRAY_SIZE<span class="token punctuation">)</span> <span class="token operator">?</span>        <span class="token class-name">Integer</span><span class="token punctuation">.</span>MAX_VALUE <span class="token operator">:</span>    MAX_ARRAY_SIZE<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="三、System-arraycopy-和-Arrays-copyOf-方法"><a href="#三、System-arraycopy-和-Arrays-copyOf-方法" class="headerlink" title="三、System.arraycopy() 和 Arrays.copyOf()方法"></a>三、System.arraycopy() 和 Arrays.copyOf()方法</h1><p>　　阅读源码的话，我们就会发现 ArrayList 中大量调用了这两个方法。比如：我们上面讲的扩容操作以及add(int index, E element)、toArray() 等方法中都用到了该方法！</p><h2 id="1、System-arraycopy-方法"><a href="#1、System-arraycopy-方法" class="headerlink" title="1、System.arraycopy() 方法"></a>1、System.arraycopy() 方法</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/**     * 在此列表中的指定位置插入指定的元素。     *先调用 rangeCheckForAdd 对index进行界限检查；然后调用 ensureCapacityInternal 方法保证capacity足够大；     *再将从index开始之后的所有成员后移一个位置；将element插入index位置；最后size加1。     */</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">,</span> <span class="token class-name">E</span> element<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">rangeCheckForAdd</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">ensureCapacityInternal</span><span class="token punctuation">(</span>size <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// Increments modCount!!</span>    <span class="token comment">//arraycopy()方法实现数组自己复制自己</span>    <span class="token comment">//elementData:源数组;index:源数组中的起始位置;elementData：目标数组；index + 1：目标数组中的起始位置； size - index：要复制的数组元素的数量；</span>    <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">arraycopy</span><span class="token punctuation">(</span>elementData<span class="token punctuation">,</span> index<span class="token punctuation">,</span> elementData<span class="token punctuation">,</span> index <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> size <span class="token operator">-</span> index<span class="token punctuation">)</span><span class="token punctuation">;</span>    elementData<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> element<span class="token punctuation">;</span>    size<span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>联系： 看两者源代码可以发现 copyOf() 内部实际调用了 System.arraycopy() 方法 </p><p>　　区别： arraycopy() 需要目标数组，将原数组拷贝到你自己定义的数组里或者原数组，而且可以选择拷贝的起点和长度以及放入新数组中的位置 copyOf() 是系统自动在内部新建一个数组，并返回该数组。</p><h1 id="四、ensureCapacity方法"><a href="#四、ensureCapacity方法" class="headerlink" title="四、ensureCapacity方法"></a>四、ensureCapacity方法</h1><p>　　ArrayList 源码中有一个 ensureCapacity 方法不知道大家注意到没有，这个方法 ArrayList 内部没有被调用过，所以很显然是提供给用户调用的，那么这个方法有什么作用呢？</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/**    如有必要，增加此 ArrayList 实例的容量，以确保它至少可以容纳由minimum capacity参数指定的元素数。     *     * @param   minCapacity   所需的最小容量     */</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">ensureCapacity</span><span class="token punctuation">(</span><span class="token keyword">int</span> minCapacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> minExpand <span class="token operator">=</span> <span class="token punctuation">(</span>elementData <span class="token operator">!=</span> DEFAULTCAPACITY_EMPTY_ELEMENTDATA<span class="token punctuation">)</span>        <span class="token comment">// any size if not default element table</span>        <span class="token operator">?</span> <span class="token number">0</span>        <span class="token comment">// larger than default for default empty table. It's already</span>        <span class="token comment">// supposed to be at default size.</span>        <span class="token operator">:</span> DEFAULT_CAPACITY<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>minCapacity <span class="token operator">&gt;</span> minExpand<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">ensureExplicitCapacity</span><span class="token punctuation">(</span>minCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cookies和session</title>
      <link href="2021/03/31/cookies-he-session/"/>
      <url>2021/03/31/cookies-he-session/</url>
      
        <content type="html"><![CDATA[<h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p> (referentce to <a href="https://segmentfault.com/a/1190000017831088">https://segmentfault.com/a/1190000017831088</a>)</p><h2 id="http是一个无状态协议"><a href="#http是一个无状态协议" class="headerlink" title="http是一个无状态协议"></a>http是一个无状态协议</h2><p>什么是无状态呢？就是说这一次请求和上一次请求是没有任何关系的，互不认识的，没有关联的。这种无状态的的好处是快速。坏处是假如我们想要把<code>www.zhihu.com/login.html</code>和<code>www.zhihu.com/index.html</code>关联起来，必须使用某些手段和工具</p><h2 id="cookie和session"><a href="#cookie和session" class="headerlink" title="cookie和session"></a>cookie和session</h2><p>由于http的无状态性，为了使某个域名下的所有网页能够共享某些数据，session和cookie出现了。客户端访问服务器的流程如下</p><ul><li>首先，客户端会发送一个http请求到服务器端。</li><li>服务器端接受客户端请求后，建立一个session，并发送一个http响应到客户端，这个响应头，其中就包含Set-Cookie头部。该头部包含了sessionId。Set-Cookie格式如下，具体请看<a href="http://bubkoo.com/2014/04/21/http-cookies-explained/">Cookie详解</a><br><code>Set-Cookie: value[; expires=date][; domain=domain][; path=path][; secure]</code></li><li>在客户端发起的第二次请求，假如服务器给了set-Cookie，浏览器会自动在请求头中添加cookie</li><li>服务器接收请求，分解cookie，验证信息，核对成功后返回response给客户端</li></ul><p><img src="/2021/03/31/cookies-he-session/bVbmYbQ" alt="请求流程"></p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ul><li>cookie只是实现session的其中一种方案。虽然是最常用的，但并不是唯一的方法。禁用cookie后还有其他方法存储，比如放在url中</li><li>现在大多都是Session + Cookie，但是只用session不用cookie，或是只用cookie，不用session在理论上都可以保持会话状态。可是实际中因为多种原因，一般不会单独使用</li><li>用session只需要在客户端保存一个id，实际上大量数据都是保存在服务端。如果全部用cookie，数据量大的时候客户端是没有那么多空间的。</li><li>如果只用cookie不用session，那么账户信息全部保存在客户端，一旦被劫持，全部信息都会泄露。并且客户端数据量变大，网络传输的数据量也会变大</li></ul><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p><strong>简而言之, session 有如用户信息档案表, 里面包含了用户的认证信息和登录状态等信息. 而 cookie 就是用户通行证</strong></p><h2 id="token"><a href="#token" class="headerlink" title="token"></a>token</h2><p>token 也称作令牌，由uid+time+sign[+固定参数]<br>token 的认证方式类似于<strong>临时的证书签名</strong>, 并且是一种服务端无状态的认证方式, 非常适合于 REST API 的场景. 所谓无状态就是服务端并不会保存身份认证相关的数据。</p><h3 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h3><ul><li>uid: 用户唯一身份标识</li><li>time: 当前时间的时间戳</li><li>sign: 签名, 使用 hash/encrypt 压缩成定长的十六进制字符串，以防止第三方恶意拼接</li><li>固定参数(可选): 将一些常用的固定参数加入到 token 中是为了避免重复查库</li></ul><h3 id="存放"><a href="#存放" class="headerlink" title="存放"></a>存放</h3><p>token在客户端一般存放于localStorage，cookie，或sessionStorage中。在服务器一般存于数据库中</p><h3 id="token认证流程"><a href="#token认证流程" class="headerlink" title="token认证流程"></a>token认证流程</h3><p>token 的认证流程与cookie很相似</p><ul><li>用户登录，成功后服务器返回Token给客户端。</li><li>客户端收到数据后保存在客户端</li><li>客户端再次访问服务器，将token放入headers中</li><li>服务器端采用filter过滤器校验。校验成功则返回请求数据，校验失败则返回错误码</li></ul><h2 id="token可以抵抗csrf，cookie-session不行"><a href="#token可以抵抗csrf，cookie-session不行" class="headerlink" title="token可以抵抗csrf，cookie+session不行"></a>token可以抵抗csrf，cookie+session不行</h2><p>假如用户正在登陆银行网页，同时登陆了攻击者的网页，并且银行网页未对csrf攻击进行防护。攻击者就可以在网页放一个表单，该表单提交src为<code>http://www.bank.com/api/transfer</code>，body为<code>count=1000&amp;to=Tom</code>。倘若是session+cookie，用户打开网页的时候就已经转给Tom1000元了.因为form 发起的 POST 请求并不受到浏览器同源策略的限制，因此可以任意地使用其他域的 Cookie 向其他域发送 POST 请求，形成 CSRF 攻击。在post请求的瞬间，cookie会被浏览器自动添加到请求头中。但token不同，token是开发者为了防范csrf而特别设计的令牌，浏览器不会自动添加到headers里，攻击者也无法访问用户的token，所以提交的表单无法通过服务器过滤，也就无法形成攻击。</p><h2 id="分布式情况下的session和token"><a href="#分布式情况下的session和token" class="headerlink" title="分布式情况下的session和token"></a>分布式情况下的session和token</h2><p>我们已经知道session时有状态的，一般存于服务器内存或硬盘中，当服务器采用分布式或集群时，session就会面对负载均衡问题。</p><ul><li>负载均衡多服务器的情况，不好确认当前用户是否登录，因为多服务器不共享session。这个问题也可以将session存在一个服务器中来解决，但是就不能完全达到负载均衡的效果。当今的几种<a href="http://blog.51cto.com/zhibeiwang/1965018">解决session负载均衡</a>的方法。</li></ul><p>而token是无状态的，token字符串里就保存了所有的用户信息</p><ul><li>客户端登陆传递信息给服务端，服务端收到后把用户信息加密（token）传给客户端，客户端将token存放于localStroage等容器中。客户端每次访问都传递token，服务端解密token，就知道这个用户是谁了。通过cpu加解密，服务端就不需要存储session占用存储空间，就很好的解决负载均衡多服务器的问题了。这个方法叫做[JWT(Json Web Token)](<a href="https://huanqiang.wang/2017/12/28/JWT">https://huanqiang.wang/2017/12/28/JWT</a> 介绍/)</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>session存储于服务器，可以理解为一个状态列表，拥有一个唯一识别符号sessionId，通常存放于cookie中。服务器收到cookie后解析出sessionId，再去session列表中查找，才能找到相应session。依赖cookie</li><li>cookie类似一个令牌，装有sessionId，存储在客户端，浏览器通常会自动添加。</li><li>token也类似一个令牌，无状态，用户信息都被加密到token中，服务器收到token后解密就可知道是哪个用户。需要开发者手动添加。</li><li>jwt只是一个跨域认证的方案</li></ul><p>Cookie是保存在浏览器上的一些数据，一般通过HTTP响应头set cookie来设置，当然也可以通过JS脚本来直接设置，Cookie是按照网站来进行组织和保存的，每一个网站都可以在浏览器中保存一些Cookie，保存好了之后，浏览器向这个网站发出的请求都会携带这些Cookie，然后后台就可以分析这些Cookie。Session这个单词在不同的语境下可以有不同的含义。它可以理解为一个抽象概念，即会话，会话用于记录一个用户在我们网站上的一些行为、一些状态，可以理解为一个上下文，Context。这些用户状态可以利用Cookie直接保存在前端，也可以保存在后台，然后利用Cookie中的Session ID来标识。在另外的一些语境下，Session又可以指在后台保存用户状态来实现会话的方式，它把用户状态存储在后台的内存、数据库等介质中，然后我们利用请求的Cookie中保存的Session ID来为这个请求找到它对应的会话。</p><p>Session在一些语境下还可能专指后台保存的用户状态</p><ol><li>由于HTTP协议是无状态的协议，所以服务端需要记录用户的状态时，就需要用某种机制来识具体的用户，这个机制就是Session.典型的场景比如购物车，当你点击下单按钮时，由于HTTP协议无状态，所以并不知道是哪个用户操作的，所以服务端要为特定的用户创建了特定的Session，用用于标识这个用户，并且跟踪用户，这样才知道购物车里面有几本书。这个Session是保存在服务端的，有一个唯一标识。在服务端保存Session的方法很多，内存、数据库、文件都有。集群的时候也要考虑Session的转移，在大型的网站，一般会有专门的Session服务器集群，用来保存用户会话，这个时候 Session 信息都是放在内存的，使用一些缓存服务比如Memcached之类的来放 Session。</li><li>思考一下服务端如何识别特定的客户？这个时候Cookie就登场了。每次HTTP请求的时候，客户端都会发送相应的Cookie信息到服务端。实际上大多数的应用都是用 Cookie 来实现Session跟踪的，第一次创建Session的时候，服务端会在HTTP协议中告诉客户端，需要在 Cookie 里面记录一个Session ID，以后每次请求把这个会话ID发送到服务器，我就知道你是谁了。有人问，如果客户端的浏览器禁用了 Cookie 怎么办？一般这种情况下，会使用一种叫做URL重写的技术来进行会话跟踪，即每次HTTP交互，URL后面都会被附加上一个诸如 sid=xxxxx 这样的参数，服务端据此来识别用户。</li><li>Cookie其实还可以用在一些方便用户的场景下，设想你某次登陆过一个网站，下次登录的时候不想再次输入账号了，怎么办？这个信息可以写到Cookie里面，访问网站的时候，网站页面的脚本可以读取这个信息，就自动帮你把用户名给填了，能够方便一下用户。这也是Cookie名称的由来，给用户的一点甜头。<br>所以，总结一下：<br>Session是在服务端保存的一个数据结构，用来跟踪用户的状态，这个数据可以保存在集群、数据库、文件中；<br>Cookie是客户端保存用户信息的一种机制，用来记录用户的一些信息，也是实现Session的一种方式。</li></ol>]]></content>
      
      
      <categories>
          
          <category> network </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spring注解原理</title>
      <link href="2021/03/31/spring-zhu-jie-yuan-li/"/>
      <url>2021/03/31/spring-zhu-jie-yuan-li/</url>
      
        <content type="html"><![CDATA[<h1 id="Spring-注解驱动开发"><a href="#Spring-注解驱动开发" class="headerlink" title="Spring 注解驱动开发"></a>Spring 注解驱动开发</h1><h2 id="1-配置文件"><a href="#1-配置文件" class="headerlink" title="1. 配置文件"></a>1. 配置文件</h2><p>1、配置文件的形式中，标注了<code>@component-scan</code>,<code>@Controller</code>,<code>@Service</code>,<code>@Repository</code>,<code>@Component</code>就会自动扫描包。</p><p>2、<code>@ComponentScan(value="com.atguigu")</code>,</p><h3 id="1-1-配置"><a href="#1-1-配置" class="headerlink" title="1.1 配置"></a>1.1 配置</h3><h2 id="2-常用注解"><a href="#2-常用注解" class="headerlink" title="2. 常用注解"></a>2. 常用注解</h2><p><code>@Controller</code> 注解的bean会被spring-mvc框架所使用。<br><code>@Repository</code> 会被作为持久层操作（数据库）的bean来使用<br>如果想使用自定义的组件注解，那么只要在你定义的新注解中加上@Component即可：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Component</span> <span class="token annotation punctuation">@Scope</span><span class="token punctuation">(</span><span class="token string">"prototype"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token annotation punctuation">@interface</span> <span class="token class-name">ScheduleJob</span> <span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token number">123</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这样，所有被<code>@ScheduleJob</code>注解的类就都可以注入到spring容器来进行管理。我们所需要做的，就是写一些新的代码来处理这个自定义注解（译者注：可以用反射的方法），进而执行我们想要执行的工作。</p><p><code>@Component</code>就是跟<code>&lt;bean&gt;</code>一样，可以托管到Spring容器进行管理。</p><p><code>@Service</code>, <code>@Controller</code> , <code>@Repository</code> = {<code>@Component</code> + 一些特定的功能}。这个就意味着这些注解在部分功能上是一样的。</p><p>当然，下面三个注解被用于为我们的应用进行分层：</p><p><code>@Controller</code>注解类进行前端请求的处理，转发，重定向。包括调用Service层的方法 （requestMapping + componnet)<br><code>@Service</code>注解类处理业务逻辑<br><code>@Repository</code>注解类作为DAO对象（数据访问对象，Data Access Objects），这些类可以直接对数据库进行操作<br>有这些分层操作的话，代码之间就实现了松耦合，代码之间的调用也清晰明朗，便于项目的管理；假想一下，如果只用<code>@Controller</code>注解，那么所有的请求转发，业务处理，数据库操作代码都糅合在一个地方，那这样的代码该有多难拓展和维护。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><code>@Component</code>, <code>@Service</code>, <code>@Controller</code>, <code>@Repository</code>是spring注解，注解后可以被spring框架所扫描并注入到spring容器来进行管理<br><code>@Component</code>是通用注解，其他三个注解是这个注解的拓展，并且具有了特定的功能<br><code>@Repository</code>注解在持久层中，具有将数据库操作抛出的原生异常翻译转化为spring的持久层异常的功能。<br><code>@Controller</code>层是spring-mvc的注解，具有将请求进行转发，重定向的功能。<br><code>@Service</code>层是业务逻辑层注解，这个注解只是标注该类处于业务逻辑层。<br>用这些注解对应用进行分层之后，就能将请求处理，义务逻辑处理，数据库操作处理分离出来，为代码解耦，也方便了以后项目的维护和开发。</p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>System类源码分析</title>
      <link href="2021/03/31/system-lei-yuan-ma-fen-xi/"/>
      <url>2021/03/31/system-lei-yuan-ma-fen-xi/</url>
      
        <content type="html"><![CDATA[<h2 id="The-Security-Manager"><a href="#The-Security-Manager" class="headerlink" title="The Security Manager"></a>The Security Manager</h2><ol><li>定义</li></ol><p>官方：</p><p>A security manager is an object that defines a security policy for an application. This policy specifies actions that are unsafe or sensitive. Any actions not allowed by the security policy cause a <code>SecurityException</code> to be thrown. An application can also query its security manager to discover which actions are allowed.</p><p>理解：</p><p>它是一个应用的安全策略。这个策略指定当前的动作是安全or不安全or敏感。</p><ol start="2"><li>示例</li></ol><p>官方：</p><p>Typically, a web applet runs with a security manager provided by the browser or Java Web Start plugin. Other kinds of applications normally run without a security manager, unless the application itself defines one. If no security manager is present, the application has no security policy and acts without restrictions.</p><p>理解：</p><p>web 程序中的安全管理类是由浏览器或者启动插件提供的。其他应用程序通常没有安全管理类，除非我们自己去定义。</p><p>在</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javaunderlying</title>
      <link href="2021/03/31/javaunderlying/"/>
      <url>2021/03/31/javaunderlying/</url>
      
        <content type="html"><![CDATA[<h3 id="1-栈帧中的变量作用域"><a href="#1-栈帧中的变量作用域" class="headerlink" title="1. 栈帧中的变量作用域"></a><font color="green">1. 栈帧中的变量作用域</font></h3><ol><li>没有作用域的局部变量不会进入局部变量表。</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">{</span>        <span class="token keyword">int</span> val1 <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> val2 <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述代码中，<code>val1</code>没有作用域（那个代码块只有它一个，跑完就咩有了），所以不会进入局部变量表中。val2会进入变量表，因为val2作用于test函数。</p><ol start="2"><li>非静态方法，局部变量表 index=0的位置永远是this指针。静态方法没有this指针。</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>小陈和我</title>
      <link href="2021/03/30/love/"/>
      <url>2021/03/30/love/</url>
      
        <content type="html"><![CDATA[<h1 id="小陈和我的生活记录"><a href="#小陈和我的生活记录" class="headerlink" title="小陈和我的生活记录"></a>小陈和我的生活记录</h1><p>身份介绍：</p><table><thead><tr><th align="center">男</th><th align="center">女</th></tr></thead><tbody><tr><td align="center">身高：180</td><td align="center">身高：164</td></tr><tr><td align="center">体重：140</td><td align="center">体重：保密</td></tr><tr><td align="center">性格：沙雕</td><td align="center">性格：稳重和隐藏</td></tr><tr><td align="center">技能：java开发、修电脑、气人达人</td><td align="center">技能：英语、温柔</td></tr><tr><td align="center">职业：程序猿</td><td align="center">职业：教师or？</td></tr></tbody></table><h2 id="1-吃过的好吃的"><a href="#1-吃过的好吃的" class="headerlink" title="1. 吃过的好吃的"></a>1. 吃过的好吃的</h2><ol><li>三不牛腩</li><li>枣木烤鸭</li><li>胡嗲单车烧烤（超好吃）</li><li>花道寿司（日料）</li><li>XX牛杂粉</li><li>酱大骨（吃坏了肚子，湖南大学天马公寓那个地方，千万不要去）</li><li>酸辣粉（后街，味道不错）</li><li>湖南大学牛肉饼（小陈说好吃，我觉得一般）</li><li>中南大学麓山南路新开的烤鱼烤牛蛙，点的鲈鱼，挺好吃</li><li>桂林卤粉（挺好吃，湖南大学麓山南路一家小店，大概在渔湾市那里）</li></ol><h2 id="2-去过的地方"><a href="#2-去过的地方" class="headerlink" title="2.去过的地方"></a>2.去过的地方</h2><ol><li>长沙海底世界</li><li>长沙五一广场</li><li>岳麓山</li><li>中南大学</li><li>湖南大学</li><li>橘子洲</li></ol><h2 id="3-看的电影"><a href="#3-看的电影" class="headerlink" title="3.看的电影"></a>3.看的电影</h2><ol><li>送你一朵小红花</li><li>阿凡达</li><li>人潮汹涌</li><li>利刃出鞘</li></ol><p><img src="/2021/03/30/love/%E5%B0%8F%E9%99%88.jpg"></p><p><img src="/2021/03/30/love/xxh.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> life </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Network Interview</title>
      <link href="2021/03/24/interview-1/"/>
      <url>2021/03/24/interview-1/</url>
      
        <content type="html"><![CDATA[<h2 id="1-TIME-WAIT过多"><a href="#1-TIME-WAIT过多" class="headerlink" title="1. TIME_WAIT过多"></a>1. TIME_WAIT过多</h2><h3 id="1-1原因"><a href="#1-1原因" class="headerlink" title="1.1原因"></a>1.1原因</h3><p>首先，产生<code>TIME_WIAT</code>是主动关闭链接的一方（课本上以客户端讲解）。</p><p>其次，产生过多<code>TIME_WAIT</code>最典型的是通信双方使用短链接。</p><p>服务器上有过多<code>TIME_WIAT</code>说明服务器主动关闭服务链接。如果通信都是用短链接，某个端口有上万个链接，那么服务器关闭端口会产生至少上万个<code>TIME_WAIT</code>记录。</p><p>客户端<code>TIME_WAIT</code>状态，在高并发场景下，如果有大量的短链接，客户端所在的操作系统的socket端口和文件描述符被用尽。</p><h3 id="1-2-time-wait过多解决方法"><a href="#1-2-time-wait过多解决方法" class="headerlink" title="1.2 time_wait过多解决方法"></a>1.2 time_wait过多解决方法</h3><pre class="line-numbers language-none"><code class="language-none">netstat -an | awk '/^tcp/ {++State[$NF]}END{for(key in State)print key "\t" State[key]}'LAST_ACK 14SYN_RECV 348ESTABLISHED 70FIN_WAIT1 229FIN_WAIT2 30CLOSING 33TIME_WAIT 18122<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>命令解释：</p><pre class="line-numbers language-none"><code class="language-none">先来看看netstat：netstat -nActive Internet connections (w/o servers)Proto Recv-Q Send-Q Local Address Foreign Address Statetcp 0 0 123.123.123.123:80 234.234.234.234:12345 TIME_WAIT你实际执行这条命令的时候，可能会得到成千上万条类似上面的记录，不过我们就拿其中的一条就足够了。再来看看awk：/^tcp/滤出tcp开头的记录，屏蔽udp, socket等无关记录。state[]相当于定义了一个名叫state的数组NF表示记录的字段数，如上所示的记录，NF等于6$NF表示某个字段的值，如上所示的记录，$NF也就是$6，表示第6个字段的值，也就是TIME_WAITstate[$NF]表示数组元素的值，如上所示的记录，就是state[TIME_WAIT]状态的连接数++state[$NF]表示把某个数加一，如上所示的记录，就是把state[TIME_WAIT]状态的连接数加一END表示在最后阶段要执行的命令for(key in state)遍历数组<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>处理TIMEWAIT：</p><p>编辑内核文件/etc/sysctl.conf，加入以下内容：</p><pre class="line-numbers language-none"><code class="language-none">net.ipv4.tcp_syncookies = 1 表示开启SYN Cookies。当出现SYN等待队列溢出时，启用cookies来处理，可防范少量SYN攻击，默认为0，表示关闭；net.ipv4.tcp_tw_reuse = 1 表示开启重用。允许将TIME-WAIT sockets重新用于新的TCP连接，默认为0，表示关闭；net.ipv4.tcp_tw_recycle = 1 表示开启TCP连接中TIME-WAIT sockets的快速回收，默认为0，表示关闭。net.ipv4.tcp_fin_timeout 修改系默认的 TIMEOUT 时间<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>然后执行 /sbin/sysctl -p 让参数生效.</p><pre class="line-numbers language-none"><code class="language-none">/etc/sysctl.conf是一个允许改变正在运行中的Linux系统的接口，它包含一些TCP/IP堆栈和虚拟内存系统的高级选项，修改内核参数永久生效。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>简单来说，就是打开系统的TIMEWAIT重用和快速回收。</p><p>如果以上配置调优后性能还不理想，可继续修改一下配置：</p><pre class="line-numbers language-none"><code class="language-none">vi /etc/sysctl.confnet.ipv4.tcp_keepalive_time = 1200 #表示当keepalive起用的时候，TCP发送keepalive消息的频度。缺省是2小时，改为20分钟。net.ipv4.ip_local_port_range = 1024 65000 #表示用于向外连接的端口范围。缺省情况下很小：32768到61000，改为1024到65000。net.ipv4.tcp_max_syn_backlog = 8192 #表示SYN队列的长度，默认为1024，加大队列长度为8192，可以容纳更多等待连接的网络连接数。net.ipv4.tcp_max_tw_buckets = 5000 #表示系统同时保持TIME_WAIT套接字的最大数量，如果超过这个数字，TIME_WAIT套接字将立刻被清除并打印警告信息。默认为180000，改为5000。对于Apache、Nginx等服务器，上几行的参数可以很好地减少TIME_WAIT套接字数量，但是对于 Squid，效果却不大。此项参数可以控制TIME_WAIT套接字的最大数量，避免Squid服务器被大量的TIME_WAIT套接字拖死。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> network </category>
          
      </categories>
      
      
        <tags>
            
            <tag> interview </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Interview</title>
      <link href="2021/03/24/interview/"/>
      <url>2021/03/24/interview/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>在线教育项目实战</title>
      <link href="2021/03/23/project/"/>
      <url>2021/03/23/project/</url>
      
        <content type="html"><![CDATA[<h1 id="在线教育平台"><a href="#在线教育平台" class="headerlink" title="在线教育平台"></a>在线教育平台</h1><h2 id="1-结构"><a href="#1-结构" class="headerlink" title="1.结构"></a>1.结构</h2><p>本平台商业模式是B2B2C模式。</p><p>拥有系统后台（管理员使用）、系统前台（普通用户使用）。</p><table><thead><tr><th align="center">后台（7大模块）</th><th align="center">前台</th></tr></thead><tbody><tr><td align="center">讲师管理模块</td><td align="center">首页数据显示</td></tr><tr><td align="center">课程分类管理模块</td><td align="center">讲师列表和详情</td></tr><tr><td align="center">课程管理模块（1）视频</td><td align="center">课程列表和课程详情（1）视频的在线播放</td></tr><tr><td align="center">统计分析模块</td><td align="center">登录和注册</td></tr><tr><td align="center">订单管理</td><td align="center">微信扫码登录</td></tr><tr><td align="center">banner管理（幻灯片切换）</td><td align="center">微信扫码支付</td></tr><tr><td align="center">权限管理</td><td align="center"></td></tr></tbody></table><h3 id="1-1-使用技术"><a href="#1-1-使用技术" class="headerlink" title="1.1 使用技术"></a>1.1 使用技术</h3><p>项目使用 前后端分离开发</p><p><img src="/2021/03/23/project/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB.PNG"></p><table><thead><tr><th>后端</th><th>前端</th></tr></thead><tbody><tr><td>springboot</td><td>vue</td></tr><tr><td>springcloud</td><td>element-ui</td></tr><tr><td>MybatisPlus</td><td>axios</td></tr><tr><td>spring security</td><td>node.js</td></tr><tr><td>redis</td><td></td></tr><tr><td>maven</td><td></td></tr><tr><td>easyExcel</td><td></td></tr><tr><td>jwt</td><td></td></tr><tr><td>OAuth2</td><td></td></tr></tbody></table><p>其他技术：阿里云oss、阿里云视频点播服务、阿里云短信服务、微信支付和登录、docker、git、jenkins</p><h2 id="2-MybatisPlus"><a href="#2-MybatisPlus" class="headerlink" title="2.MybatisPlus"></a>2.MybatisPlus</h2><p>官网：<a href="http://mp.baomidou.com/">http://mp.baomidou.com/</a></p><p>参考教程：<a href="http://mp.baomidou.com/guide/">http://mp.baomidou.com/guide/</a></p><p>MP是一个MyBatis的增强工具，在Mybatis的基础上只做增强不做改变，为简化开发、提高效率而生。</p><h3 id="2-1-开发步骤"><a href="#2-1-开发步骤" class="headerlink" title="2.1 开发步骤"></a>2.1 开发步骤</h3><h4 id="2-1-1-创建数据库"><a href="#2-1-1-创建数据库" class="headerlink" title="2.1.1 创建数据库"></a>2.1.1 创建数据库</h4><p>创建数据库表，添加数据，用于mp操作。</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">USE `mybatis_plus`;CREATE TABLE `user`(`id` BIGINT(20) NOT NULL COMMENT '主键id',`name` VARCHAR(30) NULL DEFAULT NULL COMMENT '姓名',`age` INT(11) NULL DEFAULT NULL COMMENT '年龄',`email` VARCHAR(50) NULL DEFAULT NULL COMMENT '邮箱',PRIMARY KEY (id));INSERT INTO `user` (id,`name`,age,email) VALUES (1, 'Jone',18,'test1@baomidou.com'),(2, 'Jack', 20, 'test2@baomidou.com'),(3, 'Tom', 28, 'test3@baomidou.com'),(4, 'Sandy', 21, 'test4@baomidou.com'),(5, 'Billie', 24, 'test5@baomidou.com');<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-1-2-创建springboot工程"><a href="#2-1-2-创建springboot工程" class="headerlink" title="2.1.2 创建springboot工程"></a>2.1.2 创建springboot工程</h4><p>主要就是操作idea，springboot版本使用2.2.1.RELEASE</p><h4 id="2-1-3-引入依赖"><a href="#2-1-3-引入依赖" class="headerlink" title="2.1.3 引入依赖"></a>2.1.3 引入依赖</h4><p>springboot和mp的依赖。</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencies</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-boot-starter<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-boot-starter-test<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>scope</span><span class="token punctuation">&gt;</span></span>test<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>scope</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>exclusions</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>exclusion</span><span class="token punctuation">&gt;</span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.junit.vintage<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>junit-vintage-engine<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>exclusion</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>exclusions</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>com.baomidou<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>mybatis-plus-boot-starter<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>3.0.5<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>mysql<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>mysql-connector-java<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>8.0.23<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.projectlombok<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>lombok<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>1.18.18<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependencies</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-1-4-配置application-properties"><a href="#2-1-4-配置application-properties" class="headerlink" title="2.1.4 配置application.properties"></a>2.1.4 配置application.properties</h4><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver #如果是mysql 8+ 需要加cj和下面的时区spring.datasource.url=jdbc:mysql://localhost:3306/mybatis_plus?serverTimezone=GMT%2B8spring.datasource.username=rootspring.datasource.password=000<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>另一种配置文件是yml，也可以。</p><h4 id="2-1-5-写代码"><a href="#2-1-5-写代码" class="headerlink" title="2.1.5 写代码"></a>2.1.5 写代码</h4><ul><li>实体类</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Data</span><span class="token annotation punctuation">@AllArgsConstructor</span><span class="token annotation punctuation">@NoArgsConstructor</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">User</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token class-name">Long</span> id<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">Integer</span> age<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> email<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>启动类</li></ul><p>启动类加mapperscan，自动扫描对应的mapper</p><h4 id="2-1-6-性能分析插件"><a href="#2-1-6-性能分析插件" class="headerlink" title="2.1.6 性能分析插件"></a>2.1.6 性能分析插件</h4><p>性能分析拦截器：</p><ol><li>在配置类中加上性能分析插件：</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Bean</span><span class="token annotation punctuation">@Profile</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token string">"dev"</span><span class="token punctuation">,</span><span class="token string">"test"</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token comment">//有三种环境：dev : 开发环境，test : 测试环境， prod : 生产环境</span><span class="token keyword">public</span> <span class="token class-name">PerformanceInterceptor</span> <span class="token function">performanceInterceptor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token class-name">PerformanceInterceptor</span> performanceInterceptor <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PerformanceInterceptor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    performanceInterceptor<span class="token punctuation">.</span><span class="token function">setMaxTime</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//ms,超过此处设置的ms则sql不执行</span>    performanceInterceptor<span class="token punctuation">.</span><span class="token function">setFormat</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> performanceInterceptor<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li>Springboot中设置dev环境</li></ol><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">spring.profiles.active=dev<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="3-搭建项目"><a href="#3-搭建项目" class="headerlink" title="3. 搭建项目"></a>3. 搭建项目</h2><h3 id="3-1模块说明"><a href="#3-1模块说明" class="headerlink" title="3.1模块说明"></a>3.1模块说明</h3><p><strong>guli-parent：在线教学根目录（父工程），管理四个子模块：</strong></p><p>  <strong>canal-client</strong>：canal数据库表同步模块（统计同步数据）**</p><p>  <strong>common</strong>：公共模块父节点**</p><p>​    common-util：工具类模块，所有模块都可以依赖于它</p><p>​    service-base：service服务的base包，包含service服务的公共配置类，所有service模块依赖于它</p><p>​    spring-security：认证与授权模块，需要认证授权的service服务依赖于它</p><p>  <strong>infrastructure</strong>：基础服务模块父节点**</p><p>​    api-gateway：api网关服务</p><p>  <strong>service</strong>：api接口服务父节点**</p><blockquote><blockquote><blockquote><p>service-acl：用户权限管理api接口服务（用户管理、角色管理和权限管理等）</p></blockquote></blockquote><blockquote><blockquote><p>service-cms：cms api接口服务</p></blockquote></blockquote><blockquote><blockquote><p>service-edu：教学相关api接口服务</p></blockquote></blockquote><blockquote><blockquote><p>service-msm：短信api接口服务</p></blockquote></blockquote><blockquote><blockquote><p>service-order：订单相关api接口服务</p></blockquote></blockquote><blockquote><blockquote><p>service-oss：阿里云oss api接口服务</p></blockquote></blockquote><blockquote><blockquote><p>service-statistics：统计报表api接口服务</p></blockquote></blockquote><blockquote><blockquote><p>service-ucenter：会员api接口服务</p></blockquote></blockquote><blockquote><blockquote><p>service-vod：视频点播api接口服务</p></blockquote></blockquote></blockquote><h3 id="3-2-父工程中添加依赖"><a href="#3-2-父工程中添加依赖" class="headerlink" title="3.2 父工程中添加依赖"></a>3.2 父工程中添加依赖</h3><p>在<artifactid>节点后面添加pom类型</artifactid></p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>guli-parent<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>packaging</span><span class="token punctuation">&gt;</span></span>pom<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>packaging</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>添加properties确定依赖版本</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>properties</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>java.version</span><span class="token punctuation">&gt;</span></span>1.8<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>java.version</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>guli.version</span><span class="token punctuation">&gt;</span></span>0.0.1-SNAPSHOT<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>guli.version</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>mybatis-plus.version</span><span class="token punctuation">&gt;</span></span>3.0.5<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>mybatis-plus.version</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>velocity.version</span><span class="token punctuation">&gt;</span></span>2.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>velocity.version</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>swagger.version</span><span class="token punctuation">&gt;</span></span>2.7.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>swagger.version</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>aliyun.oss.version</span><span class="token punctuation">&gt;</span></span>2.8.3<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>aliyun.oss.version</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>jodatime.version</span><span class="token punctuation">&gt;</span></span>2.10.1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>jodatime.version</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>poi.version</span><span class="token punctuation">&gt;</span></span>3.17<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>poi.version</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>commons-fileupload.version</span><span class="token punctuation">&gt;</span></span>1.3.1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>commons-fileupload.version</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>commons-io.version</span><span class="token punctuation">&gt;</span></span>2.6<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>commons-io.version</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>httpclient.version</span><span class="token punctuation">&gt;</span></span>4.5.1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>httpclient.version</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>jwt.version</span><span class="token punctuation">&gt;</span></span>0.7.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>jwt.version</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>aliyun-java-sdk-core.version</span><span class="token punctuation">&gt;</span></span>4.3.3<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>aliyun-java-sdk-core.version</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>aliyun-sdk-oss.version</span><span class="token punctuation">&gt;</span></span>3.1.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>aliyun-sdk-oss.version</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>aliyun-java-sdk-vod.version</span><span class="token punctuation">&gt;</span></span>2.15.2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>aliyun-java-sdk-vod.version</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>aliyun-java-vod-upload.version</span><span class="token punctuation">&gt;</span></span>1.4.11<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>aliyun-java-vod-upload.version</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>aliyun-sdk-vod-upload.version</span><span class="token punctuation">&gt;</span></span>1.4.11<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>aliyun-sdk-vod-upload.version</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>fastjson.version</span><span class="token punctuation">&gt;</span></span>1.2.28<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>fastjson.version</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>gson.version</span><span class="token punctuation">&gt;</span></span>2.8.2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>gson.version</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>json.version</span><span class="token punctuation">&gt;</span></span>20170516<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>json.version</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>commons-dbutils.version</span><span class="token punctuation">&gt;</span></span>1.7<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>commons-dbutils.version</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>canal.client.version</span><span class="token punctuation">&gt;</span></span>1.1.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>canal.client.version</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>docker.image.prefix</span><span class="token punctuation">&gt;</span></span>zx<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>docker.image.prefix</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>cloud-alibaba.version</span><span class="token punctuation">&gt;</span></span>0.2.2.RELEASE<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>cloud-alibaba.version</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>properties</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>配置<code>dependencyManagement</code></p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencyManagement</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencies</span><span class="token punctuation">&gt;</span></span>        <span class="token comment">&lt;!--Spring Cloud--&gt;</span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-cloud-dependencies<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>Hoxton.RELEASE<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>type</span><span class="token punctuation">&gt;</span></span>pom<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>type</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>scope</span><span class="token punctuation">&gt;</span></span>import<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>scope</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-cloud-alibaba-dependencies<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>${cloud-alibaba.version}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>type</span><span class="token punctuation">&gt;</span></span>pom<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>type</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>scope</span><span class="token punctuation">&gt;</span></span>import<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>scope</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>        <span class="token comment">&lt;!--mybatis-plus 持久层--&gt;</span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>com.baomidou<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>mybatis-plus-boot-starter<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>${mybatis-plus.version}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>        <span class="token comment">&lt;!-- velocity 模板引擎, Mybatis Plus 代码生成器需要 --&gt;</span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.apache.velocity<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>velocity-engine-core<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>${velocity.version}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>        <span class="token comment">&lt;!--swagger--&gt;</span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>io.springfox<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>springfox-swagger2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>${swagger.version}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>        <span class="token comment">&lt;!--swagger ui--&gt;</span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>io.springfox<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>springfox-swagger-ui<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>${swagger.version}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>        <span class="token comment">&lt;!--aliyunOSS--&gt;</span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>com.aliyun.oss<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>aliyun-sdk-oss<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>${aliyun.oss.version}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>        <span class="token comment">&lt;!--日期时间工具--&gt;</span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>joda-time<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>joda-time<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>${jodatime.version}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>        <span class="token comment">&lt;!--xls--&gt;</span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.apache.poi<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>poi<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>${poi.version}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>        <span class="token comment">&lt;!--xlsx--&gt;</span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.apache.poi<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>poi-ooxml<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>${poi.version}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>        <span class="token comment">&lt;!--文件上传--&gt;</span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>commons-fileupload<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>commons-fileupload<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>${commons-fileupload.version}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>        <span class="token comment">&lt;!--commons-io--&gt;</span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>commons-io<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>commons-io<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>${commons-io.version}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>        <span class="token comment">&lt;!--httpclient--&gt;</span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.apache.httpcomponents<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>httpclient<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>${httpclient.version}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>com.google.code.gson<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>gson<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>${gson.version}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>        <span class="token comment">&lt;!-- JWT --&gt;</span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>io.jsonwebtoken<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>jjwt<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>${jwt.version}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>        <span class="token comment">&lt;!--aliyun--&gt;</span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>com.aliyun<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>aliyun-java-sdk-core<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>${aliyun-java-sdk-core.version}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>com.aliyun.oss<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>aliyun-sdk-oss<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>${aliyun-sdk-oss.version}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>com.aliyun<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>aliyun-java-sdk-vod<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>${aliyun-java-sdk-vod.version}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>com.aliyun<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>aliyun-java-vod-upload<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>${aliyun-java-vod-upload.version}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>com.aliyun<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>aliyun-sdk-vod-upload<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>${aliyun-sdk-vod-upload.version}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>com.alibaba<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>fastjson<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>${fastjson.version}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.json<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>json<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>${json.version}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>commons-dbutils<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>commons-dbutils<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>${commons-dbutils.version}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>com.alibaba.otter<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>canal.client<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>${canal.client.version}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependencies</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependencyManagement</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-3-子模块service"><a href="#3-3-子模块service" class="headerlink" title="3.3 子模块service"></a>3.3 子模块service</h3><ol><li>添加模块类型是pom</li></ol><p>artifactId节点后面添加pom类型</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>service<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>packaging</span><span class="token punctuation">&gt;</span></span>pom<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>packaging</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ol start="2"><li>添加依赖</li></ol><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencies</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-cloud-starter-netflix-ribbon<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token comment">&lt;!--hystrix依赖，主要是用  @HystrixCommand --&gt;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-cloud-starter-netflix-hystrix<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token comment">&lt;!--服务注册--&gt;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-cloud-starter-alibaba-nacos-discovery<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token comment">&lt;!--服务调用--&gt;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-cloud-starter-openfeign<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-boot-starter-web<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token comment">&lt;!--mybatis-plus--&gt;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>com.baomidou<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>mybatis-plus-boot-starter<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token comment">&lt;!--mysql--&gt;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>mysql<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>mysql-connector-java<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token comment">&lt;!-- velocity 模板引擎, Mybatis Plus 代码生成器需要 --&gt;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.apache.velocity<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>velocity-engine-core<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token comment">&lt;!--swagger--&gt;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>io.springfox<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>springfox-swagger2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>io.springfox<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>springfox-swagger-ui<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token comment">&lt;!--lombok用来简化实体类：需要安装lombok插件--&gt;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.projectlombok<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>lombok<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token comment">&lt;!--xls--&gt;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.apache.poi<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>poi<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.apache.poi<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>poi-ooxml<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>commons-fileupload<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>commons-fileupload<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token comment">&lt;!--httpclient--&gt;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.apache.httpcomponents<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>httpclient<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token comment">&lt;!--commons-io--&gt;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>commons-io<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>commons-io<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token comment">&lt;!--gson--&gt;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>com.google.code.gson<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>gson<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>junit<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>junit<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>4.12<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependencies</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-4开发讲师管理模块"><a href="#3-4开发讲师管理模块" class="headerlink" title="3.4开发讲师管理模块"></a>3.4开发讲师管理模块</h3><ol><li><p>创建application.properties文件</p></li><li><p>编写controller、 service 、 mapper 内容</p></li></ol><p>mp提供了代码生成器，生成相关代码</p><p><strong>resources目录下创建文件 application.properties</strong></p><pre class="line-numbers language-none"><code class="language-none"># 服务端口server.port=8001# 服务名spring.application.name=service-edu# 环境设置：dev、test、prodspring.profiles.active=dev# mysql数据库连接spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driverspring.datasource.url=jdbc:mysql://localhost:3306/guli?serverTimezone=GMT%2B8spring.datasource.username=rootspring.datasource.password=root#mybatis日志mybatis-plus.configuration.log-impl=org.apache.ibatis.logging.stdout.StdOutImpl<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id=""><a href="#" class="headerlink" title=""></a></h2><p><strong>或者在resources目录下创建文件 application.yml</strong></p> <pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token comment"># 服务端口</span><span class="token attr-name">server.port</span><span class="token punctuation">=</span><span class="token attr-value">8001</span><span class="token comment"># 服务名</span><span class="token attr-name">spring.application.name</span><span class="token punctuation">=</span><span class="token attr-value">service-edu</span><span class="token comment"># 环境设置：dev、test、prod</span><span class="token attr-name">spring.profiles.active</span><span class="token punctuation">=</span><span class="token attr-value">dev</span><span class="token comment"># mysql数据库连接</span><span class="token attr-name">spring.datasource.driver-class-name</span><span class="token punctuation">=</span><span class="token attr-value">com.mysql.cj.jdbc.Driver</span><span class="token attr-name">spring.datasource.url</span><span class="token punctuation">=</span><span class="token attr-value">jdbc:mysql://localhost:3306/guli?serverTimezone=GMT%2B8</span><span class="token attr-name">spring.datasource.username</span><span class="token punctuation">=</span><span class="token attr-value">root</span><span class="token attr-name">spring.datasource.password</span><span class="token punctuation">=</span><span class="token attr-value">000</span><span class="token comment">#返回json的全局时间格式</span><span class="token attr-name">spring.jackson.date-format</span><span class="token punctuation">=</span><span class="token attr-value">yyyy-MM-dd HH:mm:ss</span><span class="token attr-name">spring.jackson.time-zone</span><span class="token punctuation">=</span><span class="token attr-value">GMT+8</span><span class="token comment">#mybatis日志</span><span class="token attr-name">mybatis-plus.configuration.log-impl</span><span class="token punctuation">=</span><span class="token attr-value">org.apache.ibatis.logging.stdout.StdOutImpl</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>或者：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token comment">#### application.yml</span><span class="token key atrule">spring</span><span class="token punctuation">:</span>  <span class="token key atrule">application</span><span class="token punctuation">:</span>    <span class="token key atrule">name</span><span class="token punctuation">:</span> service<span class="token punctuation">-</span>edu<span class="token key atrule">profiles</span><span class="token punctuation">:</span>    <span class="token key atrule">active</span><span class="token punctuation">:</span> dev<span class="token comment">####  application-dev.yml</span><span class="token key atrule">server</span><span class="token punctuation">:</span>  <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">8001</span><span class="token key atrule">mybatis-plus</span><span class="token punctuation">:</span>  <span class="token key atrule">configuration</span><span class="token punctuation">:</span>    <span class="token key atrule">log-impl</span><span class="token punctuation">:</span> org.apache.ibatis.logging.stdout.StdOutImpl<span class="token key atrule">mapper-locations</span><span class="token punctuation">:</span> classpath<span class="token punctuation">:</span>com/atguigu/service/<span class="token important">*/mapper/*.xml</span><span class="token key atrule">global-config</span><span class="token punctuation">:</span>    <span class="token key atrule">db-config</span><span class="token punctuation">:</span>      <span class="token key atrule">logic-delete-value</span><span class="token punctuation">:</span> <span class="token number">1</span><span class="token key atrule">logic-not-delete-value</span><span class="token punctuation">:</span> <span class="token number">0</span><span class="token key atrule">spring</span><span class="token punctuation">:</span><span class="token key atrule">datasource</span><span class="token punctuation">:</span>    <span class="token key atrule">type</span><span class="token punctuation">:</span> com.zaxxer.hikari.HikariDataSource<span class="token key atrule">driver-class-name</span><span class="token punctuation">:</span> com.mysql.cj.jdbc.Driver<span class="token key atrule">url</span><span class="token punctuation">:</span> jdbc<span class="token punctuation">:</span>mysql<span class="token punctuation">:</span>//localhost<span class="token punctuation">:</span>3306/guli<span class="token punctuation">?</span>serverTimezone=GMT%2B8<span class="token key atrule">username</span><span class="token punctuation">:</span> root<span class="token key atrule">password</span><span class="token punctuation">:</span> root<span class="token key atrule">hikari</span><span class="token punctuation">:</span>      <span class="token key atrule">connection-test-query</span><span class="token punctuation">:</span> SELECT 1<span class="token key atrule">connection-timeout</span><span class="token punctuation">:</span> <span class="token number">60000</span><span class="token key atrule">idle-timeout</span><span class="token punctuation">:</span> <span class="token number">500000</span><span class="token key atrule">max-lifetime</span><span class="token punctuation">:</span> <span class="token number">540000</span><span class="token key atrule">maximum-pool-size</span><span class="token punctuation">:</span> <span class="token number">12</span><span class="token key atrule">minimum-idle</span><span class="token punctuation">:</span> <span class="token number">10</span><span class="token key atrule">pool-name</span><span class="token punctuation">:</span> GuliHikariPool<span class="token key atrule">jackson</span><span class="token punctuation">:</span>    <span class="token key atrule">date-format</span><span class="token punctuation">:</span> yyyy<span class="token punctuation">-</span>MM<span class="token punctuation">-</span>dd HH<span class="token punctuation">:</span>mm<span class="token punctuation">:</span>ss<span class="token key atrule">time-zone</span><span class="token punctuation">:</span> GMT+8<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-4-1-创建MP代码生成器"><a href="#3-4-1-创建MP代码生成器" class="headerlink" title="3.4.1 创建MP代码生成器"></a>3.4.1 创建MP代码生成器</h4><p>在test/java目录下创建包<code>com.atguigu.eduservice</code>，创建代码生成器：<code>CodeGenerator.java</code></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> getCode <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">main1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// 1、创建代码生成器</span>        <span class="token class-name">AutoGenerator</span> mpg <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AutoGenerator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 2、全局配置</span>        <span class="token class-name">GlobalConfig</span> gc <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">GlobalConfig</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">String</span> projectPath <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">getProperty</span><span class="token punctuation">(</span><span class="token string">"user.dir"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>projectPath<span class="token punctuation">)</span><span class="token punctuation">;</span>        gc<span class="token punctuation">.</span><span class="token function">setOutputDir</span><span class="token punctuation">(</span>projectPath <span class="token operator">+</span> <span class="token string">"/src/main/java"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        gc<span class="token punctuation">.</span><span class="token function">setAuthor</span><span class="token punctuation">(</span><span class="token string">"atguigu"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        gc<span class="token punctuation">.</span><span class="token function">setOpen</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//生成后是否打开资源管理器</span>        gc<span class="token punctuation">.</span><span class="token function">setFileOverride</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//重新生成时文件是否覆盖</span>        <span class="token comment">/*         * mp生成service层代码，默认接口名称第一个字母有 I         * UcenterService         * */</span>        gc<span class="token punctuation">.</span><span class="token function">setServiceName</span><span class="token punctuation">(</span><span class="token string">"%sService"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//去掉Service接口的首字母I</span>        gc<span class="token punctuation">.</span><span class="token function">setIdType</span><span class="token punctuation">(</span><span class="token class-name">IdType</span><span class="token punctuation">.</span>ID_WORKER<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//主键策略</span>        gc<span class="token punctuation">.</span><span class="token function">setDateType</span><span class="token punctuation">(</span><span class="token class-name">DateType</span><span class="token punctuation">.</span>ONLY_DATE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//定义生成的实体类中日期类型</span>        gc<span class="token punctuation">.</span><span class="token function">setSwagger2</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//开启Swagger2模式</span>        mpg<span class="token punctuation">.</span><span class="token function">setGlobalConfig</span><span class="token punctuation">(</span>gc<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 3、数据源配置</span>        <span class="token class-name">DataSourceConfig</span> dsc <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DataSourceConfig</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        dsc<span class="token punctuation">.</span><span class="token function">setUrl</span><span class="token punctuation">(</span><span class="token string">"jdbc:mysql://localhost:3306/guli?serverTimezone=GMT%2B8"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        dsc<span class="token punctuation">.</span><span class="token function">setDriverName</span><span class="token punctuation">(</span><span class="token string">"com.mysql.cj.jdbc.Driver"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        dsc<span class="token punctuation">.</span><span class="token function">setUsername</span><span class="token punctuation">(</span><span class="token string">"root"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        dsc<span class="token punctuation">.</span><span class="token function">setPassword</span><span class="token punctuation">(</span><span class="token string">"root"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        dsc<span class="token punctuation">.</span><span class="token function">setDbType</span><span class="token punctuation">(</span><span class="token class-name">DbType</span><span class="token punctuation">.</span>MYSQL<span class="token punctuation">)</span><span class="token punctuation">;</span>        mpg<span class="token punctuation">.</span><span class="token function">setDataSource</span><span class="token punctuation">(</span>dsc<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 4、包配置</span>        <span class="token class-name">PackageConfig</span> pc <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PackageConfig</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        pc<span class="token punctuation">.</span><span class="token function">setModuleName</span><span class="token punctuation">(</span><span class="token string">"serviceedu"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//模块名</span>        pc<span class="token punctuation">.</span><span class="token function">setParent</span><span class="token punctuation">(</span><span class="token string">"com.atguigu"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        pc<span class="token punctuation">.</span><span class="token function">setController</span><span class="token punctuation">(</span><span class="token string">"controller"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        pc<span class="token punctuation">.</span><span class="token function">setEntity</span><span class="token punctuation">(</span><span class="token string">"entity"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        pc<span class="token punctuation">.</span><span class="token function">setService</span><span class="token punctuation">(</span><span class="token string">"service"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        pc<span class="token punctuation">.</span><span class="token function">setMapper</span><span class="token punctuation">(</span><span class="token string">"mapper"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        mpg<span class="token punctuation">.</span><span class="token function">setPackageInfo</span><span class="token punctuation">(</span>pc<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 5、策略配置</span>        <span class="token class-name">StrategyConfig</span> strategy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StrategyConfig</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        strategy<span class="token punctuation">.</span><span class="token function">setInclude</span><span class="token punctuation">(</span><span class="token string">"edu_teacher"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        strategy<span class="token punctuation">.</span><span class="token function">setNaming</span><span class="token punctuation">(</span><span class="token class-name">NamingStrategy</span><span class="token punctuation">.</span>underline_to_camel<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//数据库表映射到实体的命名策略</span>        strategy<span class="token punctuation">.</span><span class="token function">setTablePrefix</span><span class="token punctuation">(</span>pc<span class="token punctuation">.</span><span class="token function">getModuleName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"_"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//生成实体时去掉表前缀</span>        strategy<span class="token punctuation">.</span><span class="token function">setColumnNaming</span><span class="token punctuation">(</span><span class="token class-name">NamingStrategy</span><span class="token punctuation">.</span>underline_to_camel<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//数据库表字段映射到实体的命名策略</span>        strategy<span class="token punctuation">.</span><span class="token function">setEntityLombokModel</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// lombok 模型 @Accessors(chain = true) setter链式操作</span>        strategy<span class="token punctuation">.</span><span class="token function">setRestControllerStyle</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//restful api风格控制器</span>        strategy<span class="token punctuation">.</span><span class="token function">setControllerMappingHyphenStyle</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//url中驼峰转连字符</span>        mpg<span class="token punctuation">.</span><span class="token function">setStrategy</span><span class="token punctuation">(</span>strategy<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 6、执行</span>        mpg<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-4-2-编写后台管理api接口"><a href="#3-4-2-编写后台管理api接口" class="headerlink" title="3.4.2 编写后台管理api接口"></a>3.4.2 编写后台管理api接口</h4><p><strong>1、编写controller代码</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Autowired</span><span class="token keyword">private</span> <span class="token class-name">TeacherService</span> teacherService<span class="token punctuation">;</span><span class="token annotation punctuation">@GetMapping</span><span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Teacher</span><span class="token punctuation">&gt;</span></span> <span class="token function">list</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> teacherService<span class="token punctuation">.</span><span class="token function">list</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>2. 创建SpringBoot配置类</strong></p><p>在edu包下创建config包，创建MyBatisPlusConfig.java</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>guli<span class="token punctuation">.</span>edu<span class="token punctuation">.</span>config</span><span class="token punctuation">;</span><span class="token annotation punctuation">@Configuration</span><span class="token annotation punctuation">@EnableTransactionManagement</span><span class="token annotation punctuation">@MapperScan</span><span class="token punctuation">(</span><span class="token string">"com.atguigu.eduservice.mapper"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyBatisPlusConfig</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>3、配置SQL执行性能分析插件</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/**     * SQL 执行性能分析插件     * 开发环境使用，线上不推荐。 maxTime 指的是 sql 最大执行时长     */</span><span class="token annotation punctuation">@Bean</span><span class="token annotation punctuation">@Profile</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token string">"dev"</span><span class="token punctuation">,</span><span class="token string">"test"</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token comment">// 设置 dev test 环境开启</span><span class="token keyword">public</span> <span class="token class-name">PerformanceInterceptor</span> <span class="token function">performanceInterceptor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token class-name">PerformanceInterceptor</span> performanceInterceptor <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PerformanceInterceptor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    performanceInterceptor<span class="token punctuation">.</span><span class="token function">setMaxTime</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//ms，超过此处设置的ms则sql不执行</span>    performanceInterceptor<span class="token punctuation">.</span><span class="token function">setFormat</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> performanceInterceptor<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-4-3-创建SpringBoot启动类"><a href="#3-4-3-创建SpringBoot启动类" class="headerlink" title="3.4.3 创建SpringBoot启动类**"></a>3.4.3 创建SpringBoot启动类**</h4><p>创建启动类 EduApplication.java，注意启动类的创建位置</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@SpringBootApplication</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">EduApplication</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">SpringApplication</span><span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token class-name">EduApplication</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-4-4-运行启动类"><a href="#3-4-4-运行启动类" class="headerlink" title="3.4.4 运行启动类"></a>3.4.4 运行启动类</h4><p>访问<a href="http://localhost:8001/eduservice/teacher">http://localhost:8001/eduservice/teacher</a></p><p>得到json数据</p><h4 id="3-4-5-统一返回的json时间格式"><a href="#3-4-5-统一返回的json时间格式" class="headerlink" title="3.4.5 统一返回的json时间格式"></a>3.4.5 统一返回的json时间格式</h4><p>默认情况下json时间格式带有时区，并且是世界标准时间，和我们的时间差了八个小时</p><p>在application.properties中设置</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">#返回json的全局时间格式spring.jackson.date-format=yyyy-MM-dd HH:mm:ssspring.jackson.time-zone=GMT+8<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="3-5-讲师逻辑删除"><a href="#3-5-讲师逻辑删除" class="headerlink" title="3.5 讲师逻辑删除"></a>3.5 讲师逻辑删除</h3><h4 id="3-5-1-EduTeacherController添加删除方法"><a href="#3-5-1-EduTeacherController添加删除方法" class="headerlink" title="3.5.1 EduTeacherController添加删除方法"></a>3.5.1 EduTeacherController添加删除方法</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@DeleteMapping</span><span class="token punctuation">(</span><span class="token string">"{id}"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">removeById</span><span class="token punctuation">(</span><span class="token annotation punctuation">@PathVariable</span> <span class="token class-name">String</span> id<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> teacherService<span class="token punctuation">.</span><span class="token function">removeById</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-5-2-配置逻辑删除插件"><a href="#3-5-2-配置逻辑删除插件" class="headerlink" title="3.5.2 配置逻辑删除插件"></a>3.5.2 配置逻辑删除插件</h4><pre class="line-numbers language-none"><code class="language-none">MyBatisPlusConfig中配置<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/**      * 逻辑删除插件      */</span><span class="token annotation punctuation">@Bean</span><span class="token keyword">public</span> <span class="token class-name">ISqlInjector</span> <span class="token function">sqlInjector</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">LogicSqlInjector</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-6-Swagger2介绍"><a href="#3-6-Swagger2介绍" class="headerlink" title="3.6 Swagger2介绍"></a>3.6 Swagger2介绍</h3><p>前后端分离开发模式中，api文档是最好的沟通方式。</p><p>Swagger 是一个规范和完整的框架，用于生成、描述、调用和可视化 RESTful 风格的 Web 服务。</p><p>及时性 (接口变更后，能够及时准确地通知相关前后端开发人员)规范性 (并且保证接口的规范性，如接口的地址，请求方式，参数及响应格式和错误信息)一致性 (接口信息一致，不会出现因开发人员拿到的文档版本不一致，而出现分歧)可测性 (直接在接口文档上进行测试，以方便理解业务)</p><h4 id="3-6-1-配置Swagger2"><a href="#3-6-1-配置Swagger2" class="headerlink" title="3.6.1 配置Swagger2"></a>3.6.1 配置Swagger2</h4><p><strong>1、创建common模块</strong></p><p><strong>在guli-parent下创建模块common</strong></p><p>配置：</p><p><code>groupId：com.atguigu</code></p><p><code>artifactId：common</code></p><p><img src="/2021/03/23/project/9a40d77c-6b22-4f24-a288-c76d1082f98d.png" alt="img"></p><p><strong>2、在common中引入相关依赖</strong></p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencies</span><span class="token punctuation">&gt;</span></span>       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>           <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>           <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-boot-starter-web<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>           <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>scope</span><span class="token punctuation">&gt;</span></span>provided <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>scope</span><span class="token punctuation">&gt;</span></span>       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>       <span class="token comment">&lt;!--mybatis-plus--&gt;</span>       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>           <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>com.baomidou<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>           <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>mybatis-plus-boot-starter<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>           <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>scope</span><span class="token punctuation">&gt;</span></span>provided <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>scope</span><span class="token punctuation">&gt;</span></span>       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>       <span class="token comment">&lt;!--lombok用来简化实体类：需要安装lombok插件--&gt;</span>       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>           <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.projectlombok<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>           <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>lombok<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>           <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>scope</span><span class="token punctuation">&gt;</span></span>provided <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>scope</span><span class="token punctuation">&gt;</span></span>       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>       <span class="token comment">&lt;!--swagger--&gt;</span>       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>           <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>io.springfox<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>           <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>springfox-swagger2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>           <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>scope</span><span class="token punctuation">&gt;</span></span>provided <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>scope</span><span class="token punctuation">&gt;</span></span>       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>           <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>io.springfox<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>           <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>springfox-swagger-ui<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>           <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>scope</span><span class="token punctuation">&gt;</span></span>provided <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>scope</span><span class="token punctuation">&gt;</span></span>       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>       <span class="token comment">&lt;!-- redis --&gt;</span>       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>           <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>           <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-boot-starter-data-redis<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>       <span class="token comment">&lt;!-- spring2.X集成redis所需common-pool2       &lt;dependency&gt;           &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;           &lt;artifactId&gt;commons-pool2&lt;/artifactId&gt;           &lt;version&gt;2.6.0&lt;/version&gt;       &lt;/dependency&gt;--&gt;</span>   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependencies</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>3.在模块service-base中，创建swagger的配置类</strong></p><p>创建包<code>com.atguigu.servicebase.config</code>，创建类<code>SwaggerConfig</code></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span><span class="token annotation punctuation">@EnableSwagger2</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SwaggerConfig</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> <span class="token class-name">Docket</span> <span class="token function">webApiConfig</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Docket</span><span class="token punctuation">(</span><span class="token class-name">DocumentationType</span><span class="token punctuation">.</span>SWAGGER_2<span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">groupName</span><span class="token punctuation">(</span><span class="token string">"webApi"</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">apiInfo</span><span class="token punctuation">(</span><span class="token function">webApiInfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">select</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">paths</span><span class="token punctuation">(</span><span class="token class-name">Predicates</span><span class="token punctuation">.</span><span class="token function">not</span><span class="token punctuation">(</span><span class="token class-name">PathSelectors</span><span class="token punctuation">.</span><span class="token function">regex</span><span class="token punctuation">(</span><span class="token string">"/admin/.*"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">paths</span><span class="token punctuation">(</span><span class="token class-name">Predicates</span><span class="token punctuation">.</span><span class="token function">not</span><span class="token punctuation">(</span><span class="token class-name">PathSelectors</span><span class="token punctuation">.</span><span class="token function">regex</span><span class="token punctuation">(</span><span class="token string">"/error.*"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>        <span class="token keyword">private</span> <span class="token class-name">ApiInfo</span> <span class="token function">webApiInfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ApiInfoBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">title</span><span class="token punctuation">(</span><span class="token string">"网站-课程中心API文档"</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">description</span><span class="token punctuation">(</span><span class="token string">"本文档描述了课程中心微服务接口定义"</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">version</span><span class="token punctuation">(</span><span class="token string">"1.0"</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">contact</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Contact</span><span class="token punctuation">(</span><span class="token string">"Helen"</span><span class="token punctuation">,</span> <span class="token string">"http://atguigu.com"</span><span class="token punctuation">,</span> <span class="token string">"55317332@qq.com"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>4、在模块service模块中引入service-base</strong></p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>com.atguigu<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>service-base<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>0.0.1-SNAPSHOT<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>5、在service-edu启动类上添加注解，进行测试</strong></p><p><img src="/2021/03/23/project/ef45a37b-8f5b-480e-9d85-e25bf5bdd3ce.png" alt="img"></p><h4 id="3-6-2-API模型"><a href="#3-6-2-API模型" class="headerlink" title="3.6.2 API模型"></a>3.6.2 API模型</h4><p>可以添加一些自定义设置，例如：</p><p>定义样例数据</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@ApiModelProperty</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"创建时间"</span><span class="token punctuation">,</span> example <span class="token operator">=</span> <span class="token string">"2019-01-01 8:00:00"</span><span class="token punctuation">)</span><span class="token annotation punctuation">@TableField</span><span class="token punctuation">(</span>fill <span class="token operator">=</span> <span class="token class-name">FieldFill</span><span class="token punctuation">.</span>INSERT<span class="token punctuation">)</span><span class="token keyword">private</span> <span class="token class-name">Date</span> gmtCreate<span class="token punctuation">;</span><span class="token annotation punctuation">@ApiModelProperty</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"更新时间"</span><span class="token punctuation">,</span> example <span class="token operator">=</span> <span class="token string">"2019-01-01 8:00:00"</span><span class="token punctuation">)</span><span class="token annotation punctuation">@TableField</span><span class="token punctuation">(</span>fill <span class="token operator">=</span> <span class="token class-name">FieldFill</span><span class="token punctuation">.</span>INSERT_UPDATE<span class="token punctuation">)</span><span class="token keyword">private</span> <span class="token class-name">Date</span> gmtModified<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/2021/03/23/project/9c17851c-8e7e-4161-968c-18b36faf148a.png" alt="img"></p><h4 id="3-6-3-定义接口说明和参数说明"><a href="#3-6-3-定义接口说明和参数说明" class="headerlink" title="3.6.3 定义接口说明和参数说明"></a>3.6.3 定义接口说明和参数说明</h4><p>定义在类上：@Api</p><p>定义在方法上：@ApiOperation</p><p>定义在参数上：@ApiParam</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Api</span><span class="token punctuation">(</span>description<span class="token operator">=</span><span class="token string">"讲师管理"</span><span class="token punctuation">)</span><span class="token annotation punctuation">@RestController</span><span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">"/admin/edu/teacher"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TeacherAdminController</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">private</span> <span class="token class-name">TeacherService</span> teacherService<span class="token punctuation">;</span>    <span class="token annotation punctuation">@ApiOperation</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"所有讲师列表"</span><span class="token punctuation">)</span>    <span class="token annotation punctuation">@GetMapping</span>    <span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Teacher</span><span class="token punctuation">&gt;</span></span> <span class="token function">list</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> teacherService<span class="token punctuation">.</span><span class="token function">list</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@ApiOperation</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"根据ID删除讲师"</span><span class="token punctuation">)</span>    <span class="token annotation punctuation">@DeleteMapping</span><span class="token punctuation">(</span><span class="token string">"{id}"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">removeById</span><span class="token punctuation">(</span>            <span class="token annotation punctuation">@ApiParam</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"id"</span><span class="token punctuation">,</span> value <span class="token operator">=</span> <span class="token string">"讲师ID"</span><span class="token punctuation">,</span> required <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">)</span>            <span class="token annotation punctuation">@PathVariable</span> <span class="token class-name">String</span> id<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> teacherService<span class="token punctuation">.</span><span class="token function">removeById</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-7-统一返回数据格式"><a href="#3-7-统一返回数据格式" class="headerlink" title="3.7 统一返回数据格式"></a>3.7 统一返回数据格式</h3><p>项目中我们会将响应封装成<code>json</code>返回，一般我们会将所有接口的数据格式统一， 使前端(iOS Android, Web)对数据的操作更一致、轻松。</p><p>一般情况下，统一返回数据格式没有固定的格式，只要能描述清楚返回的数据状态以及要返回的具体数据就可以。但是一般会包含状态码、返回消息、数据这几部分内容</p><p>例如，我们的系统要求返回的基本数据格式如下：</p><p><strong>列表：</strong></p><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">{</span>  <span class="token property">"success"</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>  <span class="token property">"code"</span><span class="token operator">:</span> <span class="token number">20000</span><span class="token punctuation">,</span>  <span class="token property">"message"</span><span class="token operator">:</span> <span class="token string">"成功"</span><span class="token punctuation">,</span>  <span class="token property">"data"</span><span class="token operator">:</span> <span class="token punctuation">{</span>    <span class="token property">"items"</span><span class="token operator">:</span> <span class="token punctuation">[</span>      <span class="token punctuation">{</span>        <span class="token property">"id"</span><span class="token operator">:</span> <span class="token string">"1"</span><span class="token punctuation">,</span>        <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"刘德华"</span><span class="token punctuation">,</span>        <span class="token property">"intro"</span><span class="token operator">:</span> <span class="token string">"毕业于师范大学数学系，热爱教育事业，执教数学思维6年有余"</span>      <span class="token punctuation">}</span>    <span class="token punctuation">]</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>分页：</strong></p><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">{</span>  <span class="token property">"success"</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>  <span class="token property">"code"</span><span class="token operator">:</span> <span class="token number">20000</span><span class="token punctuation">,</span>  <span class="token property">"message"</span><span class="token operator">:</span> <span class="token string">"成功"</span><span class="token punctuation">,</span>  <span class="token property">"data"</span><span class="token operator">:</span> <span class="token punctuation">{</span>    <span class="token property">"total"</span><span class="token operator">:</span> <span class="token number">17</span><span class="token punctuation">,</span>    <span class="token property">"rows"</span><span class="token operator">:</span> <span class="token punctuation">[</span>      <span class="token punctuation">{</span>        <span class="token property">"id"</span><span class="token operator">:</span> <span class="token string">"1"</span><span class="token punctuation">,</span>        <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"刘德华"</span><span class="token punctuation">,</span>        <span class="token property">"intro"</span><span class="token operator">:</span> <span class="token string">"毕业于师范大学数学系，热爱教育事业，执教数学思维6年有余"</span>      <span class="token punctuation">}</span>    <span class="token punctuation">]</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>没有返回数据：</strong></p><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">{</span>  <span class="token property">"success"</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>  <span class="token property">"code"</span><span class="token operator">:</span> <span class="token number">20000</span><span class="token punctuation">,</span>  <span class="token property">"message"</span><span class="token operator">:</span> <span class="token string">"成功"</span><span class="token punctuation">,</span>  <span class="token property">"data"</span><span class="token operator">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>失败：</strong></p><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">{</span>  <span class="token property">"success"</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>  <span class="token property">"code"</span><span class="token operator">:</span> <span class="token number">20001</span><span class="token punctuation">,</span>  <span class="token property">"message"</span><span class="token operator">:</span> <span class="token string">"失败"</span><span class="token punctuation">,</span>  <span class="token property">"data"</span><span class="token operator">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>因此，我们定义统一结果</p><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">{</span>  <span class="token property">"success"</span><span class="token operator">:</span> 布尔<span class="token punctuation">,</span> <span class="token comment">//响应是否成功</span>  <span class="token property">"code"</span><span class="token operator">:</span> 数字<span class="token punctuation">,</span> <span class="token comment">//响应码</span>  <span class="token property">"message"</span><span class="token operator">:</span> 字符串<span class="token punctuation">,</span> <span class="token comment">//返回消息</span>  <span class="token property">"data"</span><span class="token operator">:</span> HashMap <span class="token comment">//返回数据，放在键值对中</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-7-2-创建统一结果返回类"><a href="#3-7-2-创建统一结果返回类" class="headerlink" title="3.7.2 创建统一结果返回类"></a>3.7.2 创建统一结果返回类</h4><p><strong>1、在common模块下创建子模块common-utils</strong></p><p><img src="/2021/03/23/project/3f2fb002-8f7c-47aa-aaf0-71da156e1b20.png" alt="img"></p><p><strong>2、创建接口定义返回码</strong></p><p><strong>创建包com.atguigu.commonutils，创建接口 ResultCode.java</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>atguigu<span class="token punctuation">.</span>commonutils</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">ResultCode</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Integer</span> SUCCESS <span class="token operator">=</span> <span class="token number">20000</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Integer</span> ERROR <span class="token operator">=</span> <span class="token number">20001</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>3、创建结果类</strong></p><p><strong>创建类 R.java</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Data</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">R</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@ApiModelProperty</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"是否成功"</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> <span class="token class-name">Boolean</span> success<span class="token punctuation">;</span>    <span class="token annotation punctuation">@ApiModelProperty</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"返回码"</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> <span class="token class-name">Integer</span> code<span class="token punctuation">;</span>    <span class="token annotation punctuation">@ApiModelProperty</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"返回消息"</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> message<span class="token punctuation">;</span>    <span class="token annotation punctuation">@ApiModelProperty</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"返回数据"</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> data <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">R</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">R</span> <span class="token function">ok</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token class-name">R</span> r <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">R</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        r<span class="token punctuation">.</span><span class="token function">setSuccess</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        r<span class="token punctuation">.</span><span class="token function">setCode</span><span class="token punctuation">(</span><span class="token class-name">ResultCode</span><span class="token punctuation">.</span>SUCCESS<span class="token punctuation">)</span><span class="token punctuation">;</span>        r<span class="token punctuation">.</span><span class="token function">setMessage</span><span class="token punctuation">(</span><span class="token string">"成功"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> r<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">R</span> <span class="token function">error</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token class-name">R</span> r <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">R</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        r<span class="token punctuation">.</span><span class="token function">setSuccess</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        r<span class="token punctuation">.</span><span class="token function">setCode</span><span class="token punctuation">(</span><span class="token class-name">ResultCode</span><span class="token punctuation">.</span>ERROR<span class="token punctuation">)</span><span class="token punctuation">;</span>        r<span class="token punctuation">.</span><span class="token function">setMessage</span><span class="token punctuation">(</span><span class="token string">"失败"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> r<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token class-name">R</span> <span class="token function">success</span><span class="token punctuation">(</span><span class="token class-name">Boolean</span> success<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setSuccess</span><span class="token punctuation">(</span>success<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token class-name">R</span> <span class="token function">message</span><span class="token punctuation">(</span><span class="token class-name">String</span> message<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setMessage</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token class-name">R</span> <span class="token function">code</span><span class="token punctuation">(</span><span class="token class-name">Integer</span> code<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setCode</span><span class="token punctuation">(</span>code<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token class-name">R</span> <span class="token function">data</span><span class="token punctuation">(</span><span class="token class-name">String</span> key<span class="token punctuation">,</span> <span class="token class-name">Object</span> value<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>data<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token class-name">R</span> <span class="token function">data</span><span class="token punctuation">(</span><span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> map<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setData</span><span class="token punctuation">(</span>map<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>二、统一返回结果使用</p><p>1、在service模块中添加依赖</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>com.atguigu<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>common_utils<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>0.0.1-SNAPSHOT<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>2、修改Controller中的返回结果</p><p>列表</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@ApiOperation</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"所有讲师列表"</span><span class="token punctuation">)</span><span class="token annotation punctuation">@GetMapping</span><span class="token keyword">public</span> <span class="token class-name">R</span> <span class="token function">list</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Teacher</span><span class="token punctuation">&gt;</span></span> list <span class="token operator">=</span> teacherService<span class="token punctuation">.</span><span class="token function">list</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token class-name">R</span><span class="token punctuation">.</span><span class="token function">ok</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">data</span><span class="token punctuation">(</span><span class="token string">"items"</span><span class="token punctuation">,</span> list<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>删除</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@ApiOperation</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"根据ID删除讲师"</span><span class="token punctuation">)</span><span class="token annotation punctuation">@DeleteMapping</span><span class="token punctuation">(</span><span class="token string">"{id}"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token class-name">R</span> <span class="token function">removeById</span><span class="token punctuation">(</span>    <span class="token annotation punctuation">@ApiParam</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"id"</span><span class="token punctuation">,</span> value <span class="token operator">=</span> <span class="token string">"讲师ID"</span><span class="token punctuation">,</span> required <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">)</span>    <span class="token annotation punctuation">@PathVariable</span> <span class="token class-name">String</span> id<span class="token punctuation">)</span><span class="token punctuation">{</span>    teacherService<span class="token punctuation">.</span><span class="token function">removeById</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token class-name">R</span><span class="token punctuation">.</span><span class="token function">ok</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-8-分页"><a href="#3-8-分页" class="headerlink" title="3.8 分页"></a>3.8 分页</h3><h4 id="3-8-1-MyBatisPlusConfig中配置分页插件"><a href="#3-8-1-MyBatisPlusConfig中配置分页插件" class="headerlink" title="3.8.1 MyBatisPlusConfig中配置分页插件"></a>3.8.1 MyBatisPlusConfig中配置分页插件</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/** * 分页插件 */</span><span class="token annotation punctuation">@Bean</span><span class="token keyword">public</span> <span class="token class-name">PaginationInterceptor</span> <span class="token function">paginationInterceptor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">PaginationInterceptor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-8-2-分页Controller方法"><a href="#3-8-2-分页Controller方法" class="headerlink" title="3.8.2 分页Controller方法"></a>3.8.2 分页Controller方法</h4><p><code>TeacherAdminController</code>中添加分页方法</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@ApiOperation</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"分页讲师列表"</span><span class="token punctuation">)</span><span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"{page}/{limit}"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token class-name">R</span> <span class="token function">pageList</span><span class="token punctuation">(</span>    <span class="token annotation punctuation">@ApiParam</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"page"</span><span class="token punctuation">,</span> value <span class="token operator">=</span> <span class="token string">"当前页码"</span><span class="token punctuation">,</span> required <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">)</span>    <span class="token annotation punctuation">@PathVariable</span> <span class="token class-name">Long</span> page<span class="token punctuation">,</span>    <span class="token annotation punctuation">@ApiParam</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"limit"</span><span class="token punctuation">,</span> value <span class="token operator">=</span> <span class="token string">"每页记录数"</span><span class="token punctuation">,</span> required <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">)</span>    <span class="token annotation punctuation">@PathVariable</span> <span class="token class-name">Long</span> limit<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token class-name">Page</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Teacher</span><span class="token punctuation">&gt;</span></span> pageParam <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Page</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>page<span class="token punctuation">,</span> limit<span class="token punctuation">)</span><span class="token punctuation">;</span>    teacherService<span class="token punctuation">.</span><span class="token function">page</span><span class="token punctuation">(</span>pageParam<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Teacher</span><span class="token punctuation">&gt;</span></span> records <span class="token operator">=</span> pageParam<span class="token punctuation">.</span><span class="token function">getRecords</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">long</span> total <span class="token operator">=</span> pageParam<span class="token punctuation">.</span><span class="token function">getTotal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span>  <span class="token class-name">R</span><span class="token punctuation">.</span><span class="token function">ok</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">data</span><span class="token punctuation">(</span><span class="token string">"total"</span><span class="token punctuation">,</span> total<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">data</span><span class="token punctuation">(</span><span class="token string">"rows"</span><span class="token punctuation">,</span> records<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>3、Swagger中测试</p><h3 id="3-9-条件查询"><a href="#3-9-条件查询" class="headerlink" title="3.9 条件查询"></a>3.9 条件查询</h3><p>根据讲师名称name，讲师头衔level、讲师入驻时间gmt_create（时间段）查询</p><h4 id="3-9-1-创建查询对象"><a href="#3-9-1-创建查询对象" class="headerlink" title="3.9.1 创建查询对象"></a>3.9.1 创建查询对象</h4><p>创建<code>com.guli.edu.query</code>包，创建<code>TeacherQuery.java</code>查询对象</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>guli<span class="token punctuation">.</span>edu<span class="token punctuation">.</span>query</span><span class="token punctuation">;</span><span class="token annotation punctuation">@ApiModel</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"Teacher查询对象"</span><span class="token punctuation">,</span> description <span class="token operator">=</span> <span class="token string">"讲师查询对象封装"</span><span class="token punctuation">)</span><span class="token annotation punctuation">@Data</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TeacherQuery</span> <span class="token keyword">implements</span> <span class="token class-name">Serializable</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> serialVersionUID <span class="token operator">=</span> <span class="token number">1L</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@ApiModelProperty</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"教师名称,模糊查询"</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>    <span class="token annotation punctuation">@ApiModelProperty</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"头衔 1高级讲师 2首席讲师"</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> <span class="token class-name">Integer</span> level<span class="token punctuation">;</span>        <span class="token annotation punctuation">@ApiModelProperty</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"查询开始时间"</span><span class="token punctuation">,</span> example <span class="token operator">=</span> <span class="token string">"2019-01-01 10:10:10"</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> begin<span class="token punctuation">;</span><span class="token comment">//注意，这里使用的是String类型，前端传过来的数据无需进行类型转换</span>    <span class="token annotation punctuation">@ApiModelProperty</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"查询结束时间"</span><span class="token punctuation">,</span> example <span class="token operator">=</span> <span class="token string">"2019-12-01 10:10:10"</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> end<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-9-2-service"><a href="#3-9-2-service" class="headerlink" title="3.9.2 service"></a>3.9.2 service</h4><p>接口</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>guli<span class="token punctuation">.</span>edu<span class="token punctuation">.</span>service</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">TeacherService</span> <span class="token keyword">extends</span> <span class="token class-name">IService</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Teacher</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>    <span class="token keyword">void</span> <span class="token function">pageQuery</span><span class="token punctuation">(</span><span class="token class-name">Page</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Teacher</span><span class="token punctuation">&gt;</span></span> pageParam<span class="token punctuation">,</span> <span class="token class-name">TeacherQuery</span> teacherQuery<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>实现</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>guli<span class="token punctuation">.</span>edu<span class="token punctuation">.</span>service<span class="token punctuation">.</span>impl</span><span class="token punctuation">;</span><span class="token annotation punctuation">@Service</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TeacherServiceImpl</span> <span class="token keyword">extends</span> <span class="token class-name">ServiceImpl</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">TeacherMapper</span><span class="token punctuation">,</span> <span class="token class-name">Teacher</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">implements</span> <span class="token class-name">TeacherService</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">pageQuery</span><span class="token punctuation">(</span><span class="token class-name">Page</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Teacher</span><span class="token punctuation">&gt;</span></span> pageParam<span class="token punctuation">,</span> <span class="token class-name">TeacherQuery</span> teacherQuery<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">QueryWrapper</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Teacher</span><span class="token punctuation">&gt;</span></span> queryWrapper <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">QueryWrapper</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        queryWrapper<span class="token punctuation">.</span><span class="token function">orderByAsc</span><span class="token punctuation">(</span><span class="token string">"sort"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>teacherQuery <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            baseMapper<span class="token punctuation">.</span><span class="token function">selectPage</span><span class="token punctuation">(</span>pageParam<span class="token punctuation">,</span> queryWrapper<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token class-name">String</span> name <span class="token operator">=</span> teacherQuery<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Integer</span> level <span class="token operator">=</span> teacherQuery<span class="token punctuation">.</span><span class="token function">getLevel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">String</span> begin <span class="token operator">=</span> teacherQuery<span class="token punctuation">.</span><span class="token function">getBegin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">String</span> end <span class="token operator">=</span> teacherQuery<span class="token punctuation">.</span><span class="token function">getEnd</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token class-name">StringUtils</span><span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            queryWrapper<span class="token punctuation">.</span><span class="token function">like</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token class-name">StringUtils</span><span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span>level<span class="token punctuation">)</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>            queryWrapper<span class="token punctuation">.</span><span class="token function">eq</span><span class="token punctuation">(</span><span class="token string">"level"</span><span class="token punctuation">,</span> level<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token class-name">StringUtils</span><span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span>begin<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            queryWrapper<span class="token punctuation">.</span><span class="token function">ge</span><span class="token punctuation">(</span><span class="token string">"gmt_create"</span><span class="token punctuation">,</span> begin<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token class-name">StringUtils</span><span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span>end<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            queryWrapper<span class="token punctuation">.</span><span class="token function">le</span><span class="token punctuation">(</span><span class="token string">"gmt_create"</span><span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        baseMapper<span class="token punctuation">.</span><span class="token function">selectPage</span><span class="token punctuation">(</span>pageParam<span class="token punctuation">,</span> queryWrapper<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-9-3-controller"><a href="#3-9-3-controller" class="headerlink" title="3.9.3 controller"></a>3.9.3 controller</h4><p>TeacherAdminController中修改 pageList方法：</p><p>增加参数TeacherQuery teacherQuery，非必选</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@ApiOperation</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"分页讲师列表"</span><span class="token punctuation">)</span><span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"{page}/{limit}"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token class-name">R</span> <span class="token function">pageQuery</span><span class="token punctuation">(</span>    <span class="token annotation punctuation">@ApiParam</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"page"</span><span class="token punctuation">,</span> value <span class="token operator">=</span> <span class="token string">"当前页码"</span><span class="token punctuation">,</span> required <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">)</span>    <span class="token annotation punctuation">@PathVariable</span> <span class="token class-name">Long</span> page<span class="token punctuation">,</span>    <span class="token annotation punctuation">@ApiParam</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"limit"</span><span class="token punctuation">,</span> value <span class="token operator">=</span> <span class="token string">"每页记录数"</span><span class="token punctuation">,</span> required <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">)</span>    <span class="token annotation punctuation">@PathVariable</span> <span class="token class-name">Long</span> limit<span class="token punctuation">,</span>    <span class="token annotation punctuation">@ApiParam</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"teacherQuery"</span><span class="token punctuation">,</span> value <span class="token operator">=</span> <span class="token string">"查询对象"</span><span class="token punctuation">,</span> required <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">)</span>    <span class="token class-name">TeacherQuery</span> teacherQuery<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token class-name">Page</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Teacher</span><span class="token punctuation">&gt;</span></span> pageParam <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Page</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>page<span class="token punctuation">,</span> limit<span class="token punctuation">)</span><span class="token punctuation">;</span>    teacherService<span class="token punctuation">.</span><span class="token function">pageQuery</span><span class="token punctuation">(</span>pageParam<span class="token punctuation">,</span> teacherQuery<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Teacher</span><span class="token punctuation">&gt;</span></span> records <span class="token operator">=</span> pageParam<span class="token punctuation">.</span><span class="token function">getRecords</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">long</span> total <span class="token operator">=</span> pageParam<span class="token punctuation">.</span><span class="token function">getTotal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span>  <span class="token class-name">R</span><span class="token punctuation">.</span><span class="token function">ok</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">data</span><span class="token punctuation">(</span><span class="token string">"total"</span><span class="token punctuation">,</span> total<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">data</span><span class="token punctuation">(</span><span class="token string">"rows"</span><span class="token punctuation">,</span> records<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-9-4-Swagger中测试"><a href="#3-9-4-Swagger中测试" class="headerlink" title="3.9.4 Swagger中测试"></a>3.9.4 Swagger中测试</h4><p>一、自动填充封装</p><p>1、在service-base模块中添加</p><p><strong>创建包handler，创建自动填充类 MyMetaObjectHandler</strong> </p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Component</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyMetaObjectHandler</span> <span class="token keyword">implements</span> <span class="token class-name">MetaObjectHandler</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">insertFill</span><span class="token punctuation">(</span><span class="token class-name">MetaObject</span> metaObject<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setFieldValByName</span><span class="token punctuation">(</span><span class="token string">"gmtCreate"</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> metaObject<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setFieldValByName</span><span class="token punctuation">(</span><span class="token string">"gmtModified"</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> metaObject<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">updateFill</span><span class="token punctuation">(</span><span class="token class-name">MetaObject</span> metaObject<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setFieldValByName</span><span class="token punctuation">(</span><span class="token string">"gmtModified"</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> metaObject<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>2、在实体类添加自动填充注解</p><p><img src="/2021/03/23/project/91054b5b-c478-4ba3-86f5-95f465210b39.png" alt="img"></p><p><strong>二、controller方法定义</strong></p><p>1、新增 </p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@ApiOperation</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"新增讲师"</span><span class="token punctuation">)</span><span class="token annotation punctuation">@PostMapping</span><span class="token keyword">public</span> <span class="token class-name">R</span> <span class="token function">save</span><span class="token punctuation">(</span>    <span class="token annotation punctuation">@ApiParam</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"teacher"</span><span class="token punctuation">,</span> value <span class="token operator">=</span> <span class="token string">"讲师对象"</span><span class="token punctuation">,</span> required <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">)</span>    <span class="token annotation punctuation">@RequestBody</span> <span class="token class-name">Teacher</span> teacher<span class="token punctuation">)</span><span class="token punctuation">{</span>    teacherService<span class="token punctuation">.</span><span class="token function">save</span><span class="token punctuation">(</span>teacher<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token class-name">R</span><span class="token punctuation">.</span><span class="token function">ok</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>2、根据id查询</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@ApiOperation</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"根据ID查询讲师"</span><span class="token punctuation">)</span><span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"{id}"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token class-name">R</span> <span class="token function">getById</span><span class="token punctuation">(</span>    <span class="token annotation punctuation">@ApiParam</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"id"</span><span class="token punctuation">,</span> value <span class="token operator">=</span> <span class="token string">"讲师ID"</span><span class="token punctuation">,</span> required <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">)</span>    <span class="token annotation punctuation">@PathVariable</span> <span class="token class-name">String</span> id<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token class-name">Teacher</span> teacher <span class="token operator">=</span> teacherService<span class="token punctuation">.</span><span class="token function">getById</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token class-name">R</span><span class="token punctuation">.</span><span class="token function">ok</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">data</span><span class="token punctuation">(</span><span class="token string">"item"</span><span class="token punctuation">,</span> teacher<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>3、根据id修改 </p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@ApiOperation</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"根据ID修改讲师"</span><span class="token punctuation">)</span><span class="token annotation punctuation">@PutMapping</span><span class="token punctuation">(</span><span class="token string">"{id}"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token class-name">R</span> <span class="token function">updateById</span><span class="token punctuation">(</span>    <span class="token annotation punctuation">@ApiParam</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"id"</span><span class="token punctuation">,</span> value <span class="token operator">=</span> <span class="token string">"讲师ID"</span><span class="token punctuation">,</span> required <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">)</span>    <span class="token annotation punctuation">@PathVariable</span> <span class="token class-name">String</span> id<span class="token punctuation">,</span>    <span class="token annotation punctuation">@ApiParam</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"teacher"</span><span class="token punctuation">,</span> value <span class="token operator">=</span> <span class="token string">"讲师对象"</span><span class="token punctuation">,</span> required <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">)</span>    <span class="token annotation punctuation">@RequestBody</span> <span class="token class-name">Teacher</span> teacher<span class="token punctuation">)</span><span class="token punctuation">{</span>    teacher<span class="token punctuation">.</span><span class="token function">setId</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>    teacherService<span class="token punctuation">.</span><span class="token function">updateById</span><span class="token punctuation">(</span>teacher<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token class-name">R</span><span class="token punctuation">.</span><span class="token function">ok</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-10-统一异常处理"><a href="#3-10-统一异常处理" class="headerlink" title="3.10 统一异常处理"></a>3.10 统一异常处理</h3><p><strong>1、制造异常</strong></p><p>除以0 </p><pre class="line-numbers language-none"><code class="language-none">int a = 10/0;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/2021/03/23/project/42cfc6ab-afaf-4516-8b67-d1e198277567.png" alt="img"></p><p>我们想让异常结果也显示为统一的返回结果对象，并且统一处理系统的异常信息，那么需要统一异常处理</p><p><strong>1、创建统一异常处理器</strong></p><p>在service-base中创建统一异常处理类GlobalExceptionHandler.java：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/** * 统一异常处理类 */</span><span class="token annotation punctuation">@ControllerAdvice</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">GlobalExceptionHandler</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@ExceptionHandler</span><span class="token punctuation">(</span><span class="token class-name">Exception</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>    <span class="token annotation punctuation">@ResponseBody</span>    <span class="token keyword">public</span> <span class="token class-name">R</span> <span class="token function">error</span><span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span><span class="token punctuation">{</span>        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token class-name">R</span><span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>2、测试</strong> </p><p>返回统一错误结果</p><p><img src="/2021/03/23/project/c54eac64-d736-4dc4-9923-fb85f87d31a2.png" alt="img"></p><p>处理特定异常</p><p><strong>1、添加异常处理方法</strong> </p><p>GlobalExceptionHandler.java中添加</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@ExceptionHandler</span><span class="token punctuation">(</span><span class="token class-name">ArithmeticException</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token annotation punctuation">@ResponseBody</span><span class="token keyword">public</span> <span class="token class-name">R</span> <span class="token function">error</span><span class="token punctuation">(</span><span class="token class-name">ArithmeticException</span> e<span class="token punctuation">)</span><span class="token punctuation">{</span>    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token class-name">R</span><span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">message</span><span class="token punctuation">(</span><span class="token string">"执行了自定义异常"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>2、测试</strong></p><p><img src="/2021/03/23/project/2b02cb8f-53fd-4847-a5ad-10e134c44f28.png" alt="img"></p><p><strong>四、自定义异常</strong></p><p>1、创建自定义异常类</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Data</span><span class="token annotation punctuation">@AllArgsConstructor</span><span class="token annotation punctuation">@NoArgsConstructor</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">GuliException</span> <span class="token keyword">extends</span> <span class="token class-name">RuntimeException</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@ApiModelProperty</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"状态码"</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> <span class="token class-name">Integer</span> code<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> msg<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>2、业务中需要的位置抛出GuliException</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">try</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token operator">/</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">catch</span><span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">GuliException</span><span class="token punctuation">(</span><span class="token number">20001</span><span class="token punctuation">,</span><span class="token string">"出现自定义异常"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>3、添加异常处理方法</p><p>GlobalExceptionHandler.java中添加</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@ExceptionHandler</span><span class="token punctuation">(</span><span class="token class-name">GuliException</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token annotation punctuation">@ResponseBody</span><span class="token keyword">public</span> <span class="token class-name">R</span> <span class="token function">error</span><span class="token punctuation">(</span><span class="token class-name">GuliException</span> e<span class="token punctuation">)</span><span class="token punctuation">{</span>    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token class-name">R</span><span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">message</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span><span class="token function">getMsg</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">code</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span><span class="token function">getCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>4、测试 </p><p><img src="/2021/03/23/project/f3c5a449-4984-4d35-9f25-35d43197a3e8.png" alt="img"></p><h3 id="3-11-统一日志处理"><a href="#3-11-统一日志处理" class="headerlink" title="3.11 统一日志处理"></a>3.11 统一日志处理</h3><p>1、配置日志级别</p><p>日志记录器（Logger）的行为是分等级的。如下表所示：</p><p>分为：OFF、FATAL、ERROR、WARN、INFO、DEBUG、ALL</p><p>默认情况下，spring boot从控制台打印出来的日志级别只有INFO及以上级别，可以配置日志级别 </p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"># 设置日志级别logging.level.root=WARN<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这种方式只能将日志打印在控制台上</p><p>二、Logback日志</p><p>spring boot内部使用Logback作为日志实现的框架。</p><p>Logback和log4j非常相似，如果你对log4j很熟悉，那对logback很快就会得心应手。</p><p>logback相对于log4j的一些优点：<a href="https://blog.csdn.net/caisini_vc/article/details/48551287">https://blog.csdn.net/caisini_vc/article/details/48551287</a></p><p>1、配置logback日志</p><p>删除application.properties中的日志配置</p><p>安装idea彩色日志插件：grep-console</p><p>resources 中创建 logback-spring.xml  </p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>configuration</span>  <span class="token attr-name">scan</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span> <span class="token attr-name">scanPeriod</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>10 seconds<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token comment">&lt;!-- 日志级别从低到高分为TRACE &lt; DEBUG &lt; INFO &lt; WARN &lt; ERROR &lt; FATAL，如果设置为WARN，则低于WARN的信息都不会输出 --&gt;</span>    <span class="token comment">&lt;!-- scan:当此属性设置为true时，配置文件如果发生改变，将会被重新加载，默认值为true --&gt;</span>    <span class="token comment">&lt;!-- scanPeriod:设置监测配置文件是否有修改的时间间隔，如果没有给出时间单位，默认单位是毫秒。当scan为true时，此属性生效。默认的时间间隔为1分钟。 --&gt;</span>    <span class="token comment">&lt;!-- debug:当此属性设置为true时，将打印出logback内部日志信息，实时查看logback运行状态。默认值为false。 --&gt;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>contextName</span><span class="token punctuation">&gt;</span></span>logback<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>contextName</span><span class="token punctuation">&gt;</span></span>    <span class="token comment">&lt;!-- name的值是变量的名称，value的值时变量定义的值。通过定义的值会被插入到logger上下文中。定义变量后，可以使“${}”来使用变量。 --&gt;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>log.path<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>D:/guli_log/edu<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>    <span class="token comment">&lt;!-- 彩色日志 --&gt;</span>    <span class="token comment">&lt;!-- 配置格式变量：CONSOLE_LOG_PATTERN 彩色日志格式 --&gt;</span>    <span class="token comment">&lt;!-- magenta:洋红 --&gt;</span>    <span class="token comment">&lt;!-- boldMagenta:粗红--&gt;</span>    <span class="token comment">&lt;!-- cyan:青色 --&gt;</span>    <span class="token comment">&lt;!-- white:白色 --&gt;</span>    <span class="token comment">&lt;!-- magenta:洋红 --&gt;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>CONSOLE_LOG_PATTERN<span class="token punctuation">"</span></span>              <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>%yellow(%date{yyyy-MM-dd HH:mm:ss}) |%highlight(%-5level) |%blue(%thread) |%blue(%file:%line) |%green(%logger) |%cyan(%msg%n)<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>    <span class="token comment">&lt;!--输出到控制台--&gt;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>appender</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>CONSOLE<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>ch.qos.logback.core.ConsoleAppender<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>        <span class="token comment">&lt;!--此日志appender是为开发使用，只配置最底级别，控制台输出的日志级别是大于或等于此级别的日志信息--&gt;</span>        <span class="token comment">&lt;!-- 例如：如果此处配置了INFO级别，则后面其他位置即使配置了DEBUG级别的日志，也不会被输出 --&gt;</span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>filter</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>ch.qos.logback.classic.filter.ThresholdFilter<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>level</span><span class="token punctuation">&gt;</span></span>INFO<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>level</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>filter</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>encoder</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Pattern</span><span class="token punctuation">&gt;</span></span>${CONSOLE_LOG_PATTERN}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>Pattern</span><span class="token punctuation">&gt;</span></span>            <span class="token comment">&lt;!-- 设置字符集 --&gt;</span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>charset</span><span class="token punctuation">&gt;</span></span>UTF-8<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>charset</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>encoder</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>appender</span><span class="token punctuation">&gt;</span></span>    <span class="token comment">&lt;!--输出到文件--&gt;</span>    <span class="token comment">&lt;!-- 时间滚动输出 level为 INFO 日志 --&gt;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>appender</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>INFO_FILE<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>ch.qos.logback.core.rolling.RollingFileAppender<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>        <span class="token comment">&lt;!-- 正在记录的日志文件的路径及文件名 --&gt;</span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>file</span><span class="token punctuation">&gt;</span></span>${log.path}/log_info.log<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>file</span><span class="token punctuation">&gt;</span></span>        <span class="token comment">&lt;!--日志文件输出格式--&gt;</span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>encoder</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>pattern</span><span class="token punctuation">&gt;</span></span>%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{50} - %msg%n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>pattern</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>charset</span><span class="token punctuation">&gt;</span></span>UTF-8<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>charset</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>encoder</span><span class="token punctuation">&gt;</span></span>        <span class="token comment">&lt;!-- 日志记录器的滚动策略，按日期，按大小记录 --&gt;</span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>rollingPolicy</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>ch.qos.logback.core.rolling.TimeBasedRollingPolicy<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>            <span class="token comment">&lt;!-- 每天日志归档路径以及格式 --&gt;</span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>fileNamePattern</span><span class="token punctuation">&gt;</span></span>${log.path}/info/log-info-%d{yyyy-MM-dd}.%i.log<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>fileNamePattern</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>timeBasedFileNamingAndTriggeringPolicy</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>maxFileSize</span><span class="token punctuation">&gt;</span></span>100MB<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>maxFileSize</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>timeBasedFileNamingAndTriggeringPolicy</span><span class="token punctuation">&gt;</span></span>            <span class="token comment">&lt;!--日志文件保留天数--&gt;</span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>maxHistory</span><span class="token punctuation">&gt;</span></span>15<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>maxHistory</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>rollingPolicy</span><span class="token punctuation">&gt;</span></span>        <span class="token comment">&lt;!-- 此日志文件只记录info级别的 --&gt;</span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>filter</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>ch.qos.logback.classic.filter.LevelFilter<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>level</span><span class="token punctuation">&gt;</span></span>INFO<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>level</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>onMatch</span><span class="token punctuation">&gt;</span></span>ACCEPT<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>onMatch</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>onMismatch</span><span class="token punctuation">&gt;</span></span>DENY<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>onMismatch</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>filter</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>appender</span><span class="token punctuation">&gt;</span></span>    <span class="token comment">&lt;!-- 时间滚动输出 level为 WARN 日志 --&gt;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>appender</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>WARN_FILE<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>ch.qos.logback.core.rolling.RollingFileAppender<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>        <span class="token comment">&lt;!-- 正在记录的日志文件的路径及文件名 --&gt;</span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>file</span><span class="token punctuation">&gt;</span></span>${log.path}/log_warn.log<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>file</span><span class="token punctuation">&gt;</span></span>        <span class="token comment">&lt;!--日志文件输出格式--&gt;</span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>encoder</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>pattern</span><span class="token punctuation">&gt;</span></span>%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{50} - %msg%n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>pattern</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>charset</span><span class="token punctuation">&gt;</span></span>UTF-8<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>charset</span><span class="token punctuation">&gt;</span></span> <span class="token comment">&lt;!-- 此处设置字符集 --&gt;</span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>encoder</span><span class="token punctuation">&gt;</span></span>        <span class="token comment">&lt;!-- 日志记录器的滚动策略，按日期，按大小记录 --&gt;</span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>rollingPolicy</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>ch.qos.logback.core.rolling.TimeBasedRollingPolicy<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>fileNamePattern</span><span class="token punctuation">&gt;</span></span>${log.path}/warn/log-warn-%d{yyyy-MM-dd}.%i.log<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>fileNamePattern</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>timeBasedFileNamingAndTriggeringPolicy</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>maxFileSize</span><span class="token punctuation">&gt;</span></span>100MB<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>maxFileSize</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>timeBasedFileNamingAndTriggeringPolicy</span><span class="token punctuation">&gt;</span></span>            <span class="token comment">&lt;!--日志文件保留天数--&gt;</span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>maxHistory</span><span class="token punctuation">&gt;</span></span>15<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>maxHistory</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>rollingPolicy</span><span class="token punctuation">&gt;</span></span>        <span class="token comment">&lt;!-- 此日志文件只记录warn级别的 --&gt;</span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>filter</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>ch.qos.logback.classic.filter.LevelFilter<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>level</span><span class="token punctuation">&gt;</span></span>warn<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>level</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>onMatch</span><span class="token punctuation">&gt;</span></span>ACCEPT<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>onMatch</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>onMismatch</span><span class="token punctuation">&gt;</span></span>DENY<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>onMismatch</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>filter</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>appender</span><span class="token punctuation">&gt;</span></span>    <span class="token comment">&lt;!-- 时间滚动输出 level为 ERROR 日志 --&gt;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>appender</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>ERROR_FILE<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>ch.qos.logback.core.rolling.RollingFileAppender<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>        <span class="token comment">&lt;!-- 正在记录的日志文件的路径及文件名 --&gt;</span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>file</span><span class="token punctuation">&gt;</span></span>${log.path}/log_error.log<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>file</span><span class="token punctuation">&gt;</span></span>        <span class="token comment">&lt;!--日志文件输出格式--&gt;</span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>encoder</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>pattern</span><span class="token punctuation">&gt;</span></span>%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{50} - %msg%n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>pattern</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>charset</span><span class="token punctuation">&gt;</span></span>UTF-8<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>charset</span><span class="token punctuation">&gt;</span></span> <span class="token comment">&lt;!-- 此处设置字符集 --&gt;</span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>encoder</span><span class="token punctuation">&gt;</span></span>        <span class="token comment">&lt;!-- 日志记录器的滚动策略，按日期，按大小记录 --&gt;</span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>rollingPolicy</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>ch.qos.logback.core.rolling.TimeBasedRollingPolicy<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>fileNamePattern</span><span class="token punctuation">&gt;</span></span>${log.path}/error/log-error-%d{yyyy-MM-dd}.%i.log<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>fileNamePattern</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>timeBasedFileNamingAndTriggeringPolicy</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>maxFileSize</span><span class="token punctuation">&gt;</span></span>100MB<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>maxFileSize</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>timeBasedFileNamingAndTriggeringPolicy</span><span class="token punctuation">&gt;</span></span>            <span class="token comment">&lt;!--日志文件保留天数--&gt;</span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>maxHistory</span><span class="token punctuation">&gt;</span></span>15<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>maxHistory</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>rollingPolicy</span><span class="token punctuation">&gt;</span></span>        <span class="token comment">&lt;!-- 此日志文件只记录ERROR级别的 --&gt;</span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>filter</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>ch.qos.logback.classic.filter.LevelFilter<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>level</span><span class="token punctuation">&gt;</span></span>ERROR<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>level</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>onMatch</span><span class="token punctuation">&gt;</span></span>ACCEPT<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>onMatch</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>onMismatch</span><span class="token punctuation">&gt;</span></span>DENY<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>onMismatch</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>filter</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>appender</span><span class="token punctuation">&gt;</span></span>    <span class="token comment">&lt;!--        &lt;logger&gt;用来设置某一个包或者具体的某一个类的日志打印级别、以及指定&lt;appender&gt;。        &lt;logger&gt;仅有一个name属性，        一个可选的level和一个可选的addtivity属性。        name:用来指定受此logger约束的某一个包或者具体的某一个类。        level:用来设置打印级别，大小写无关：TRACE, DEBUG, INFO, WARN, ERROR, ALL 和 OFF，              如果未设置此属性，那么当前logger将会继承上级的级别。    --&gt;</span>    <span class="token comment">&lt;!--        使用mybatis的时候，sql语句是debug下才会打印，而这里我们只配置了info，所以想要查看sql语句的话，有以下两种操作：        第一种把&lt;root level="INFO"&gt;改成&lt;root level="DEBUG"&gt;这样就会打印sql，不过这样日志那边会出现很多其他消息        第二种就是单独给mapper下目录配置DEBUG模式，代码如下，这样配置sql语句会打印，其他还是正常DEBUG级别：     --&gt;</span>    <span class="token comment">&lt;!--开发环境:打印控制台--&gt;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>springProfile</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>dev<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>        <span class="token comment">&lt;!--可以输出项目中的debug日志，包括mybatis的sql日志--&gt;</span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>logger</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.guli<span class="token punctuation">"</span></span> <span class="token attr-name">level</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>INFO<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>        <span class="token comment">&lt;!--            root节点是必选节点，用来指定最基础的日志输出级别，只有一个level属性            level:用来设置打印级别，大小写无关：TRACE, DEBUG, INFO, WARN, ERROR, ALL 和 OFF，默认是DEBUG            可以包含零个或多个appender元素。        --&gt;</span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>root</span> <span class="token attr-name">level</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>INFO<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>appender-ref</span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>CONSOLE<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>appender-ref</span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>INFO_FILE<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>appender-ref</span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>WARN_FILE<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>appender-ref</span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>ERROR_FILE<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>root</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>springProfile</span><span class="token punctuation">&gt;</span></span>    <span class="token comment">&lt;!--生产环境:输出到文件--&gt;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>springProfile</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>pro<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>root</span> <span class="token attr-name">level</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>INFO<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>appender-ref</span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>CONSOLE<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>appender-ref</span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>DEBUG_FILE<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>appender-ref</span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>INFO_FILE<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>appender-ref</span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>ERROR_FILE<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>appender-ref</span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>WARN_FILE<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>root</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>springProfile</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>configuration</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li>将错误日志输出到文件</li></ol><p>GlobalExceptionHandler.java 中</p><p>类上添加注解</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Slf4j</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>异常输出语句</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">log<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span><span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="3"><li>将日志堆栈信息输出到文件</li></ol><p>定义工具类</p><p>guli-framework-common下创建util包，创建ExceptionUtil.java工具类</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>guli<span class="token punctuation">.</span>common<span class="token punctuation">.</span>util</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ExceptionUtil</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">String</span> <span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">StringWriter</span> sw <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token class-name">PrintWriter</span> pw <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            sw <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringWriter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            pw <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PrintWriter</span><span class="token punctuation">(</span>sw<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 将出错的栈信息输出到printWriter中</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span>pw<span class="token punctuation">)</span><span class="token punctuation">;</span>            pw<span class="token punctuation">.</span><span class="token function">flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            sw<span class="token punctuation">.</span><span class="token function">flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>sw <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">try</span> <span class="token punctuation">{</span>                    sw<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e1<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    e1<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>pw <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                pw<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> sw<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>调用</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">log<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token class-name">ExceptionUtil</span><span class="token punctuation">.</span><span class="token function">getMessage</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>GuliException中创建toString方法</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token string">"GuliException{"</span> <span class="token operator">+</span>        <span class="token string">"message="</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span>        <span class="token string">", code="</span> <span class="token operator">+</span> code <span class="token operator">+</span>        <span class="token string">'}'</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4-前端"><a href="#4-前端" class="headerlink" title="4. 前端"></a>4. 前端</h2><h2 id="其他知识"><a href="#其他知识" class="headerlink" title="其他知识"></a>其他知识</h2><h3 id="1-主键的生成策略"><a href="#1-主键的生成策略" class="headerlink" title="1.主键的生成策略"></a>1.主键的生成策略</h3><ol><li>自动增长 </li></ol><p>在MYSQL中是AUTO_INCREMENT。在分表中，比如将用户数据放入3张表中，下一张表需要得到上一张表的最后一个值加1才能自动增长。</p><ol start="2"><li>UUID </li></ol><p>每次生成随机唯一的一个值。但是排序不方便，不好索引。</p><ol start="3"><li>Redis生成ID。</li><li>mp中自带策略</li></ol><p>使用snowflake算法生成。19位id。10bit作为机器的ID（5bit是数据中心，5bit是机器ID），12bit作为毫秒内的流水号，最后还有符号位，永远是0。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@TableId</span><span class="token punctuation">(</span>type<span class="token operator">=</span> <span class="token class-name">IdType</span><span class="token punctuation">.</span>AUTO<span class="token punctuation">)</span><span class="token keyword">private</span> <span class="token class-name">Long</span> id<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><code>IdType</code>的类型<code>AUTO</code>——自动增长、<code>ID_WORKER</code>——生成19位值，数字类型使用这种类型，比如long、<code>ID_WORKER_STR</code>——生成19位值，字符串类型使用这种类型，比如String、<code>INPUT——设置id值</code>、<code>NONE：输入</code>、<code>UUID</code>——随机唯一值。</p><h3 id="2-自动填充"><a href="#2-自动填充" class="headerlink" title="2.自动填充"></a>2.自动填充</h3><p>不需要set到对象里面的值，使用mq方式实现数据添加。</p><ol><li>在实体类自动填充属性上添加注解：</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@TableField</span><span class="token punctuation">(</span>fill<span class="token operator">=</span> <span class="token class-name">FieldFill</span><span class="token punctuation">.</span>INSERT<span class="token punctuation">)</span><span class="token keyword">private</span> <span class="token class-name">Date</span> createTime<span class="token punctuation">;</span><span class="token annotation punctuation">@TableField</span><span class="token punctuation">(</span>fill <span class="token operator">=</span> <span class="token class-name">FieldFill</span><span class="token punctuation">.</span>INSERT_UPDATE<span class="token punctuation">)</span><span class="token keyword">private</span> <span class="token class-name">Date</span> updateTime<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li>自定义实现类，实现接口<code>MetaObjectHandler</code>和接口的方法</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Component</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyMetaObjectHandler</span> <span class="token keyword">implements</span> <span class="token class-name">MetaObjectHandler</span> <span class="token punctuation">{</span>    <span class="token comment">//使用mq实现添加操作，这个方法执行</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">insertFill</span><span class="token punctuation">(</span><span class="token class-name">MetaObject</span> metaObject<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setFieldValByName</span><span class="token punctuation">(</span><span class="token string">"createTime"</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> metaObject<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setFieldValByName</span><span class="token punctuation">(</span><span class="token string">"updateTime"</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> metaObject<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//使用mq实现修改操作，这个方法执行</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">updateFill</span><span class="token punctuation">(</span><span class="token class-name">MetaObject</span> metaObject<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setFieldValByName</span><span class="token punctuation">(</span><span class="token string">"updateTime"</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> metaObject<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-乐观锁"><a href="#3-乐观锁" class="headerlink" title="3.乐观锁"></a>3.乐观锁</h3><p>解决丢失更新问题（多个人同时修改同一条记录，最后提交的把之前提交的数据覆盖）。</p><p>乐观锁的实现方式：</p><ol><li>取出记录时，获取当前的version。</li><li>更新时，带上这个version。</li><li>执行更新时，<code>set version = newVersion where version = oldVersion</code></li><li>如果version不对，就更新失败。</li></ol><p>代码中的实现：</p><ol><li>表中加字段version</li></ol><ol start="2"><li>类中加属性version，并且添加<code>@Version</code>注解</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Version</span><span class="token keyword">private</span> <span class="token class-name">Integer</span> version<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ol start="3"><li>配置乐观锁插件</li></ol><h3 id="4-分页查询"><a href="#4-分页查询" class="headerlink" title="4.分页查询"></a>4.分页查询</h3><ol><li>配置分页插件</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//分页插件</span><span class="token annotation punctuation">@Bean</span><span class="token keyword">public</span> <span class="token class-name">PaginationInterceptor</span> <span class="token function">paginationInterceptor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">PaginationInterceptor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li>编写分页代码</li></ol><p>直接new page对象，传入两个参数。调入mp方法实现分页查询。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Test</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testPage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment">//第一个参数 当前页 第二个 每页显示记录数</span>    <span class="token class-name">Page</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">User</span><span class="token punctuation">&gt;</span></span> page <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Page</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//调用mp分页查询过程中，底层封装把分页所有数据封装到page对象里面。</span>    userMaper<span class="token punctuation">.</span><span class="token function">selectPage</span><span class="token punctuation">(</span>page<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//通过page对象获取所有数据</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>page<span class="token punctuation">.</span><span class="token function">getCurrent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>page<span class="token punctuation">.</span><span class="token function">getRecords</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-逻辑删除"><a href="#5-逻辑删除" class="headerlink" title="5. 逻辑删除"></a>5. 逻辑删除</h3><p>数据库表中加上一列<code>deleted</code></p><ul><li>物理删除：数据真的不在了，在硬件上删除。</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Test</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testDeleteById</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> userMaper<span class="token punctuation">.</span><span class="token function">deleteById</span><span class="token punctuation">(</span><span class="token number">1L</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//物理删除</span><span class="token punctuation">}</span><span class="token annotation punctuation">@Test</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testDeleteBatchIds</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> result <span class="token operator">=</span> userMaper<span class="token punctuation">.</span><span class="token function">deleteBatchIds</span><span class="token punctuation">(</span><span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//批量删除</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>逻辑删除：逻辑上删除，但数据实际还存在。</li></ul><ol><li>表中添加逻辑删除字段，对应实体类添加属性。</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@TableLogic</span><span class="token keyword">private</span> <span class="token class-name">Integer</span> deleted<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ol start="2"><li>配置逻辑插件</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Bean</span><span class="token keyword">public</span> <span class="token class-name">ISqlInjector</span> <span class="token function">sqlInjector</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">LogicSqlInjector</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ol start="3"><li>再调用删除语句，就会将deleted字段置为1。（假装删除）</li></ol><p>其底层的sql语句是<code>UPDATE user SET deleted=1 WHERE id=? AND deleted=0 </code></p>]]></content>
      
      
      <categories>
          
          <category> project </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>MYSQL</title>
      <link href="2021/03/15/database/"/>
      <url>2021/03/15/database/</url>
      
        <content type="html"><![CDATA[<h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><h2 id="一、绪论"><a href="#一、绪论" class="headerlink" title="一、绪论"></a>一、绪论</h2><p>数据、数据库、数据库管理系统和数据库系统是4个基本概念。</p><ol><li>数据（data）</li></ol><p>数据是数据库种存储的基本对象。（数字、字符、音视频等等）</p><p><font color="green">描述事物的符号记录称为数据。</font></p><ol start="2"><li>数据库（Data Base,DB)</li></ol><p>数据库是存放数据的仓库。<font color="green">数据库是长期存储在计算机内、有组织的、可共享的大量数据的集合。数据库中的数据按一定的数据模型组织、描述和存储，具有较小的冗余度、较高的数据独立性和易扩展性，并可为各种用户共享</font></p><ol start="3"><li>数据库管理系统</li></ol><p>它有以下功能：</p><p>1）数据定义功能。</p><p>2）数据组织、存储和管理</p><p>3）数据操纵功能</p><p>4）数据库的事务管理和运行管理</p><p>5）数据库的建立和维护功能</p><p>6）其他功能</p><ol start="4"><li>数据库系统</li></ol><p>数据库系统是由数据库、数据库管理系统、应用程序和数据库管理员组成的存储、管理、处理和维护数据的系统。</p><h3 id="1-两类数据模型"><a href="#1-两类数据模型" class="headerlink" title="1. 两类数据模型"></a>1. 两类数据模型</h3><p>第一类是概念模型，第二类是逻辑模型和物理模型。</p><p><img src="/2021/03/15/database/%E6%A6%82%E5%BF%B5%E6%A8%A1%E5%9E%8B.PNG"></p><ul><li><strong>概念模型</strong></li></ul><p>也叫信息模型,是现实世界到机器世界的一个中间层次。</p><p>信息世界中基本概念：</p><p>1） 实体。 客观存在并可相互区别的事物称为实体。</p><p>2） 属性。 实体所具有的某一特性称为属性。</p><p>3） 码。 唯一标识实体的属性集成为码。</p><p>4）实体性。 用实体名及其属性名集合来抽象和刻画同类实体，称为实体性。</p><p>5） 实体集。 同一类型实体的集合称为实体集。</p><p>6） 联系。 实体之间的联系通常是指不同实体集之间的联系。</p><p>实体之间的联系有一对一、一对多和多对多等多种类型。</p><p>概念模型的一种表示方法：实体-联系方法，该方法使用<strong>ER图</strong>，E-R方法也称为E-R模型。</p><ul><li><strong>数据模型</strong></li></ul><p>通常由数据结构、数据操作和数据的完整性约束条件三部分组成。</p><p>1） 数据结构。描述数据库的组成对象以及对象之间的联系。</p><p>2） 数据操作。对数据库中的各种对象的实例允许执行的操作的集合，包括操作及有关的操作规则。</p><p>3）数据的完整性约束。</p><p>常用的数据模型：</p><p>1） 层次模型 （树）</p><ul><li><p>有且只有一个结点没有双亲结点，这个结点是根节点。</p></li><li><p>根以外的其他结点没有双亲结点。</p></li></ul><p>2）网状模型</p><ul><li>允许一个以上的结点无双亲。</li><li>一个结点可以有多于一个的双亲。</li></ul><p><img src="/2021/03/15/database/%E7%BD%91%E7%8A%B6%E6%A8%A1%E5%9E%8B.PNG"></p><ul><li>关系模型</li></ul><p><img src="/2021/03/15/database/%E5%85%B3%E7%B3%BB%E6%A8%A1%E5%9E%8B.PNG"></p><p>关系：一个关系对应通常说的一张表。</p><p>元组：表中的一行。</p><p>属性：表中的一列。</p><p>码：也称为码键。表中的某个属性组，它可以唯一确定一个元组。</p><p>域：域是一组具有相同数据类型的值的集合。属性的取值范围来自某个域。</p><p>分量：元组中的一个属性值。</p><p>关系模式：对关系的描述，一般表示为：关系名（属性1，属性2，…，属性n）</p><p>关系模型要求关系必须是规范化的，<font color="green">关系的每一个分量必须是一个不可分的数据项</font>。</p><p><img src="/2021/03/15/database/%E8%A1%A8%E4%B8%AD%E6%9C%89%E8%A1%A8.PNG"></p><h3 id="2-数据库系统的结构"><a href="#2-数据库系统的结构" class="headerlink" title="2.数据库系统的结构"></a>2.数据库系统的结构</h3><p>在数据模型中有“型(type)”和“值”的概念。型是指对某一类数据的结构和属性的说明，值是型的一个具体赋值。模式是数据库中全体数据的逻辑结构和特征的描述，它仅仅涉及型的描述，不涉及具体的值。</p><ul><li>数据库系统的三级模式结构</li></ul><p>外模式、模式和内模式三级构成。</p><p><img src="/2021/03/15/database/%E4%B8%89%E7%BA%A7%E6%A8%A1%E5%BC%8F.PNG"></p><ol><li>模式</li></ol><p>模式也成为逻辑模式，是数据库中全体数据的逻辑结构和特征的描述，是所有用户的公共数据视图。一个数据库只有一个模式。数据库模式以某一种数据模型为基础，同意综合地考虑了所有用户的需求。</p><ol start="2"><li>外模式</li></ol><p>外模式也称为子模式或用户模式，它是数据库用户能够看见和使用的局部数据的逻辑结构和特征的描述，是数据库用户的数据视图，是与某一应用有关的数据的逻辑表示。</p><p>外模式是模式的子集。</p><ol start="3"><li>内模式</li></ol><p>内模式也称为存储模式，一个数据库只有一个内模式。它是数据物理结构和存储方式的描述，是数据在数据库内部的组织方式。</p><p> <font color="green">外模式/模式映像</font></p><p>模式描述的是数据的全局逻辑结构，外模式描述的是数据的局部逻辑结构。每一个外模式，都有一个外模式/模式映像，它定义了外模式和模式之间的对应关系。这些映像定义通常包含各自外模式的描述。</p><p><font color="green">模式/内模式映像</font></p><p>模式内模式映像是唯一的，它定义了数据全局逻辑结构与存储结构之间的对应关系。</p><h2 id="二、关系数据库"><a href="#二、关系数据库" class="headerlink" title="二、关系数据库"></a>二、关系数据库</h2><h3 id="1-关系数据结构及其形式化定义"><a href="#1-关系数据结构及其形式化定义" class="headerlink" title="1.关系数据结构及其形式化定义"></a>1.关系数据结构及其形式化定义</h3><p>关系模型是建立在集合代数的基础上的。</p><p>笛卡尔积：</p><p><img src="/2021/03/15/database/%E7%AC%9B%E5%8D%A1%E5%B0%94%E7%A7%AF.PNG"></p><ul><li><font color="red" size="5">关系</font></li></ul><p>$D_1 \times D_2 \times …. \times D_n$ 的子集叫做在域$D_1, D_2, …,D_n$上的关系。表示为$R(D_1,D_2,…,D_n)$</p><p>这里的R表示关系的名字，n是关系的目或度（degree)。</p><p>n = 1，表示是单元关系。</p><p>n = 2，表示是二元关系。</p><p><font color="green">若关系中某一个属性组的值能唯一地标识一个元组，而其子集不能，则称该属性组为<strong>候选码</strong></font></p><p>若一个关系有多个候选码，则选定其中一个为<strong>主码</strong>。候选码的诸属性称为<strong>主属性</strong>。</p><ul><li><font color="red" size="5">关系模式</font> </li></ul><p>关系数据库中，关系模式是型，关系是值。关系模式是对关系的描述。</p><p>关系模式可以形式化地表示为$R(U,D,DOM,F)$，其中R为关系名，U为组成该关系的属性名集合，D为U中属性所来自的域，DOM为属性向域的映像集合，F为属性间数据的依赖关系集合。</p><p>关系数据库：所有关系的集合。</p><p>关系操作：查询和插入、删除、修改。</p><p>查询操作可以分为选择、投影、连接、除、并、差、交、笛卡尔积等。其中选择、投影、并、差、笛卡尔积是5中基本操作。操作的对象和结果都是集合。非关系数据模型的数据操作方式则为一次一记录的方式。</p><h1 id="InnoDB-技术内幕"><a href="#InnoDB-技术内幕" class="headerlink" title="InnoDB 技术内幕"></a>InnoDB 技术内幕</h1><p>连接MySQL操作是一个连接进程和MySQL数据库实例进行通信。比如通过TCP/IP连接到MySQL实例，数据库会先检查一张权限视图，用来判断发起请求的客户端IP是否允许连接到Mysql实例。</p><h3 id="1-InnoDB体系架构"><a href="#1-InnoDB体系架构" class="headerlink" title="1. InnoDB体系架构"></a>1. InnoDB体系架构</h3><ol><li>Master Thread</li></ol><p>核心的后台线程，主要负责将缓冲池中的数据异步刷新到磁盘，保证数据的一致性，包括脏页的刷新、合并插入缓冲、UNDO页的回收。</p><ol start="2"><li>IO Thread</li></ol><p>InnoDB存储引擎大量使用AIO（Async IO）来处理写IO请求，这样可以大大提高数据库的性能。InnoDB 1.0 版本之前共有4个IO Tread。write、read、insert buffer、log IO thread。</p><ol start="3"><li>Purge Thread</li></ol><p>PurgeThread来回收已经使用并分配的undo页。</p><h2 id="基础查询"><a href="#基础查询" class="headerlink" title="基础查询"></a>基础查询</h2><h3 id="1、Select"><a href="#1、Select" class="headerlink" title="1、Select"></a>1、<code>Select</code></h3><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">Select 查询列表 from 表名;SELECT last_name,email,salary from employees; #查询多个字段SELECT 100*98;#查询表达式SELECT VERSION();#查询函数SELECT DISTINCT department_id FROM employees;#去重复SELECT 100+90;SELECT '123'+90;#看3点<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li><p>查询列表可以是字段、常量值、函数和表达式。</p></li><li><p>查询的结果是一个虚拟的表格。</p></li><li><p><code>+</code>的作用：</p><p>a. 两个操作数都为数值型，则做加法运算。</p><p>b.其中一方为字符型，试图将字符型数值转换为数值型。如果转换成功，则继续做加法运算。如果失败，则字符型转换为0</p><p>c. 只要其中一方为<code>null</code>，则结果肯定为<code>null</code>。</p></li><li><p><code>CONCAT</code> 连接</p></li></ol><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">SELECT CONCAT('a','b','c') As 结果;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="单行函数"><a href="#单行函数" class="headerlink" title="单行函数"></a>单行函数</h3><ol><li>字符函数</li></ol><p><code>length</code> </p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">SELECT LENGTH('john');<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>concat</code> 拼接字符串</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">SELECT CONCAT(last_name,'_',first_name) 姓名 FROM employees;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>upper</code> <code>lower</code></p><pre class="line-numbers language-none"><code class="language-none">SELECT UPPER('john');SELECT LOWER('joHn');<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><code>substr</code> <code>substring</code></p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">SELECT SUBSTR('李莫愁爱上了陆展元',6) out_put;// 陆展元SELECT SUBSTR("李莫愁爱上了陆展元"，1，3) output //李莫愁<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><code>instr</code></p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">SELECT INSTR('杨不悔爱上了殷六侠','殷六侠') AS out_put; 返回子串第一次出现的索引，如果找不到返回0<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>trim</code></p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">SELECT TRIM('      张翠山    ') AS out_put;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>lpad</code></p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">SELECT LPAD('殷素素',10,'*') AS out_put;//左侧填充<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>rpad</code></p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">SELECT RPAD('殷素素',10,'*') AS out_put;//右侧填充<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>replace</code></p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">SELECT REPLACE ('张无忌爱上了周芷若周芷若爱上了张无忌','周芷若'，'赵敏') AS out_put;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="2"><li>数学函数</li></ol><p><code>round</code> 四舍五入</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">SELECT ROUND(1.65);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>ceil</code> 向上取整</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">SELECT CEIL(1.00); # 返回该参数的最小整数<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>floor</code> 向下取整</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">SELECT FLOOR(-9.99)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>truncate</code> 截断</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">SELECT TRUNCATE(1.6999,1);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>mod</code></p><pre class="line-numbers language-none"><code class="language-none">SELECT MOD(-10,3);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="2"><li>日期函数</li><li>其他函数</li><li>流程控制函数</li></ol><h4 id="Union-联合查询"><a href="#Union-联合查询" class="headerlink" title="Union 联合查询"></a>Union 联合查询</h4><p>多张表合并成一个结果。（要查询的结果来自于多个表，且多个表没有直接的关系，但查询的信息一般是一致的）。</p><h1 id="高级部分"><a href="#高级部分" class="headerlink" title="高级部分"></a>高级部分</h1><p><img src="/2021/03/15/database/%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F.PNG"></p><p><img src="/2021/03/15/database/limit%E5%85%AC%E5%BC%8F.PNG"></p><h3 id="Explain-SQL-语句优化"><a href="#Explain-SQL-语句优化" class="headerlink" title="Explain + SQL 语句优化"></a>Explain + SQL 语句优化</h3><h4 id="id"><a href="#id" class="headerlink" title="id"></a>id</h4><p><img src="/2021/03/15/database/explainID.PNG"></p><h4 id="TYPE"><a href="#TYPE" class="headerlink" title="TYPE"></a>TYPE</h4><p><img src="/2021/03/15/database/explainTYPE.PNG"></p><h3 id="2-六大约束"><a href="#2-六大约束" class="headerlink" title="2.六大约束"></a>2.六大约束</h3><h4 id="2-1-事务"><a href="#2-1-事务" class="headerlink" title="2.1 事务"></a>2.1 事务</h4><h3 id="2-1-1-是什么"><a href="#2-1-1-是什么" class="headerlink" title="2.1.1 是什么"></a>2.1.1 是什么</h3><p>一组原子性的SQL查询，后者说是一个独立的工作单元。</p><h3 id="2-1-2-为什么"><a href="#2-1-2-为什么" class="headerlink" title="2.1.2 为什么"></a>2.1.2 为什么</h3><p>比如现实生活中银行的转账操作，必须打包在一个事务中（从转账方减去，收款方加上）。</p><h3 id="2-1-3-怎么做"><a href="#2-1-3-怎么做" class="headerlink" title="2.1.3 怎么做"></a>2.1.3 怎么做</h3><p>通过满足ACID的要求。</p><p>数据库中有四种隔离级别：</p><ol><li>READ UNCOMMITED （未提交读）</li><li>READ COMMMITTED （提交读）</li><li>REPEATABLE READ （可重复读）MYSQL默认的隔离级别。</li><li>SERIALIZABLE （可串行化）</li></ol><p>设置回滚点</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">savepoint 回滚点名rollback to 回滚点名<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>并发事务</p><p>多个事务 同时操作  同一个数据库的相同数据时。</p><p>并发问题都有哪些：</p><p>脏读：一个事务读取了其他事务还没有提交的数据</p><p>不可重复读：一个事务多次读取，结果不一样。</p><p>幻读：一个事务读取了其他事务还没有提交的数据，只是读到的是其他事务“插入”的数据。</p><p>通过设置隔离级别来解决并发问题。</p><p><img src="/2021/03/15/database/%E7%BA%A6%E6%9D%9F.PNG"></p><p>tips: </p><ul><li>创建表时添加</li><li>修改表时添加</li></ul><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">CREATE TABLE TEST{字段名 字段类型 列级约束表级约束}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-1-约束分类"><a href="#2-1-约束分类" class="headerlink" title="2.1 约束分类"></a>2.1 约束分类</h4><p>NOT NULL 非空，该字段</p><p>UNIQUE 唯一，该字段的值不可重复</p><p>DEFAULT 默认，该字段的值不用手动插入有默认值。</p><p>CHECK 检查，mysql不支持。</p><p>PRIMARY KEY</p><p>FOREIGN KEY</p><p>主键和唯一的区别：</p><p>主键不允许为空，唯一允许为空</p><p>一个表至多一个主键，唯一可以多个。</p><p>相同点：都具有唯一性。</p><ul><li><p>列级约束</p><p>六大约束都支持，但外键约束咩有效果。 不可以起约束名字。</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">CREATE TABLE stuinfo{id INT PRIMARY KEY,stuName VARCHAR(20) NOT NULL,gender CHAR(1) CHECK(gender = '男' OR gender = '女',seat INT UNIQUE,    age INT DEFAULT 18,    majorId INT FOREIGN KEY REFERENCE major(id)}CREATE TABLE major{    id INT PRIMARY KEY,                 }                               <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>表级约束</p><p>除了非空、默认，其他都支持。 可以起约束名字，但对主键无效。</p></li></ul><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">CREATE TABLE stuinfo{id INT,stuName VARCHAR(20) NOT NULL,gender CHAR(1) CHECK(gender = '男' OR gender = '女',seat INT UNIQUE,    age INT DEFAULT 18,    majorId INT,    CONSTRAINT pk PRIMARY KEY(id),    CONSTRAINT ue UNIQUE(seat),    CONSTRAINT fp_stuinfo_major FOREIGN KEY(majorID) REFERENCE major(id)                     }CREATE TABLE major{    id INT PRIMARY KEY,                 }  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通用写法：</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">CREATE TABLE stuinfo{id INT PRIMARY KEY,stuName VARCHAR(20) NOT NULL,gender CHAR(1) CHECK(gender = '男' OR gender = '女',seat INT UNIQUE,    age INT DEFAULT 18,    CONSTRAINT fp_stuinfo_major FOREIGN KEY(majorID) REFERENCE major(id) ## 只写外键                         }CREATE TABLE major{    id INT PRIMARY KEY,                 }  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-2-主键和唯一键区别"><a href="#2-2-主键和唯一键区别" class="headerlink" title="2.2 主键和唯一键区别"></a>2.2 主键和唯一键区别</h4><table><thead><tr><th>name</th><th>唯一性</th><th>允许空</th><th>一个表中多少个</th><th>允许组合</th></tr></thead><tbody><tr><td>主键</td><td>是</td><td>不允许</td><td>最多一个</td><td>允许</td></tr><tr><td>唯一键</td><td>是</td><td>允许</td><td>可以多个unique</td><td>允许</td></tr></tbody></table><p>唯一键<code>null</code>只能有一个</p><h3 id="2-3-外键的特点"><a href="#2-3-外键的特点" class="headerlink" title="2.3 外键的特点"></a>2.3 外键的特点</h3><ol><li>要求从表设置外键关系。</li><li>从表外键列类型和主表类型一致或兼容，名称无所谓。</li><li>主表的关联列必须是key（一般是主键或唯一）</li><li>插入数据先插入主表再从表，删除顺序相反。</li></ol><h4 id="2-4-修改表添加约束"><a href="#2-4-修改表添加约束" class="headerlink" title="2.4 修改表添加约束"></a>2.4 修改表添加约束</h4><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">ALTER TABLE stuInfo MODIFY COLUMN stuname VARCHAR(20) NOT NULL # 非空约束# 列级约束ALTER TABLE stuInfo MODIFY COLUMN id INT PRIMARY KEY;# 表级约束ALTER TABLE stuInfo ADD PRIMARY KEY(id);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-5-修改表时删除约束"><a href="#2-5-修改表时删除约束" class="headerlink" title="2.5 修改表时删除约束"></a>2.5 修改表时删除约束</h4><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql"># 删除唯一键ALTER TABLE stuInfo DROP INDEX seat;# 删除主键ALTER TABLE stuInfo DROP PRIMARY KEY;# 删除外键ALTER TABLE stuInfo DROP FOREIGN KEY majorid;# 或者可以直接更改原来的形式 not null ---&gt; nullALTER TABLE stuInfo MODIFY stuname VARCHAR(20) NULL;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-标识列"><a href="#3-标识列" class="headerlink" title="3. 标识列"></a>3. 标识列</h3><ul><li>自增长列，系统提供默认的序列值（1开始）</li><li>一个表只能有一个标识列</li><li>只能是数值型 （INT FLOAT DOUBLE)</li><li>mysql 可以设置步长</li></ul><h4 id="3-1-创建表时"><a href="#3-1-创建表时" class="headerlink" title="3.1 创建表时"></a>3.1 创建表时</h4><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">CRATE TABLE test{id INT PRIMARY KEY AUTO_INCREMENT,NAME VARCHAR(20)}set auto_increment_increment=3 #步长每次加3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-2-修改表时"><a href="#3-2-修改表时" class="headerlink" title="3.2 修改表时"></a>3.2 修改表时</h4><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">ALTER TABLE tab_identity MODIFY COLUMN id PRIMARY KEY AUTO_INCREMENT;# 删除自增ALTER TABLE tab_identity MODIFY COLUMN id PRIMARY KEY;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="3-3-隔离级别"><a href="#3-3-隔离级别" class="headerlink" title="3.3 隔离级别"></a>3.3 隔离级别</h4><p>4种事务隔离级别。</p><p>MYSQL四种都支持，默认REPEATEBLE READ。 </p><p>READ UNCOMMITTED</p><p>READ COMMITED 避免脏读</p><p>REPEATABLE READ 脏读和不可重复读都避免</p><p>SERIALIZABLE 串行化，效率十分低下。</p><h3 id="4-视图"><a href="#4-视图" class="headerlink" title="4. 视图"></a>4. 视图</h3><h4 id="4-1-视图"><a href="#4-1-视图" class="headerlink" title="4.1 视图"></a>4.1 视图</h4><p>概念：虚拟表，和普通表一样使用。通过表动态生成的数据。<font color="red">只保存sql逻辑。</font></p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">CREATE VIEW name AS...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>多个地方用到同样的查询结果，或sql语句较为复杂。</p><h4 id="4-2-视图修改"><a href="#4-2-视图修改" class="headerlink" title="4.2 视图修改"></a>4.2 视图修改</h4><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">create or replace veiw 视图名  #方式一as 查询语句alter view 视图名as 查询语句<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="4-3-视图删除"><a href="#4-3-视图删除" class="headerlink" title="4.3 视图删除"></a>4.3 视图删除</h4><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">DROP VIEW 视图名，视图名...<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="4-4-显示视图"><a href="#4-4-显示视图" class="headerlink" title="4.4 显示视图"></a>4.4 显示视图</h4><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">show create view 视图名<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="4-5-视图更新"><a href="#4-5-视图更新" class="headerlink" title="4.5 视图更新"></a>4.5 视图更新</h4><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">INSERT INTO 视图名 VALUES(‘zhangfei’,'1940')<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>有一些语句是不能更新的，具备以下特点的是不能更新的</p><p>1:</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">SELECT 语句中包含子查询JOINGROUP BYJOIN（查询时使用到了JOIN）from 一个不能更新的视图WHERE 子句的子查询引用了from子句中的表DISTINCTunion union all<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="4-6-delete-和-truncate-在事务使用时的区别"><a href="#4-6-delete-和-truncate-在事务使用时的区别" class="headerlink" title="4.6 delete 和 truncate 在事务使用时的区别"></a>4.6 delete 和 truncate 在事务使用时的区别</h4><p><code>trancate</code>不支持回滚</p><p>delete每次删除一行。</p><p>trancate table一次性删除所有数据且不记录日志保存，执行速度快。</p><p>执行速度上：drop &gt; trancate &gt; delete</p><h3 id="5-变量"><a href="#5-变量" class="headerlink" title="5. 变量"></a>5. 变量</h3><h4 id="5-1-系统变量"><a href="#5-1-系统变量" class="headerlink" title="5.1 系统变量"></a>5.1 系统变量</h4><p>变量有系统提供，不是用户定义，属于服务器层面。</p><ol><li>查看所有的系统变量。</li></ol><p><code>SHOW GLOBAL | 【SESSION】 VARIABLES</code></p><ol start="2"><li>查看满足条件的部分系统变量</li></ol><p><code>SHOW GLOBAL | 【SESSION】 variables like '%char%'</code></p><ol start="3"><li><p>查看指定的某个系统变量的值。</p><p><code>select @@global | 【session】.系统变量名</code></p></li><li><p>为某个系统变量赋值</p></li></ol><p><code>set @@global | session.系统变量名 = 值</code></p><h4 id="5-2-自定义变量"><a href="#5-2-自定义变量" class="headerlink" title="5.2 自定义变量"></a>5.2 自定义变量</h4><p>用户自定义的，不是由系统提供的。</p><p>声明 赋值 使用</p><ol><li>用户变量</li></ol><p>作用域：针对当前会话连接有效，同于会话变量的作用域。</p><p><code>SET @用户变量名=值</code> 或</p><p><code>set @用户变量名:=值；</code>或</p><p><code>select @用户变量名:=值</code></p><ol start="2"><li>局部变量</li></ol><p>a 声明</p><p><code>declare 变量名 类型</code></p><p><code>declare 变量名 类型 default  值</code></p><p>b 赋值</p><p>通过SET 或 SELECT</p><p><code>SET @局部变量名=值</code> 或</p><p><code>set @局部变量名:=值；</code>或</p><p><code>select @局部变量名:=值</code></p><p>c 使用</p><p><code>select 局部变量名</code></p><h4 id="5-3-存储过程和函数"><a href="#5-3-存储过程和函数" class="headerlink" title="5.3 存储过程和函数"></a>5.3 存储过程和函数</h4><p>类似于java中的方法。</p><ol><li><p>提高代码的重用性。</p></li><li><p>简化操作。</p></li><li><p>减少了编译次数，减少了和数据库的连接次数。</p></li></ol><ul><li><p>概念：一组预先编译好的SQL语句的集合，理解成批处理语句。</p></li><li><p>创建</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">create procedure 存储过程名(参数列表)BEGIN存储过程体（一组合法的SQL语句）END<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>注意：</p><ol><li><p>参数列表包括三部分</p><p>参数模式 参数名 参数类型</p><p>举例：</p><p>IN stuname VARCHAR(20)</p><p>参数模式：</p><p>IN ：该参数可以作为输入，该参数需要调用方法传入值</p><p>OUT:该参数可以作为输出，也就是该参数可以作为返回值</p><p>INOUT:该参数既可以作为输入又可以作为输出，也就是该参数既需要传入值又可以返回值。</p></li><li><p>如果存储过程体仅仅只有一句话，BEGIN END可以省略</p></li></ol></li><li><p>调用</p></li></ul><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">CALL 存储过程名(实参列表)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">DELIMITER $CREATE PROCEDURE myp1(IN beautyName VARCHAR(20), IN newName VARCHAR(20), OUT boyName VARCHAR(20),OUT userCP INT) # 还有一个INOUTBEGININSERT INTO admin(username, 'password') values('','')END $CALL myp1('柳岩')$<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="5-4-存储过程的删除和查看"><a href="#5-4-存储过程的删除和查看" class="headerlink" title="5.4 存储过程的删除和查看"></a>5.4 存储过程的删除和查看</h4><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">DROP PROCEDURE P1;SHOW CREATE PROCEDURE P1;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="6-函数"><a href="#6-函数" class="headerlink" title="6. 函数"></a>6. 函数</h2><ul><li>概念</li></ul><p>适合做处理数据返回一个结果。（增删改是适合存储过程）</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">CREATE FUNCTION 函数名（参数列表）RETURNS 返回类型begin函数体end<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="6-1-调用语法"><a href="#6-1-调用语法" class="headerlink" title="6.1 调用语法"></a>6.1 调用语法</h3><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">select 函数名(参数列表)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">返回公司的员工个数CREATE FUNCTION myf1() RETURNS INTBEGINDECLARE c INT DEFAULT 0;SELECT COUNT(*)FROM employees;RETURN c;END $SELECT myf1() $DROP FUNCTION P1;SHOW CREATE FUNCTION P1;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="7-分支结构"><a href="#7-分支结构" class="headerlink" title="7. 分支结构"></a>7. 分支结构</h2><h3 id="7-2-case"><a href="#7-2-case" class="headerlink" title="7.2 case"></a>7.2 case</h3><p>情况一：（作为独立语句才可返回语句，并且只能放在BEGIN END中）</p><p> case 变量|表达式|字段</p><p>when 要判断的值 THEN 返回的值或语句1；</p><p>…</p><p>else 要返回的值或语句</p><p>END CASE;</p><p>情况二：</p><p> case 变量|表达式|字段</p><p>when 要判断的值 THEN 返回的值或语句；</p><p>…</p><p>else 要返回的值</p><p>END CASE;</p><h3 id="7-3-IF结构"><a href="#7-3-IF结构" class="headerlink" title="7.3 IF结构"></a>7.3 IF结构</h3><p>实现多重分支。</p><h2 id="8-循环结构"><a href="#8-循环结构" class="headerlink" title="8. 循环结构"></a>8. 循环结构</h2><h3 id="8-1-WHILE"><a href="#8-1-WHILE" class="headerlink" title="8.1 WHILE"></a>8.1 WHILE</h3><p>while 循环条件 do</p><p>循环体</p><p>end while;</p><h3 id="8-2-loop"><a href="#8-2-loop" class="headerlink" title="8.2 loop"></a>8.2 loop</h3><p>loop</p><p>循环体；//要搭配leave。</p><p>end loop;</p><h3 id="8-3-repeat"><a href="#8-3-repeat" class="headerlink" title="8.3 repeat"></a>8.3 repeat</h3><p>类似于do while</p><p>repeat</p><p>循环体</p><p>until 结束循环条件</p><p>end repeat。</p><h2 id="1-MYSQL-架构"><a href="#1-MYSQL-架构" class="headerlink" title="1. MYSQL 架构"></a>1. MYSQL 架构</h2><p><img src="/2021/03/15/database/sqlstructure.PNG"></p><ol><li>连接层</li><li>服务层</li><li>引擎层</li><li>存储层</li></ol><h2 id="1-索引"><a href="#1-索引" class="headerlink" title="1. 索引"></a>1. 索引</h2><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">CREATE [UNIQUE] INDEX indexname ON mytable(columnname(length));#或ALTER mytable ADD [UNIQUE] INDEX [indexname] ON (columnname(length))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="1-1-删除索引"><a href="#1-1-删除索引" class="headerlink" title="1.1 删除索引"></a>1.1 删除索引</h3><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">DROP INDEX [indexname] ON mytable;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="1-2-查看索引"><a href="#1-2-查看索引" class="headerlink" title="1.2 查看索引"></a>1.2 查看索引</h3><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">SHOW INDEX FROM tablename;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="1-3-建立索引条件"><a href="#1-3-建立索引条件" class="headerlink" title="1.3 建立索引条件"></a>1.3 建立索引条件</h3><p><img src="/2021/03/15/database/%E5%BB%BA%E7%AB%8B%E7%B4%A2%E5%BC%95%E6%9D%A1%E4%BB%B6.PNG"></p><h3 id="1-4-不建立索引条件"><a href="#1-4-不建立索引条件" class="headerlink" title="1.4 不建立索引条件"></a>1.4 不建立索引条件</h3><ol><li>表的记录太少</li><li>经常增删改的表</li><li>某个列包含很多重复的数据，建立索引没有太大的实际效果。</li></ol><h3 id="1-5-索引失效场景"><a href="#1-5-索引失效场景" class="headerlink" title="1.5 索引失效场景"></a>1.5 索引失效场景</h3><ol><li>组合索引未使用最左前缀，例如组合索引（A，B），where B=b不会使用索引；</li><li>like未使用最左前缀，where A like ‘%China’；</li><li>搜索一个索引而在另一个索引上做order by，where A=a order by B，只使用A上的索引，因为查询只使用一个索引 ；</li><li>or会使索引失效。如果查询字段相同，也可以使用索引。例如where A=a1 or A=a2（生效），where A=a or B=b（失效）</li><li>如果列类型是字符串，要使用引号。例如where A=’China’，否则索引失效（会进行类型转换）；</li><li>在索引列上的操作，函数（upper()等）、or、！=(&lt;&gt;)、not in等；</li></ol><p><img src="/2021/03/15/database/%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88.PNG"></p><h3 id="1-6-性能下降"><a href="#1-6-性能下降" class="headerlink" title="1.6 性能下降"></a>1.6 性能下降</h3><ol><li>查询语句写的烂</li><li>索引失效</li><li>关联查询太多join</li><li>服务器调优及各个参数的设置。</li></ol><h3 id="1-7-row-gap-lock-next-key-lock"><a href="#1-7-row-gap-lock-next-key-lock" class="headerlink" title="1.7 row\gap lock\next_key lock"></a>1.7 row\gap lock\next_key lock</h3><p>首先，要明白锁是建立在索引上的，所以如果不是索引，那么就会锁住整张表。</p><p>其次，分情况讨论索引类型：</p><p>比如我数据库中有这么一张表user2：</p><p><img src="/2021/03/15/database/rowlock.PNG"></p><ol><li><p>UNIQUE （唯一键索引 id）</p><p>执行 <code>select * from user2 where id = 5 for update</code>；</p><ol><li>锁有此纪录（5），next_key lock退化成行锁，只锁定这一行。</li><li>锁无此记录（比如将上面的语句改为id=6），唯一索引都是确定的不用边界，退化成gap 锁，锁定这个范围（开区间 （5，7））。</li></ol></li><li><p>普通索引 （val）</p><p>执行 <code>select * from user2 where val = 3 for update</code>；</p><ol><li>锁有记录(val = 3)，锁定范围是(1,3] [3,6]</li><li>锁无记录(上面语句 val = 4) ,锁定范围是(3,6]。</li></ol><p>普通索引锁定范围+下边界。</p></li></ol><p>这句话是别人的总结：<br>1，Record Lock：单个行记录上的锁<br>2，Gap Lock：间隙锁，锁定一个范围，但不包括记录本身。GAP锁的目的，是为了防止同一事务的两次当前读，出现幻读的情况<br>3，Next-Key Lock：1+2，锁定一个范围，并且锁定记录本身。对于行的查询，都是采用该方法，主要目的是解决幻读的问题。</p><h2 id="2-7种JOIN"><a href="#2-7种JOIN" class="headerlink" title="2. 7种JOIN"></a>2. 7种JOIN</h2><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">SELECT DISTINCT &lt;select_list&gt;FROM&lt; left_table&gt; &lt;join_type &gt;JOIN &lt; right_table&gt; ON &lt;join_condition&gt;where&lt; where_condition &gt;GROUP BY&lt; group_by_list &gt;HAVING&lt; having_condition &gt;ORDER BY&lt; order_by_condition &gt;LIMIT &lt; limit_number &gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/2021/03/15/database/%E6%9C%BA%E8%AF%BB%E9%A1%BA%E5%BA%8F.PNG"></p><p><img src="/2021/03/15/database/JOIN7%E7%A7%8D.PNG"></p><h3 id="7-1-SQL-优化器"><a href="#7-1-SQL-优化器" class="headerlink" title="7.1 SQL 优化器"></a>7.1 SQL 优化器</h3><ul><li>概念</li></ul><p>它按照自己搜集的统计信息给出它认为最优的执行计划。</p><h3 id="7-2-EXPLAIN"><a href="#7-2-EXPLAIN" class="headerlink" title="7.2 EXPLAIN"></a>7.2 EXPLAIN</h3><ol><li>慢查询的开启并捕获。</li><li>explain + 慢SQL分析</li><li>show profile查询SQL在Mysql服务器里面的执行细节和生命周期情况。</li><li>SQL数据库服务器的参数调优。</li></ol><table><thead><tr><th>id</th><th>select_type</th><th>table</th><th>type</th><th>possible_keys</th><th>key</th><th>key_len</th><th>ref</th><th>rows</th><th>Extra</th></tr></thead><tbody><tr><td>select查询的序列号，包含的一组数字，表示查询中执行select子句或操作表的顺序。</td><td>SIMPLE、PRIMARY、SUBQUERY、DERIVED、UNION、UNION RESULT 查询的类型，普通查询、联合查询、子查询等复杂查询</td><td>衍生 = derived (给这个表重新起了一个名字)</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>id相同，执行顺序由上到下</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>id 不相同，id的序号会递增，id值越大优先级越高，越先被执行。</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>id 相同不同，同时存在</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><ul><li>id 表的读取顺序</li></ul><ul><li><p>select_type 数据读取操作的操作类型</p><ul><li><p>简单的select查询，查询中不包含子查询或者UNION</p></li><li><p>PRIMARY 鸡蛋壳，最后加载的那个</p></li><li><p>SUBQUERY 括号里的子查询</p></li><li><p>DERIVED 临时表，把结果放在临时表里的。FROM 列表包含子查询表记derived。</p></li><li><p>UNION 若第二个SELECT出现在UNION之后，则被标记为UNION。若UNION出现在FROM的子查询中，外层SELECT被标记为DERIVED。</p></li><li><p>UNION RESULT 从union表中获取union结果。</p></li></ul></li><li><p>type 访问类型</p><ul><li><p> |ALL|index|range|ref|eq_ref|const| system|null|</p></li><li><p> 从最好到最差依次如下： system &gt; const &gt; eq_ref &gt; ref &gt; range &gt; index &gt; ALL</p></li><li><p> 只要达到range级别，就够好了。</p></li><li><p> system 表只有一行记录（等于系统表）。这是类型的特例，平时不会出现，这个也可以忽略不计。</p></li><li><p> const 表示通过索引一次就找到了，const用于比较primary key或者unique索引。因为只匹配一行数据，所以很快。如将主键置于<code>where</code>中，MYSQL就只能将该查询转换为一个常量。</p></li><li><p> eq_ref 唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配。常见于主键或唯一索引扫描。</p></li><li><p> ref 非唯一性索引扫描，返回匹配某个单独值得所有行。本质上也是一种索引访问，它返回所有匹配某个单独值的行。它可能会找到多个符合条件的行，所以它属于查找和扫描的混合体。</p></li><li><p> range 只检索给定范围的行，使用一个索引来选择行。key列显示使用了哪个索引。 where 里面用了between啥的</p></li><li><p> index 只遍历索引树。 select id from table1.</p></li><li><p> ALL 全表扫描。</p></li></ul></li></ul><ul><li>pobbible_keys</li></ul><p>显示可能应用在这张表中的索引，一个或多个。</p><p>查询涉及到的字段上若存在索引，则该索引被列出，但不一定被查询实际使用。</p><ul><li>key</li></ul><p>实际用到的索引。如果为NULL ，则没有使用索引。查询中若使用了覆盖索引，则该索引仅出现在key列表中。</p><ul><li>key_len</li></ul><p>表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度。在不损失精确性的情况下，长度越短越好。ken_len显示的值为索引字段的最大可能长度，并非实际使用长度，即key_len是根据表定义计算而得，不是通过表内检索得出的。</p><ul><li>ref</li></ul><p>显示索引的哪一列被使用了，如果可能的话，是一个常数。哪些列或常量被用于查找索引列上的值。</p><ul><li>rows （每张表有多少行被查询优化器查询）</li></ul><p>根据表统计信息及索引选用情况，大致估算出找到所需的记录所需要读取的行数。</p><ul><li>Extra</li></ul><p>包含不适合在其他列中显示但十分重要的信息。</p><p>​    * Using filesort </p><p>​    文件内排序。说明mysql会对数据使用一个外部的索引排序，而不是按照表内的索引顺序进行读取。MYSQL中无法利用索引完成的排序称之为“文件内排序”。（复合索引，排序没有用建立索引时的顺序）</p><p>​    * using temporary</p><p>使用了临时表保存中间结果。MYSQL在对查询结果排序时使用临时表。常见于排序order by 和 分布查询 group by。group by 语句一般会产生临时表。</p><p>​    * using Index</p><p>表示相应的select操作中使用了覆盖索引(Covering Index)，避免访问了表的数据行，效率不错！！！（覆盖索引指的就是现在索引里面已经覆盖了你要查的东西了，你不用再读取数据文件了。）</p><p>如果同时出现using where， 表明索引被用来执行索引键值的查找。</p><p>如果没有出现using where， 表明索引被用来读取数据而非执行查找动作。</p><ul><li><p>using where </p><p>使用where过滤</p></li><li><p>using join buffer 使用连接缓冲</p></li><li><p>impossible where where子句总是false，不能用来获取元素</p></li><li><p>select tables optimized away 没有groupby字句的情况下，基于索引优化MIN/MAX操作或者对于myisam存储引擎优化count(*)操作，不必等到执行阶段再进行计算，查询执行计划生成阶段即完成优化。</p></li><li><p>distinct 优化distinct操作，在找到第一匹配的元组后即停止找同样值的动作。</p></li></ul><ol><li>表的读取顺序</li></ol><ol start="2"><li>数据读取操作的操作类型</li></ol><ol start="3"><li>哪些索引可以使用</li></ol><ol start="4"><li>哪些索引被实际使用</li></ol><ol start="5"><li>表之间的引用</li></ol><ol start="6"><li>每张表有多少行被优化器查询</li></ol><h3 id="7-3-小表驱动大表"><a href="#7-3-小表驱动大表" class="headerlink" title="7.3 小表驱动大表"></a>7.3 小表驱动大表</h3><p>当B表的数据集必须小于A表数据集时，用in优于exists。</p><p>exists子查询只返回<code>true</code>或<code>false</code>。</p><h3 id="7-4-ORDER-BY-使用index排序"><a href="#7-4-ORDER-BY-使用index排序" class="headerlink" title="7.4 ORDER BY  使用index排序"></a>7.4 ORDER BY  使用index排序</h3><ol><li>ORDER BY 语句使用索引最左前列。</li><li>使用where子句与Order BY 子句条件列组合满足索引最左前列。</li></ol><h3 id="7-5-filesort"><a href="#7-5-filesort" class="headerlink" title="7.5 filesort"></a>7.5 filesort</h3><ol><li>双路排序</li></ol><p>MYSQL 4.1之前使用双路排序，意思是两次扫描磁盘，最终得到数据。（从磁盘读取排序字段，在buffer进行排序，再从磁盘读取其他字段）。</p><p>读取行指针和<code>orderby</code>列，对他们进行排序，然后扫描已经排序好的列表，按照列表中的值重新从列表中</p><ol start="2"><li>单路排序</li></ol><p>从磁盘读取查询需要的所有列，按照orderby列在buffer对它们进行排序，然后扫描排序后的列表进行输出，它的效率更快一些，避免出现了第二次读取数据。并且把随机IO变成了顺序IO，但是它会使用更多空间，因为把每一行都保存在内存。</p><p><font color="red">MYSQL两种排序：文件排序和扫描有序索引排序。</font></p><h3 id="7-6-慢查询日志"><a href="#7-6-慢查询日志" class="headerlink" title="7.6 慢查询日志"></a>7.6 慢查询日志</h3><p>mysql默认没有开启慢查询日志，需要手动设置。如果不是调优，一般不开启。</p><p><code>SHOW VARIABLES LIKE '%slow_query_log%'</code></p><p>由<code>long_query_time</code>控制，默认情况下<code>long_query_time</code>的值为10秒。</p><p><code>mysqldumpslow -s r -t 10 XXX.log</code> 得到返回记录集最多的10个SQL。</p><p>第一步，发现问题</p><p>第二步， 开启慢查询 抓取和截取</p><p>第三步，explain </p><p>第四步， show profile 更改配置</p><h3 id="7-7-Show-Profile"><a href="#7-7-Show-Profile" class="headerlink" title="7.7 Show Profile"></a>7.7 Show Profile</h3><p><code>Show Profile</code>是mysql提供可以用来分析当前会话中语句执行的资源消耗情况。可以用于SQL的调优的测量。</p><p>默认情况下，参数处于关闭状态，并保存最近15次的运行结果。</p><p>使用步骤：</p><ol><li><p><code>Show variables like 'prifiling'</code> 查看是否关闭，准备将其打开</p></li><li><p><code>set profiling=on</code></p></li><li><p>查看结果 <code>show profiles</code></p></li><li><p><code>show profile cpu,block io for query 2;</code> 2表示查询语句的id</p><p>这里语句中只写了cpu和io，还有其他信息，参数有：</p><p><img src="/2021/03/15/database/showprofiles.PNG"></p></li><li></li></ol><p><img src="/2021/03/15/database/showprofilep.PNG"></p><h3 id="7-8-全局查询日志"><a href="#7-8-全局查询日志" class="headerlink" title="7.8 全局查询日志"></a>7.8 全局查询日志</h3><p>不要在生产环境中开启这个功能。测试环境下使用。</p><p><code>set global general_log=1</code></p><p><code>set global log_output='TABLE'</code>此后，所编写的sql语句，将会记录到mysql库里的general_log表里，可以用下面命令查看：</p><p><code>select * from mysql.general_log</code></p><h2 id="3-锁机制"><a href="#3-锁机制" class="headerlink" title="3. 锁机制"></a>3. 锁机制</h2><h3 id="3-1-表锁"><a href="#3-1-表锁" class="headerlink" title="3.1 表锁"></a>3.1 表锁</h3><ul><li><code>show open tables</code></li><li>手动上锁</li></ul><p><code>lock table 表名字 read(write)， 表名字2 read(write)， 其他</code></p><ul><li>释放锁</li></ul><p><code>unlock tables</code></p><p>读锁的使用：</p><p>加了读锁，可以读，但是不能写这个表了，这个数据库中的其他表也不能读了。（读写复制的原因）</p><p>第二个session再来此数据库中的更改其他表也只能阻塞。</p><p>写锁的使用：</p><p>加了写锁，可以更改此表，不能查询其他表。</p><p>第二个session可以查其他表，但是不能查此表。</p><h4 id="3-1-1-MYISAM"><a href="#3-1-1-MYISAM" class="headerlink" title="3.1.1 MYISAM"></a>3.1.1 MYISAM</h4><p>偏读锁。在执行查询语句(select)前，会自动给涉及的所有表加读锁，在执行增删改操作前，会自动给涉及的表加写锁。</p><ul><li>表级锁有两种模式</li></ul><p>表共享读锁（Table Read Lock)</p><p>表独占写锁（Table Write Lock）</p><table><thead><tr><th align="center">锁类型</th><th align="center">可否兼容</th><th align="center">读锁</th><th align="center">写锁</th></tr></thead><tbody><tr><td align="center">读锁</td><td align="center">是</td><td align="center">是</td><td align="center">否</td></tr><tr><td align="center">写锁</td><td align="center">是</td><td align="center">否</td><td align="center">否</td></tr></tbody></table><ol><li>对Myisam表的读操作（加读锁），不会阻塞其他进程对同一表的读请求，但会阻塞对同一表的写请求。只有当读锁释放后，才会执行其他进程的写操作。</li><li>对MyISAM表的写操作（加写锁），会阻塞其他进程对同一表的读和写操作，只有当写锁释放后，才会执行其他进程的读写操作。</li></ol><h4 id="3-2-1-分析表的锁定"><a href="#3-2-1-分析表的锁定" class="headerlink" title="3.2.1 分析表的锁定"></a>3.2.1 分析表的锁定</h4><p><code>show status like 'table%'</code></p><h3 id="3-2-行级锁"><a href="#3-2-行级锁" class="headerlink" title="3.2 行级锁"></a>3.2 行级锁</h3><p>查看命令：</p><p><code>show status like 'innodb_row_lock%'</code>;</p><p><img src="/2021/03/15/database/%E8%A1%8C%E9%94%81%E6%9F%A5%E7%9C%8B.PNG"></p><p><img src="/2021/03/15/database/%E8%A1%8C%E9%94%81%E5%8F%82%E6%95%B0%E8%A7%A3%E9%87%8A.PNG"></p><p>Innodb支持，myisam不支持。</p><p>索引失效，将会使得行锁变表锁。</p><h4 id="3-2-1-间隙锁"><a href="#3-2-1-间隙锁" class="headerlink" title="3.2.1 间隙锁"></a>3.2.1 间隙锁</h4><p>当使用范围条件而不是相等条件检索数据，并请求共享或排他锁时，InnoDB会给符合条件的已有数据记录的索引项加锁。对于键值在条件范围内但并不存在的记录，叫做”间隙锁“。InnoDB也会给这个”间隙“加锁，这种锁机制就是所谓的间隙锁。</p><h4 id="3-2-2-锁定某一行"><a href="#3-2-2-锁定某一行" class="headerlink" title="3.2.2 锁定某一行"></a>3.2.2 锁定某一行</h4><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">begin;select * from test_innodb_lock where a = 8 for update;#锁定一行后，其他操作会被阻塞，直到commit；commit;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="4-主从复制"><a href="#4-主从复制" class="headerlink" title="4. 主从复制"></a>4. 主从复制</h2><p><img src="/2021/03/15/database/%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6.PNG"></p><p>复制分为三步：</p><ol><li>master将改变记录到二进制日志(binary log)。这些记录过程叫做二进制日志事件，binary log events。</li><li>slave将master的binary log events拷贝到它的中继日志（relay log);</li><li>slave重做中继日志的事件，将改变应用到自己的数据库中。mysql复制是异步且串行化。</li></ol><h4 id="4-1-配置"><a href="#4-1-配置" class="headerlink" title="4.1 配置"></a>4.1 配置</h4><ol><li>主服务唯一ID</li><li>启用二进制日志<ol><li><code>log-bin = 自己本地的路径/mysqlbin</code></li></ol></li><li>[可选]启用错误日志<ol><li><code>log-err = 自己本地路径/mysqlerr</code></li></ol></li><li>[可选]根目录<ol><li><code>basedir = "自己本地路径"</code></li></ol></li><li>[可选]临时目录<ol><li><code>tmpdir = "自己本地路径"</code></li></ol></li><li>[可选]数据目录<ol><li><code>datadir = "自己本地路径/Data/"</code></li></ol></li><li>[可选]设置不要复制的数据库<ol><li><code>binlog-ignore-db = mysql</code></li></ol></li></ol><p>配置文件更改后，重启数据库服务。</p><h1 id="MYSQL-面试题"><a href="#MYSQL-面试题" class="headerlink" title="MYSQL 面试题"></a>MYSQL 面试题</h1><h3 id="0-SQL-语句主要可以划分为以下-3-个类别。-DDL-DML-DCL"><a href="#0-SQL-语句主要可以划分为以下-3-个类别。-DDL-DML-DCL" class="headerlink" title="0. SQL 语句主要可以划分为以下 3 个类别。 DDL DML DCL"></a>0. <strong>SQL 语句主要可以划分为以下 3 个类别。</strong> DDL DML DCL</h3><p><strong>DDL（Data Definition Languages）语句：</strong>数据定义语言，这些语句定义了不同的数据段、数据库、表、列、索引等数据库对象的定义。常用的语句关键字主要包括 create、drop、alter等。</p><p><strong>DML（Data Manipulation Language）语句：</strong>数据操纵语句，用于添加、删除、更新和查询数据库记录，并检查数据完整性，常用的语句关键字主要包括 insert、delete、udpate 和select 等。(增添改查）</p><p><strong>DCL（Data Control Language）语句：</strong>数据控制语句，用于控制不同数据段直接的许可和访问级别的语句。这些语句定义了数据库、表、字段、用户的访问权限和安全级别。主要的语句关键字包括 grant、revoke 等。</p><h3 id="1-数据库三大范式是什么"><a href="#1-数据库三大范式是什么" class="headerlink" title="1. 数据库三大范式是什么"></a>1. 数据库三大范式是什么</h3><p>第一范式：每个列都不可以再拆分。</p><p>第二范式：在第一范式的基础上，非主键列完全依赖于主键，消除非主键堆码的部分函数依赖。（比如通过码，必须可以确定表中的其他所有属性。如果还有其他属性无法推测，则不符合第二范式）</p><p><img src="/2021/03/15/database/%E7%AC%AC%E4%BA%8C%E8%8C%83%E5%BC%8F%E5%AE%9E%E4%BE%8B.PNG"></p><p>图中通过id 和姓名组成了码，可以推断系名和系主任，但是课名无法推测，所以不是第二范式。</p><p><img src="/2021/03/15/database/%E4%BA%8C%E8%8C%83%E5%BC%8F%E9%97%AE%E9%A2%98.PNG"></p><p>插入异常：往这张表新插入一个系id空的，插不进去。</p><p>删除异常：删除id系也删除了。</p><p>第三范式：在第二范式的基础上，消除传递函数依赖。非主键列只依赖于主键，不依赖于其他非主键。 </p><p><img src="/2021/03/15/database/%E4%B8%89%E8%8C%83%E5%BC%8F%E5%AE%9E%E4%BE%8B.PNG"></p><p>系主任依赖于系名，系名又依赖于id，系主任又依赖于id（传递了）。</p><p>还有BCNF范式 4范式 5范式，这几个很少说了</p><h3 id="2-数据库的权限表"><a href="#2-数据库的权限表" class="headerlink" title="2. 数据库的权限表"></a>2. 数据库的权限表</h3><p>MySQL服务器通过权限表来控制用户对数据库的访问，权限表存放在<code>mysql</code>数据库里，由mysql_install_db脚本初始化。这些权限表分别user，db，table_priv，columns_priv和host。下面分别介绍一下这些表的结构和内容：</p><ul><li>user权限表：记录允许连接到服务器的用户帐号信息，里面的权限是全局级的。</li><li>db权限表：记录各个帐号在各个数据库上的操作权限。</li><li>table_priv权限表：记录数据表级的操作权限。</li><li>columns_priv权限表：记录数据列级的操作权限。</li><li>host权限表：配合db权限表对给定主机上数据库级操作权限作更细致的控制。这个权限表不受GRANT和REVOKE语句的影响。</li></ul><h3 id="3-innodb-myisam"><a href="#3-innodb-myisam" class="headerlink" title="3. innodb myisam"></a>3. innodb myisam</h3><p>   1.支持事务与不支持。</p><ol start="2"><li>支持外键与否。</li><li>聚集索引和非聚集索引。</li><li>innodb表级查询，不保存具体行数。myisam用一个变量保存了整个表的行数。（查行数。其他innodb快）</li><li>Innodb支持表锁和行锁，myisam只有表锁。且Innobdb支持全文检索。</li></ol><p>叶子结点保存完整的数据。 </p><p>非聚集 索引和数据分开存储。叶子节点只保存</p><h3 id="1-为什么设计索引"><a href="#1-为什么设计索引" class="headerlink" title="1. 为什么设计索引"></a>1. 为什么设计索引</h3><p>索引可以加快数据访问，快速定位数据。举个例子：我们平时写代码，一个数组存了很多数据。我们不就是通过那个指针直接访问那个数据吗？</p><p>MYSQL 使用B+数和哈希（单值索引）。</p><h3 id="2-为什么设计成B-树"><a href="#2-为什么设计成B-树" class="headerlink" title="2. 为什么设计成B+树"></a>2. 为什么设计成B+树</h3><p>哈希会碰撞和冲突。因为要查询，这种方式需要把所有数据全部放到内存里，耗费内存空间。</p><p>实际工程中大部分是范围查询。</p><p>二叉树和红黑树太深了（只存储一个值），io次数过多影响读取效率。</p><p>B树每个节点m个子树 （m - 1）个结点。</p><h3 id="4-面试中常问的存储引擎"><a href="#4-面试中常问的存储引擎" class="headerlink" title="4. 面试中常问的存储引擎"></a>4. 面试中常问的存储引擎</h3><p>MEMORY 使用哈希存储。（还有 InnoDB 和 MyIsam）。</p><p>存储引擎的区别就i是不同的数据存储方式。比如MyISAM是数据索引分开放，InnoDB是索引数据一起放。（聚簇索引和非聚簇索引）</p><h3 id="5-局部性原理"><a href="#5-局部性原理" class="headerlink" title="5. 局部性原理"></a>5. 局部性原理</h3><ol><li>时间局部性 放过的数据在最近很大可能还会被访问</li><li>空间局部性 访问过的位置的附近很大可能会被访问</li></ol><h3 id="6-InnoDB-每次规定，预读4-4K-16K-的数据"><a href="#6-InnoDB-每次规定，预读4-4K-16K-的数据" class="headerlink" title="6. InnoDB 每次规定，预读4*4K = 16K 的数据"></a>6. InnoDB 每次规定，预读4*4K = 16K 的数据</h3><h3 id="7-B-树的高度取决于你的索引是用什么类型存储的，一般使用int类型建立索引。（数值越小越好）。"><a href="#7-B-树的高度取决于你的索引是用什么类型存储的，一般使用int类型建立索引。（数值越小越好）。" class="headerlink" title="7. B+树的高度取决于你的索引是用什么类型存储的，一般使用int类型建立索引。（数值越小越好）。"></a>7. B+树的高度取决于你的索引是用什么类型存储的，一般使用int类型建立索引。（数值越小越好）。</h3><h3 id="8-B-树两种查找运算"><a href="#8-B-树两种查找运算" class="headerlink" title="8. B+树两种查找运算"></a>8. B+树两种查找运算</h3><ol><li>主键的范围查找和分页查找。</li><li>根节点开始，进行随机查找。</li></ol><p>InnoDB叶子节点中存储记录，如果没有主键，那么选择唯一键。如果没有唯一键，那么会生成一个6字节的row_id来作为主键。</p><p>如果创建索引的键是其他字段，那么叶子节点中存储的是该记录的主键，然后再通过主键索引找到对应的记录，叫做回表。</p><h3 id="9-为什么推荐主键自增"><a href="#9-为什么推荐主键自增" class="headerlink" title="9. 为什么推荐主键自增"></a>9. 为什么推荐主键自增</h3><p>分布式，不建议。</p><p>单机，建议自增。（跟业务场景相关）。如果是乱序插入，插到中间（B+树开始分裂），分裂完了还得合并，还影响到了索引列。</p><h3 id="10-回表-索引覆盖-索引下推-最左匹配"><a href="#10-回表-索引覆盖-索引下推-最左匹配" class="headerlink" title="10. 回表 索引覆盖 索引下推 最左匹配"></a>10. 回表 索引覆盖 索引下推 最左匹配</h3><p>如果创建索引的键是其他字段，那么叶子节点中存储的是该记录的主键，然后再通过主键索引找到对应的记录，叫做回表。（使用了辅助索引）</p><p>直接从索引全部命中数据——索引覆盖。</p><p>组合索引中，先从左侧的顺序匹配。</p><p>比如(select * from table where name = ? and age = ? )没有索引下推时，MYSQL会先从存储引擎中拉取数据（根据name筛选的数据），再从musql server 根据age进行数据的筛选。</p><p>有索引下推时，拉取数据直接根据name，age获取数据，不需要server做任何的数据筛选。（缺点：需要在磁盘上多做数据筛选）。</p><p>（举例：索引下推是先把所有字段拿出来再做关联，原来是先把表所有内容拿出来，查询字段）。</p><h3 id="11-优化器两种方式"><a href="#11-优化器两种方式" class="headerlink" title="11. 优化器两种方式"></a>11. 优化器两种方式</h3><ol><li><p>CBO 基于成本优化。（大部分采用）</p></li><li><p>RBO 基于规则优化</p></li></ol><h3 id="12-MRR"><a href="#12-MRR" class="headerlink" title="12. MRR"></a>12. MRR</h3><p>mult_range read。索引排序好了，加了一个排序的环节。把随机磁盘读取转化为顺序磁盘读，提高了索引查询的性能。</p><h3 id="13-FIC"><a href="#13-FIC" class="headerlink" title="13. FIC"></a>13. FIC</h3><p>fast index create。只作用于辅助索引，对于主键的创建和删除同样需要重建一张表。</p><p>插入和删除数据，先创建临时表，将数据导入到临时表中。把原始表删除。修改临时表的名字替换原始表。</p><p>有了FIC，给当前表添加一个Share锁，不会有创建临时文件的资源消耗，还是在源文件做。但是此时如果有人发起DML操作，很明显数据会不一致，所以添加share锁。</p><h3 id="14-索引分类"><a href="#14-索引分类" class="headerlink" title="14. 索引分类"></a>14. 索引分类</h3><p>主键索引 唯一索引 普通索引 组合索引 全文索引</p><h3 id="15-索引的匹配方式"><a href="#15-索引的匹配方式" class="headerlink" title="15. 索引的匹配方式"></a>15. 索引的匹配方式</h3><ol><li><p>全值匹配 </p><p>和索引中所有的列进行匹配。</p></li><li><p>匹配最左前缀</p></li></ol><ol start="3"><li>匹配列前缀</li></ol><p>匹配其中一部分，列前缀。比如 like%。</p><ol start="4"><li>匹配范围值</li></ol><ol start="5"><li>精确匹配某一列并范围匹配另外一列</li></ol><ol start="6"><li>只访问索引的查询</li></ol><h3 id="16-哈希索引"><a href="#16-哈希索引" class="headerlink" title="16. 哈希索引"></a>16. 哈希索引</h3><p>精确匹配。只有memory存储引擎显示支持哈希索引。</p><p>限制：</p><ol><li>只包含哈希值和行指针，不存储字段值。</li><li>无法排序。不是按照索引顺序存储的。</li><li>哈希使用索引列的全部内容查找，不支持列部分匹配。</li><li>支持等值比较查询，也不支持任何范围查询。</li><li>访问哈希索引速度快，当出现哈希冲突时，必须遍历链表中所所有行指针直到找到符合条件的行。</li><li>哈希冲突比较多的话，维护的代价很高。</li></ol><p>CRC32 循环冗余加密规则。</p><h3 id="17-索引优化"><a href="#17-索引优化" class="headerlink" title="17. 索引优化"></a>17. 索引优化</h3><ol><li>使用索引列查询不要使用表达式，把计算逻辑放在业务层。否则就不走索引了。</li><li>尽量使用主键查询，不会触发回表查询。自然主键和代理主键（跟业务无关性）。</li><li>前缀索引。比如字符串的前7个字符。</li><li>使用索引扫描来排序。 防止出现 using filesort。</li><li>union all，in，or都能够使用索引，但是推荐使用in。如果是单列索引，or会使用索引。如果是组合索引：如果全部是组合索引，使用表中全部列所对应的索引，如果部分列是组合索引，不会走索引。</li><li>范围列可以用到索引。&lt; &lt;= &gt; &gt;= between。如果某索引使用到了范围，那么其后面的索引列不会再走索引。</li><li>强制类型转换会触发全表扫描。</li><li>更新频繁的索引不适合建立索引。typeloglog，distinct value。</li><li>创建索引的列，不允许为null，可能会得到不符合预期的结果。</li><li>进行表连接时，最好不要超过三个表，因为join字段数据类型必须一致。</li><li>能使用limit的时候尽量使用limit。limit主要目的时限制输出。</li><li>单表索引控制在5个以内（现在没有太多的限制）。</li><li>单索引字段数不允许超过5个（组合索引）。</li><li>创建索引应该避免以下错误观念（1.索引越多越好2. 过早优化，不了解系统的情况下进行优化）。</li></ol><p>————————</p><p>监控SQL、数据库连接不要过多、数据库设计之初、索引、SQL语句的优化、设置MYSQL参数、分布式集群如何设计。</p><h3 id="18-索引监控"><a href="#18-索引监控" class="headerlink" title="18.索引监控"></a>18.索引监控</h3><p><img src="/2021/03/15/database/%E7%B4%A2%E5%BC%95%E7%9B%91%E6%8E%A7.PNG"></p><h3 id="19-Count-1-COUNT"><a href="#19-Count-1-COUNT" class="headerlink" title="19. Count(1) COUNT(*)"></a>19. Count(1) COUNT(*)</h3><p><strong>count详解：</strong></p><p><code>count(1)</code>跟<code>count(主键)</code>一样，只扫描主键。</p><p><code>count(*)</code>跟<code>count(非主键)</code>：</p><p>　　count(*)将返回表格中所有存在的行的总数包括值为null的行，然而count(列名)将返回表格中除去null以外的所有行的总数(有默认值的列也会被计入）.<br>　　distinct 列名,得到的结果将是除去值为null和重复数据后的结果</p><p>1.优先考虑count(*)，因为数据库做了特别的优化处理。</p><p>有主键或联合主键的情况下，count(*)略比count(1)快一些。<br>没有主键的情况下count(1)比count(*)快一些。<br>如果表只有一个字段，则count(*)是最快的。<br>2.使用count()聚合函数后，最好不要跟where age = 1；这样的条件，会导致不走索引，降低查询效率。除非该字段已经建立了索引。使用count()聚合函数后，若有where条件，且where条件的字段未建立索引，则查询不会走索引，直接扫描了全表。<br>3.count(字段),非主键字段，这样的使用方式最好不要出现。因为它不会走索引.</p><h3 id="20-主从复制"><a href="#20-主从复制" class="headerlink" title="20. 主从复制"></a>20. 主从复制</h3><p>客户发请求给代理，代理给每个分库读或者写。要保证每个分库数据一致，binlog进行主从复制。master  和 slave 库，客户端操作master进行DML操作，</p><h3 id="21-读写分离"><a href="#21-读写分离" class="headerlink" title="21 读写分离"></a>21 读写分离</h3><p>客户发请求给代理，代理给每个分库读或者写。要保证每个分库数据一致，binlog进行主从复制。master  和 slave 库，客户端操作master，</p><h3 id="22-分库分表"><a href="#22-分库分表" class="headerlink" title="22. 分库分表"></a>22. 分库分表</h3><h3 id="23-MVCC"><a href="#23-MVCC" class="headerlink" title="23 MVCC"></a>23 MVCC</h3><h3 id="24-锁"><a href="#24-锁" class="headerlink" title="24. 锁"></a>24. 锁</h3><p>表锁、行锁、页锁。</p><p>表锁（偏向MYISAM引擎。</p><h3 id="25-日志系统"><a href="#25-日志系统" class="headerlink" title="25. 日志系统"></a>25. 日志系统</h3><p><code>binlog</code> ——》 MYSQL服务的   <code>undo log</code> 和  <code>redo log</code> ——》innodb存储引擎的</p><h3 id="26-MYSQL-结构"><a href="#26-MYSQL-结构" class="headerlink" title="26. MYSQL 结构"></a>26. MYSQL 结构</h3><p><img src="/2021/03/15/database/MYSQL%E7%BB%93%E6%9E%84.PNG"></p>]]></content>
      
      
      <categories>
          
          <category> database </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>java</title>
      <link href="2021/03/15/java/"/>
      <url>2021/03/15/java/</url>
      
        <content type="html"><![CDATA[<h1 id="JAVA-常问知识点"><a href="#JAVA-常问知识点" class="headerlink" title="JAVA 常问知识点"></a>JAVA 常问知识点</h1><h3 id="求时间复杂度"><a href="#求时间复杂度" class="headerlink" title=" 求时间复杂度 "></a><font color="green"> 求时间复杂度 </font></h3><ol><li>递归树法</li></ol><p>$T(n) = 2 * T(\frac{n}{2}) + n $</p><p><img src="/2021/03/15/java/%E9%80%92%E5%BD%92%E6%B1%82%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6.PNG"></p><p><img src="/2021/03/15/java/%E9%80%92%E5%BD%92%E6%B1%82%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A61.PNG"></p><ol start="2"><li>主定理分析法</li></ol><p>$T(n) = a * T(\frac{n}{b}) + f(n)$</p><p><img src="/2021/03/15/java/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%B8%BB%E6%88%90%E5%88%86%E5%88%86%E6%9E%90.PNG"></p><p><img src="/2021/03/15/java/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%B8%BB%E6%88%90%E5%88%86%E5%88%86%E6%9E%901.PNG"></p><h2 id="1-JVM虚拟机"><a href="#1-JVM虚拟机" class="headerlink" title="1. JVM虚拟机"></a>1. JVM虚拟机</h2><p>虚拟机的启动是通过引导类加载器（bootstrap class loader）创建一个初始类（initial class）来完成的，这个类是由虚拟机的具体实现指定的。</p><p>执行引擎：</p><p><img src="/2021/03/15/java/%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E.PNG"></p><p>常见的虚拟机有：</p><ol><li>Sun Classic VM。</li><li>Exact VM。</li><li>Sum HotSpot VM</li><li>BEA JRockit</li><li>IBM J9</li></ol><h3 id="gt-面向对象和面向过程的区别"><a href="#gt-面向对象和面向过程的区别" class="headerlink" title="&nbsp;> 面向对象和面向过程的区别"></a><font color="green">&nbsp;&gt; 面向对象和面向过程的区别</font></h3><ul><li>面向过程 ： 面向过程性能很好。类调用时需要实例化，开销大消耗资源。但是面向过程没有面向对象易于维护、复扩展。</li><li>面向对象：易维护、复用、扩展。因为面向对象有封装、继承、多态的特性，低耦合系统。</li></ul><p>类加载子系统</p><p><img src="/2021/03/15/java/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F.PNG"></p><h3 id="gt-对象加载的5个步骤"><a href="#gt-对象加载的5个步骤" class="headerlink" title="> 对象加载的5个步骤"></a><font color="green">&gt; 对象加载的5个步骤</font></h3><ol><li><strong>类加载检查</strong>。当使用new 生成一个对象时，会首先去检查常量池中有没有对这个对象的引用。如果没有，再检查这个对象是否已经<font color="purple">加载、解析、初始化</font>过，如果没有，会进行类加载。</li><li><strong>分配内存</strong>。在JAVA堆中为对象分配内存。内存分配机制有两种，第一种是<strong>指针碰撞</strong>，第二种是<strong>空闲列表</strong>。分配方式由JAVA堆是否规整决定，JAVA堆是否规整又由所采用的垃圾回收器是否有压缩整理功能决定。</li><li><strong>初始化零值</strong>。为内存中已经分配的对象数据初始化零值，这样对象可以不赋初始值直接使用。</li><li><strong>分配对象头</strong>。对象头包括类元数据、对象的哈希码以及对象的GC分代年龄等。</li><li><strong>init初始化</strong>。按照程序员的意愿对类中的数据进行初始化。</li></ol><h3 id="gt-对象的内存布局"><a href="#gt-对象的内存布局" class="headerlink" title=">对象的内存布局"></a><font color="green">&gt;对象的内存布局</font></h3><ol><li><strong>对象头</strong>。包括对象的哈希码、GC分代年龄等。</li><li><strong>实例数据</strong>。程序中所s定义的各种字段内容。</li><li><strong>对齐填充</strong>。由于对象占位必须是8字节的整数倍，所以当对象实例部分空间未占满时（对象头本身是8字节的1倍或2倍），会对剩余空间进行填充。</li></ol><h3 id="gt-句柄和直接引用"><a href="#gt-句柄和直接引用" class="headerlink" title="> 句柄和直接引用"></a><font color="green">&gt; 句柄和直接引用</font></h3><ol><li><strong>句柄</strong>。指针的指针。JAVA堆中分配句柄池，存储实例对象的地址。</li></ol><p><img src="/2021/03/15/java/%E5%8F%A5%E6%9F%84.png" alt="句柄"></p><p><strong>优点</strong>：一个对象被多个变量引用，那么只需要更改句柄池一个。当对象地址改变时，只需改变句柄池内容即可。</p><p><strong>缺点</strong>：速度慢。</p><ol start="2"><li><strong>直接指针</strong>。指针，直接保存对象地址。速度快，省去了句柄池还得再次寻找地址。</li></ol><p><strong>优点</strong>：速度快。</p><p><strong>缺点</strong>：对象被移动时，所有指向该对象的reference都需要被改变，耗时。</p><h3 id="gt-双亲委派机制"><a href="#gt-双亲委派机制" class="headerlink" title="> 双亲委派机制"></a>&gt; <font color="green">双亲委派机制</font></h3><p>当要加载某个类时，需要把任务委托给上级类加载器，递归询问是否已经加载此类，如果没有，自己才会加载。</p><p><img src="/2021/03/15/java/%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6.png" alt="句柄"></p><ol><li>启动类加载器（BootstrapClassLoader）<code>C++</code> 编写</li></ol><p>加载<code>java</code>核心库 <code>java.*</code>,构造<code>ExtClassLoader</code>和<code>AppClassLoader</code>。涉及到虚拟机本地实现细节，开发者无法获取到启动类加载器的引用，不允许直接通过引用进行操作。</p><ol start="2"><li>标准扩展类加载器（ExtClassLoader）<code>java</code> 编写</li></ol><p>加载扩展库如<code>classpath</code>中的<code>jre</code> ，<code>javax.*</code>或者<br><code>java.ext.dir</code> 指定位置中的类，开发者可使用标准扩展类加载器。</p><ol start="3"><li>系统类加载器 （AppClassLoader）<code>java</code> 编写</li></ol><p>加载程序所在的目录，如<code>user.dir</code>所在的位置的<code>class</code>。</p><ol start="4"><li>用户自定义类加载器（CustomClassLoader）<code>java</code> 编写</li></ol><p>用户自定义的类加载器,可加载指定路径的<code>class</code>文件</p><p>作用：</p><p>1.防止重复加载同一个类。</p><p>2.防止代码被篡改。（只能有一个被加载的类，已经加载的类不能被篡改）。</p><h3 id="lt-JVM结构"><a href="#lt-JVM结构" class="headerlink" title="< JVM结构"></a><font color="green">&lt; JVM结构</font></h3><p>HotSpot是使用指针的方式来访问对象：java堆中存放访问类元数据（描述数据的数据，也就是模板）的地址，reference存储的就直接是对象的地址。</p><p><img src="/2021/03/15/java/JVM1.7.png" alt="句柄"></p><p><img src="/2021/03/15/java/JVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84.png" alt="句柄"></p><pre class="line-numbers language-none"><code class="language-none">程序计数器<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol><li>程序计数器 <strong>线程私有</strong></li></ol><ul><li><p>概念：记录当前线程执行的<strong>指令字节码地址</strong>。</p></li><li><p>功能：改变这个计数器的值来选取下一条需要执行指令的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖计数器完成。</p></li><li><p><strong>唯一一个不会出现 <code>OutOfMemoryError </code>的内存区域</strong>，它的生命周期随着线程的创建而创建，随着线程的结束而死亡。</p></li></ul><pre class="line-numbers language-none"><code class="language-none">虚拟机栈<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="2"><li>虚拟机栈 <strong>线程私有</strong></li></ol><p><img src="/2021/03/15/java/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88.png" alt="句柄"></p><p><img src="/2021/03/15/java/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%882.png" alt="句柄"></p><ul><li><p>栈存储的是对象的引用变量、8种基本类型和实例方法。</p></li><li><p>栈帧理解成java中的方法。stackoverflowerror是个错误。</p></li><li><p>Java虚拟机栈是由一个个栈帧组成，而每个栈帧中都拥有：局部变量表、操作数栈、动态链接、方法出口信息。</p></li><li><p><strong>局部变量表主要存放了编译器可知的各种数据类型</strong>（boolean、byte、char、short、int、float、long、double）、<strong>对象引用</strong>（reference类型，它不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）。</p></li><li><p>Java 虚拟机栈会出现两种异常：StackOverFlowError 和 OutOfMemoryError。</p><p><strong>StackOverFlowError：</strong> 若Java虚拟机栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前Java虚拟机栈的最大深度的时候，就抛出StackOverFlowError异常。</p><p><strong>OutOfMemoryError：</strong> 若 Java 虚拟机栈的内存大小允许动态扩展，且当线程请求栈时内存用完了，无法再动态扩展了，此时抛出OutOfMemoryError异常。</p></li><li><p>Java方法有两种返回方式：</p></li></ul><ol><li><p>return 语句。</p></li><li><p>抛出异常。</p><p>不管哪种返回方式都会导致栈帧被弹出。</p></li></ol><ul><li><strong>i++ 和 ++i 的区别：</strong><ol><li>i++：从局部变量表取出 i 并压入操作栈(load memory)，然后对局部变量表中的 i 自增 1(add&amp;store memory)，将操作栈栈顶值取出使用，如此线程从操作栈读到的是自增之前的值。</li><li>++i：先对局部变量表的 i 自增 1(load memory&amp;add&amp;store memory)，然后取出并压入操作栈(load memory)，再将操作栈栈顶值取出使用，线程从操作栈读到的是自增之后的值。</li></ol></li></ul><pre class="line-numbers language-none"><code class="language-none">本地方法栈<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="3"><li>本地方法栈 <strong>线程私有</strong></li></ol><ul><li><p> <strong>虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。</strong> 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。（本地方法=android 里面的JNI 用其他语言例如C++)</p></li><li><p> 本地方法被执行的时候，在本地方法栈也会创建一个栈帧，用于存放该本地方法的局部变量表、操作数栈、动态链接、出口信息。</p></li><li><p> 也会出现 StackOverFlowError 和 OutOfMemoryError 两种异常。</p></li></ul><pre class="line-numbers language-none"><code class="language-none">java堆<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="4"><li>堆 线程<strong>共享</strong></li></ol><ul><li><p>存放<strong>对象实例</strong>，几乎所有的对象实例以及<strong>数组</strong>都在这里分配内存。</p></li><li><p>主要记<strong>垃圾回收机制</strong>。</p></li></ul><pre class="line-numbers language-none"><code class="language-none">方法区<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="5"><li>方法区 线程<strong>共享</strong> JDK1.8替换为元空间</li></ol><ul><li>存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</li><li>别名叫做 Non-Heap（非堆）。永久代也叫方法区。</li></ul><pre class="line-numbers language-none"><code class="language-none">运行时常量池<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="6"><li>运行时常量池 线程<strong>共享</strong></li></ol><ul><li><p>是方法区的一部分。Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池（Constant Pool Table），用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。</p></li><li><p>运行期间也可能将新的常量放入池中，例如 String 类的 intern() 方法。</p></li></ul><pre class="line-numbers language-none"><code class="language-none">直接内存<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="7"><li>直接内存 线程<strong>共享</strong></li></ol><ul><li><p>不是 Java 虚拟机规范中定义的内存区域。</p></li><li><p>受到本机总内存（包括 RAM 以及 SWAP 区或者分页文件）大小以及处理器寻址空间的限制。</p></li></ul><pre class="line-numbers language-none"><code class="language-none">元空间<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="8"><li>元空间 线程<strong>共享</strong></li></ol><ul><li>使用本地内存（直接内存）来存储类元数据信息并称之为：元空间（Metaspace）</li><li>java8中移除了永久代（就是<strong>方法区</strong>），新增元空间，这两者之间存储的内容（常量池，类信息，还有class的static变量）几乎没怎么变化，而是在内存限制、垃圾回收等机制上改变较大。元空间的出现就是为了解决突出的类和类加载器元数据过多导致的内存溢出问题。</li></ul><ol><li>使用JDK1.7运行Java程序，监控并耗尽默认设定的85MB大小的PermGen（1.7之前是PermGen，1.8改为元空间）内存空间。</li><li>使用JDK1.8运行Java程序，监控新Metaspace内存空间的动态增长和垃圾回收过程。</li><li>使用JDK1.8运行Java程序，模拟耗尽通过“MaxMetaspaceSize”参数设定的128MB大小的Metaspace内存空间。</li></ol><p><img src="/2021/03/15/java/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA3.png" alt="句柄"></p><ol start="9"><li>堆参数调优</li></ol><table><thead><tr><th>-Xms</th><th>设置初始分配大小，默认为物理内存的“1/64”</th></tr></thead><tbody><tr><td>-Xmx</td><td>最大分配内存，默认为物理内存的”1/4”</td></tr><tr><td>-XX:+PrintGCDetails</td><td>输出详细的GC处理日志</td></tr><tr><td>-XX:MaxTenuringThreshold</td><td>设置对象在新生代中的存活的次数</td></tr></tbody></table><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token punctuation">{</span>    <span class="token class-name">Runtime<span class="token punctuation">.</span>GetRuntime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">availableProcessors</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">Runtime<span class="token punctuation">.</span>GetRuntime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">maxMemory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">Runtime<span class="token punctuation">.</span>GetRuntime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">totalMemory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>最好初始内存和最大内存设置成一样的。避免内存忽高忽低。</li></ul><h3 id="lt-垃圾回收机制"><a href="#lt-垃圾回收机制" class="headerlink" title="< 垃圾回收机制"></a><font color="green">&lt; 垃圾回收机制</font></h3><p>GC = YGC = 轻量级GC</p><p>养老区满了 FULL GC = FGC 重量级GC，如果没办法腾空间，则OOM</p><ol><li><strong>判定</strong>哪些对象是垃圾</li></ol><ul><li>引用计数法</li></ul><p>每个对象都分配一个引用计数器，用来存储该对象被引用的个数。当有地方引用它，计数器加1。当个数为0，则可以回收。</p><p>此方法有一个<strong>缺陷</strong>：两个对象互相引用，计数器永远不为0。所以JAVA没采用此方法。</p><ul><li>可达性分析</li></ul><p>把所有引用对象抽象成一棵树，从树<strong>GC Roots</strong>根结点出发，遍历所有树枝。找到的就是可达，判定存活，不能找到的就是可回收对象。</p><p><img src="/2021/03/15/java/%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90.png" alt="句柄"></p><ul><li>GC Roots的种类：</li></ul><p>虚拟机栈中引用的对象。</p><p>方法区中静态属性引用的对象。</p><p>方法区中常量引用的对象。</p><p>本地方法栈中JNI引用的对象。</p><p><img src="/2021/03/15/java/gc.PNG"></p><ol start="2"><li><strong>回收垃圾算法</strong> （4个）</li></ol><ul><li>标记-清理</li></ul><p>1）标记，利用可达性分析，找到垃圾对象。</p><p>优点：简单快捷。</p><p>缺点：产生内存碎片。</p><p><img src="/2021/03/15/java/%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95.png" alt="句柄"></p><ul><li>标记-整理</li></ul><p>标记清理会产生内存碎片所以：</p><p>1）可达性分析找到垃圾对象和存活对象。</p><p>2）把所有存活对象堆到同一个地方，没有内存碎片。</p><p>适合存活对象多，垃圾少的情况。</p><p><img src="/2021/03/15/java/%E6%A0%87%E8%AE%B0%E6%95%B4%E7%90%86.png" alt="句柄"></p><ul><li>复制</li></ul><p>将内存划分为大小相等的两块，每次使用其中一块。这一块用完了，将活着的队形复制到另一块，然后把使用过的内存空间一次性清理掉。</p><p><img src="/2021/03/15/java/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95.png" alt="句柄"></p><p>优点：简单快速、不会产生碎片</p><p>缺点：内存利用率很低，只用了一半。</p><ul><li><strong>分代回收算法</strong></li></ul><p>java堆分为刚刚创建的对象、存活了一段时间的对象和永久存在的对象。</p><p>新生代与老年代的比例为1：2。</p><p><img src="/2021/03/15/java/java%E6%96%B0%E7%94%9F%E4%BB%A3.png" alt="句柄"></p><p><strong>设置两个 Survivor 区解决内存碎片化</strong>。Survivor 如果只有一个区域，Minor GC 执行后，Eden 区被清空了，存活的对象放到了 S1（from） 区，而之前 S1 区中的对象，可能也有一些是需要被清除的。这时候我们怎么清除它们？在这种场景下，我们只能标记清除，标记清除最大的问题就是内存碎片。有了s2（to），将之前 Eden 区和 From 区（s1)中的存活对象复制到 To 区域(s2)。第二次 Minor GC 时，From 与 To 职责换一下，这时候会将 Eden 区和 s2 区中的存活对象再复制到 s1 区域，以此反复。</p><p><strong>新生代-复制 回收机制</strong>：</p><p>区域大小比例Eden:s1:s2= 8: 1:1（Hotspot虚拟机这样划分）。新生代每次都有大量对象死亡，只有少量存活。因此采用复制算法，回收时GC把少量存活对象复制过去即可。</p><p><strong>只有经历16次 Minor GC 还能在新生代中存活的对象，才会被送到老年代。</strong></p><p><img src="/2021/03/15/java/java%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6.png" alt="句柄"></p><p>工作原理：</p><p>1）Eden区域快满了，**触发垃圾回收机制（Young GC)**。此轮存活对象放入From(s1)。</p><p>2）Eden再次满，<strong>触发垃圾回收机制（Young GC)<strong>，回收Eden和From（s1），存活放入To（s2）。此时s1空了，下一次回收时</strong>s1和s2职责对换</strong>，下一次Eden满时将Eden和To（s2）的存活对象放入From（s1）， 如此往复。多次后一些对象在s1和s2之间多次复制，复制次数超过某个阈值<strong>（16）</strong>后，把存活对象复制到Old区域。</p><p>3）当某个s区域不足以存放存活对象，将多余对象放到Old区域。</p><p>4）Old区域满了，<strong>触发垃圾回收机制（Full GC）</strong>，进行整个堆的垃圾回收（老年代也要回收了，用老年代自己的回收算法），跳到1）进行新一轮垃圾回收算法。</p><p><strong>老年代-标记整理 回收机制</strong>：</p><p>老年代存活对象多、垃圾少。老年代仅仅通过少量地移动存活对象就能清理垃圾。</p><p><strong>Full GC</strong> 触发情况：</p><p>　　1）年老代（Tenured）被写满</p><p>　　2）持久代（Perm）被写满 </p><p>　　3）System.gc()被显示调用 </p><p>　　4）上一次GC之后Heap的各域分配策略动态变化</p><ol start="3"><li><strong>垃圾回收器</strong> （hotspot虚拟机）</li></ol><ul><li>吞吐量</li></ul><p>CPU 用于运行用户代码的时间与 CPU 总消耗时间的比值。比如说虚拟机总运行了 100 分钟，用户代码时间 99 分钟，垃圾回收 时间 1 分钟，那么吞吐量就是 99%。</p><ul><li>停顿时间</li></ul><p>停顿时间 指垃圾回收器正在运行时，应用程序 的 暂停时间。</p><ul><li>GC的名词</li></ul><p>新生代GC：Minor GC </p><p>老年代GC：Major GC</p><ul><li>并发与并行</li></ul><p>（1）串行（Parallel）</p><p>垃圾回收线程 进行垃圾回收工作，但此时 用户线程 仍然处于 等待状态。</p><p>（2）并发（Concurrent）</p><p>这里的并发指 用户线程 与 垃圾回收线程 交替执行。</p><p>（3）并行（Parallel）</p><p>这里的并行指 用户线程 和多条 垃圾回收线程 分别在不同 CPU 上同时工作。</p><p><img src="/2021/03/15/java/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8.png" alt="句柄"></p><p>回收器种类：</p><p><strong>1）Serial（单线程）</strong></p><p>Serial 回收器是最基本的 新生代垃圾回收器，是单线程的垃圾回收器。采用的是 <strong>复制</strong>算法。垃圾清理时，Serial回收器不存在线程间的切换，因此，在单 CPU的环境下，垃圾清除效率比较高。</p><p><strong>2）Serial Old（单线程）</strong></p><p>Serial Old回收器是 Serial回收器的老生代版本，单线程回收器，使用 <strong>标记-整理算法</strong>。在 JDK1.5 及其以前，它常与Parallel Scavenge回收器配合使用，达到较好的吞吐量，另外它也是 CMS 回收器在Concurrent Mode Failure时的后备方案。</p><p><strong>3）ParNew（多线程）</strong></p><p>ParNew回收器是在Serial回收器的基础上演化而来的，属于Serial回收器的多线程版本，采用<strong>复制</strong>算法。运行在新生代区域。在实现上，两者共用很多代码。在不同运行环境下，根据CPU核数，开启不同的线程数，从而达到最优的垃圾回收效果。</p><p><img src="/2021/03/15/java/parnew%E5%92%8Cserial%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6.png" alt="句柄"></p><p><strong>4）Parallel Scavenge（多线程）</strong></p><p>运行在新生代区域，属于多线程的回收器，采用<strong>复制</strong>算法。与ParNew不同的是，ParNew回收器是通过控制垃圾回收的线程数来进行参数调整，而Parallel Scavenge回收器更关心的是程序运行的吞吐量。即一段时间内用户代码运行时间占总运行时间的百分比。</p><p><strong>5）Parallel Old（多线程）</strong></p><p>Parallel Old回收器是Parallel Scavenge回收器的老生代版本，属于多线程回收器，采用<strong>标记-整理算法</strong>。Parallel Old回收器和Parallel Scavenge回收器同样考虑了吞吐量优先这一指标，非常适合那些注重吞吐量和CPU资源敏感的场合。</p><p><img src="/2021/03/15/java/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6parallelold.png" alt="句柄"></p><p><strong>6）CMS（多线程回收）</strong></p><p>CMS回收器是回收老年代收集器。在最短回收停顿时间为前提的回收器，属于多线程回收器，采用标记-清除算法。</p><p><img src="/2021/03/15/java/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6CMS.png" alt="句柄"></p><p>初始标记 ：标记GC Roots能直接关联到的对象，需要在safepoint位置暂停所有执行线程。</p><p>并发标记 ：进行GC Roots Tracing，遍历完从root可达的所有对象。该阶段与工作线程并发执行。</p><p>重新标记 ：修正并发标记期间因用户程序继续运作而导致标记产生表动的那一部分对象的标记记录。需要在safepoint位置暂停所有执行线程。</p><p>并发清理 ：内存回收阶段，将死亡的内存对象占用的空间增加到一个空闲列表(free list),供以后的分配使用。</p><p>重置 ：清理数据结构,为下一个并发收集做准备。</p><p><strong>7）G1回收器</strong></p><p>以前的回收器，都需要完全回收整个年轻代和老年代，随着技术的发展，垃圾越来越大，处理垃圾需要很大延迟。G1是 JDK 1.7中正式投入使用的用于取代CMS的压缩回收器。<strong>基于标记整理</strong>的垃圾回收器。年轻代分为Eden和Survivor两个区，老年代分为Old和Humongous（大对象，占用的空间超过了分区容量50%）两个区。</p><ol><li><p>G1首先将堆分为大小相等的 Region，避免全区域的垃圾回收。</p><ul><li><p><code>-XX:G1HeapRegionSize=N</code> 默认2048个区域大小</p></li><li><p>G1的分区示例如下图所示：（新生代、幸存区、老年代和大对象(humongous)</p></li></ul></li></ol><p><img src="/2021/03/15/java/G1%E5%9B%9E%E6%94%B6%E5%99%A8.png" alt="句柄"></p><p>G1把堆内存分为大小相等的内存分段，默认情况下会把内存分为2048个内存分段。比如32G堆内存，2048个内存分段每段的大小为16M。这相当于把内存化整为零。内存分段是物理概念，代表实际的物理内存空间。每个内存分段都可以被标记为Eden区，Survivor区，Old区，或者Humongous区。</p><p>这样划分有问题，不同的区域之间存在互相引用，造成跨代引用的问题。如何去标记另外一个区域引用了当前这个对象，引入了卡表和RS。每个区域内每个卡表占512byte，当此卡表对应的对象发生改变时，标记为dirty。每个对象的RS（RememberSet)记录谁引用了此对象。如下图所示：卡表引用Region1引用Region2区域的对象，Region2区域的RS记录Region1引用了它本身。</p><p><img src="/2021/03/15/java/G1RS.png" alt="句柄"></p><p><img src="/2021/03/15/java/G1.PNG"></p><p>如何去实现这个RS记录的过程？G1中有<code>Write Barrier</code>机制，这个机制由编译器动态生成一小段代码。</p><p><strong>Write Barrier机制</strong></p><p>每当执行<code>object.field = &lt;reference&gt;(putfield)</code>赋值操作时，JVM会注入一小段代码。</p><p>当赋值操作需要让RS更新时，把即将改变的卡表比如上图中的Region 1 卡表新指向了 Region 2，需要将Region 1中的这个卡表标记为 dirty。然后将此card放入队列(Dirty Card Queue)，这个队列有白、绿、黄、红四个颜色。根据更新的频率G1自动设定等级，比如更新的非常剧烈，红色。</p><ol><li><p>白色</p><p>天下太平，无事发生</p></li><li><p>绿色 (-XX:G1ConcRefinementGreenZone = N)</p><p>Refinement线程开始被激活，开始更新RS</p></li><li><p>黄色 （-XX：G1ConcRefinementYellowZone=N)</p><p>全部Refinement线程激活</p></li><li><p>红色 (-XX:G1ConcRefinementRedZone=N)</p><p>应用线程也参与排空队列的工作。（把应用线程拖慢）</p></li></ol><ul><li>无需回收整个堆，而是选择一个<code>Collection Set(CS)</code></li></ul><p>当一个地址空间被引用时，这个地址空间对应的数组索引的值被标记为”0″，即标记为脏被引用，此外RSet也将这个数组下标记录下来。一般情况下，这个RSet其实是一个Hash Table，Key是别的Region的起始地址，Value是一个集合，里面的元素是Card Table的Index。</p><p>Mixed GC （老年代和年轻代一起回收） 不一定立即发生，选择若干个Region进行，默认1/8的Old Region（选择垃圾最多的老年代优先进行）。STW,Parallel,Copying回收，它和年轻代是完全相同的做法。</p><p>总结：</p><p>G1垃圾回收过程主要包括三个：</p><ul><li>年轻代回收（young gc）过程，这个过程是<code>stop the world</code>方法，需要暂停应用程序，通过上述的卡表和RS更新引用对象。</li><li>老年代并发标记（concurrent marking）过程，这个是并发标记的过程，使用三色标记法标记（白色，黑色，灰色）。</li><li>混合回收过程（mixed gc）。</li></ul><p>1）Young GC</p><ul><li>阶段1：根扫描<br>静态和本地对象被扫描</li><li>阶段2：更新RS<br>处理dirty card队列更新RS</li><li>阶段3：处理RS<br>检测从年轻代指向年老代的对象</li><li>阶段4：对象拷贝<br>拷贝存活的对象到survivor/old区域</li><li>阶段5：处理引用队列<br>软引用，弱引用，虚引用处理</li></ul><p>2）并发标记+垃圾回收</p><ul><li>初始标记（initial mark，STW）<br>在此阶段，G1 GC 对根进行标记。该阶段与常规的 (STW) 年轻代垃圾回收密切相关。</li><li>根区域扫描（root region scan）<br>G1 GC 在初始标记的存活区扫描对老年代的引用，并标记被引用的对象。该阶段与应用程序（非 STW）同时运行，并且只有完成该阶段后，才能开始下一次 STW 年轻代垃圾回收。</li><li>并发标记（Concurrent Marking）<br>G1 GC 在整个堆中查找可访问的（存活的）对象。该阶段与应用程序同时运行，可以被 STW 年轻代垃圾回收中断</li><li>最终标记（Remark，STW）<br>该阶段是 STW 回收，帮助完成标记周期。G1 GC 清空 SATB 缓冲区，跟踪未被访问的存活对象，并执行引用处理。</li><li>清除垃圾（Cleanup，STW）<br>在这个最后阶段，G1 GC 执行统计和 RSet 净化的 STW 操作。在统计期间，G1 GC 会识别完全空闲的区域和可供进行混合垃圾回收的区域。清理阶段在将空白区域重置并返回到空闲列表时为部分并发。</li></ul><p>了解并发标记的<strong>三色标记算法</strong>。</p><p><img src="/2021/03/15/java/G1%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0%E6%B3%95.PNG"></p><p>收集器总结：</p><table><thead><tr><th align="center">收集器</th><th align="center">执行方式</th><th align="center">分代</th><th align="center">算法</th><th align="center">目标</th><th align="center">场景</th></tr></thead><tbody><tr><td align="center">Serial</td><td align="center">串行</td><td align="center">新生代</td><td align="center">复制</td><td align="center">响应速度优先</td><td align="center">单CPU下的客户端模式</td></tr><tr><td align="center">Serial Old</td><td align="center">串行</td><td align="center">老年代</td><td align="center">标记-整理</td><td align="center">响应速度优先</td><td align="center">单CPU下的客户端和CMS后备方案</td></tr><tr><td align="center">ParNew</td><td align="center">并行</td><td align="center">新生代</td><td align="center">复制</td><td align="center">响应速度优先</td><td align="center">多CPU在服务器模式下与CMS配合</td></tr><tr><td align="center">Parallel Scavenge</td><td align="center">并行</td><td align="center">新生代</td><td align="center">复制</td><td align="center">吞吐量优先</td><td align="center">后台计算不需要太多交互任务</td></tr><tr><td align="center">Parallel Old</td><td align="center">并行</td><td align="center">老年代</td><td align="center">标记-整理</td><td align="center">吞吐量优先</td><td align="center">后台计算不需要太多交互任务</td></tr><tr><td align="center">CMS</td><td align="center">并发</td><td align="center">老年代</td><td align="center">标记-清除</td><td align="center">响应速度优先</td><td align="center">集中在网站或B/S系统服务</td></tr><tr><td align="center">G1</td><td align="center">并发</td><td align="center">两者都有</td><td align="center">标记整理+复制</td><td align="center">响应速度优先</td><td align="center">面向服务端应用，替换CMS</td></tr></tbody></table><ul><li>4.方法区回收条件：</li></ul><p>只有同时满足以下三个条件才会被回收！</p><p>1）所有实例被回收</p><p>2）加载该类的ClassLoader被回收</p><p>3）Class对象无法通过任何途径访问(包括反射)</p><h2 id="2-Java基础"><a href="#2-Java基础" class="headerlink" title="2. Java基础"></a>2. Java基础</h2><h3 id="lt-static-关键字"><a href="#lt-static-关键字" class="headerlink" title="<static 关键字"></a><font color="green">&lt;static 关键字</font></h3><blockquote><p>static 关键字</p></blockquote><p>java中不存在“全局变量”概念，可以用static表示“伪全局”概念。</p><p>被static修饰就是静态变量，所以JVM肯定将其放在单独的常量池里。JVM可以方便访问它们。</p><p>要点：</p><ol><li><p>被 static 修饰的成员变量和成员方法是独立于该类的。</p><p>静态变量和静态方法是随着类加载时被完成初始化的（类加载时已经存在），它在内存中仅有一个，且 JVM 也只会为它分配一次内存，同时类所有的实例都共享静态变量，可以直接通过类名来访问它。</p><p>可如下直接使用：</p></li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">ClassName</span><span class="token punctuation">.</span>propertyName<span class="token class-name">ClassName</span><span class="token punctuation">.</span><span class="token function">methodName</span><span class="token punctuation">(</span>……<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ol start="2"><li>它只能调用 static 变量和方法。</li><li>不能以任何形式引用 this、super。</li><li>static 变量在定义时必须要进行初始化，且初始化时间要早于非静态变量。</li></ol><p>静态方法里面为什么不能用this指针，从底层上来说，操作数栈中的没有this指针，而普通方法index=0永远是this。</p><h3 id="lt-final关键字"><a href="#lt-final关键字" class="headerlink" title="<final关键字"></a><font color="green">&lt;final关键字</font></h3><p>某些数据不可更改。final修饰的叫常量。“常量”的使用有以下两个地方：</p><ol><li>编译期常量，永远不可改变。</li><li>运行期初始化时，不可改变。根据对象的不同而表现不同，但同时又不希望它被改变，这个时候我们就可以使用运行期常量。</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">String</span> final_01 <span class="token operator">=</span> <span class="token string">"demo"</span><span class="token punctuation">;</span><span class="token comment">//编译期常量，必须要进行初始化，且不可更改</span><span class="token keyword">public</span> <span class="token keyword">class</span> test<span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token class-name">String</span> str<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">Random</span> random <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">int</span> final_03 <span class="token operator">=</span> random<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//使用随机数来进行初始化,运行期初始化，每次new新的类都会改变内容（random）。</span>    <span class="token function">test</span><span class="token punctuation">(</span><span class="token class-name">String</span> s<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>str<span class="token operator">=</span>s<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意点：</p><ol><li>final修饰的方法不能被修改重写，可以被继承。</li><li>final修饰的类不能修改不能继承，最终类。</li><li>匿名内部类中参数必须为final。</li></ol><blockquote><h3 id="java-compator"><a href="#java-compator" class="headerlink" title="java compator"></a><font color="green">java compator</font></h3></blockquote><ul><li>保持这个顺序就返回-1 (&gt; 还是 &lt;)</li><li>交换顺序就返回1</li><li>什么都不做就返回0；所以 升序的话 如果1&lt;2,返回-1,保持顺序[1,2],如果3&gt;2,返回-1,交换顺序[2,3]</li></ul><pre class="line-numbers language-none"><code class="language-none">if (a &gt; b) return -1; 保持a&gt; b的顺序if (a &gt; b) return 1; 交换ab<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="lt-java异常"><a href="#lt-java异常" class="headerlink" title="<java异常"></a><font color="green">&lt;java异常</font></h3><ol><li>异常的体系结构</li></ol><p>什么是异常？</p><p>异常指的就是程序的不正常，简单理解就是程序所发生的错误。</p><ul><li>分类</li></ul><p>a 编译时异常： 编译期间，编译器检测到某段代码可能会发生某些问题，需要程序员提前给代码做出错误的解决方案，否则编译无法通过。</p><p>b 运行时异常 编译正常，运行时出现了错误。</p><ul><li>体系结构</li></ul><p>a throwable</p><p>​    Error:严重错误</p><p>​    Exception:</p><p>​        RuntimeException</p><p>​        IRuntimeException</p><ul><li><p>异常出现的原理</p><p>java对异常的默认处理方式是抛出问题给上一级，如果出现了问题，java会根据问题所描述的异常类创建一个对象，底层通过throw关键字将该对象抛出给上一级。（mehtod -&gt; main -&gt; jvm -&gt; 将异常位置和错误原因打印）</p></li><li><p>异常的处理方式</p><ul><li><p>问题可以自己处理的</p><p>try catch处理方式 (后面的代码还可以继续执行)</p></li><li><p>问题处理不掉的</p><p>throw处理方式。 如果是RuntimeException异常，则方法上面无需throws声明。</p></li></ul></li></ul><p>throws 和 throw throws是仅仅对方法进行声明，告知调用者此方法存在异常。</p><p>throw是抛出。</p><ul><li><p>Spring框架的事务默认是RuntimeException才进行回滚</p><ul><li>解决方案 </li></ul><p>修改Transactional注解中的rollbackFor属性可以指定为exception异常回滚。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Transactional</span><span class="token punctuation">(</span>rollbackFor<span class="token operator">=</span><span class="token punctuation">{</span><span class="token class-name">Exception</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><p>自己定义异常 （规范的异常类名，找一个类继承exception）。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">MyPersonAgeException</span> <span class="token keyword">extends</span> <span class="token class-name">RuntimeExceptoin</span><span class="token punctuation">(</span>或 <span class="token class-name">Exception</span><span class="token punctuation">)</span>        记得加入字符串的构造参数<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="lt-JAVA-集合"><a href="#lt-JAVA-集合" class="headerlink" title="<JAVA 集合"></a><font color="green">&lt;JAVA 集合</font></h3><p><img src="/2021/03/15/java/java%E9%9B%86%E5%90%88%E7%B1%BB.png" alt="句柄"></p><ol><li><strong>Collection</strong></li></ol><p>最基本的集合接口，它不提供直接的实现，JAVA SDK提供的类都是继承自Collection的<strong>子接口</strong>。所有实现Collection的接口类必须实现两类构造函数</p><p>a) 无参构造函数。创建空的Collection。</p><p>b) 有参构造函数，用于创建新的Collection。</p><p>解决ArrayLlist的线程不安全(<code>concurrentModificationException</code>)。</p><ol><li>换成<code>vector</code>。</li><li>换成`Collections.synchronizeList(new ArrayList());</li><li>new copyOnWriteArrayList();写时赋值。</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token number">1.L</span>ista<span class="token punctuation">)</span> <span class="token class-name">ArrayList</span> 初始容量<span class="token number">10</span>。基于数组实现。每次扩容<span class="token number">1.5</span>倍。b<span class="token punctuation">)</span> <span class="token class-name">LinkedList</span>基于双向链表实现，近开头或结尾（靠近索引）遍历链表。c<span class="token punctuation">)</span> <span class="token class-name">Vector</span>与<span class="token class-name">ArrayList</span>一样，不同在于它是线程安全。d<span class="token punctuation">)</span> <span class="token class-name">Stack</span>继承自<span class="token class-name">Vector</span>，后进先出的栈。提供push pop peek empty search。<span class="token number">2.</span>Set与list区别是不包含重复元素。a）<span class="token class-name">EnumSet</span>枚举专用<span class="token class-name">Set</span>，所有元素都是枚举类型。b）<span class="token class-name">HashSet</span>查询速度最快的集合，内部以<span class="token class-name">Hashcode</span>实现，顺序也以哈希码排序。c）<span class="token class-name">TreeSet</span>排序状态的<span class="token class-name">Set</span>，以<span class="token class-name">TreeMap</span>实现，以自然元素顺序或用户自定义`<span class="token class-name">Comparator</span>`排序。<span class="token number">3.</span>Queue（<span class="token number">1</span>）不阻塞的： <span class="token class-name">PriorityQueue</span> 和 <span class="token class-name">ConcurrentLinkedQueue</span>　　<span class="token class-name">PriorityQueue</span> 和 <span class="token class-name">ConcurrentLinkedQueue</span> 类在 <span class="token class-name">Collection</span> <span class="token class-name">Framework</span> 中加入两个具体集合实现。 　　<span class="token class-name">PriorityQueue</span> 类实质上维护了一个有序列表。加入到 <span class="token class-name">Queue</span> 中的元素根据它们的天然排序（通过其 <span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span>Comparable</span> 实现）或者根据传递给构造函数的 <span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span>Comparator</span> 实现来定位。　　<span class="token class-name">ConcurrentLinkedQueue</span> 是基于链接节点的、线程安全的队列。并发访问不需要同步。因为它在队列的尾部添加元素并从头部删除它们，所以只要不需要知道队列的大 小，<span class="token class-name">ConcurrentLinkedQueue</span> 对公共集合的共享访问就可以工作得很好。收集关于队列大小的信息会很慢，需要遍历队列。（<span class="token number">2</span>）阻塞的：　　五个阻塞队列类。它实质上就是一种带有一点扭曲的 FIFO 数据结构。不是立即从队列中添加或者删除元素，线程执行操作阻塞，直到有空间或者元素可用。五个队列所提供的各有不同：　　 <span class="token class-name">ArrayBlockingQueue</span> ：一个由数组支持的有界队列。　　 <span class="token class-name">LinkedBlockingQueue</span> ：一个由链接节点支持的可选有界队列。　　 <span class="token class-name">PriorityBlockingQueue</span> ：一个由优先级堆支持的无界优先级队列。　　 <span class="token class-name">DelayQueue</span> ：一个由优先级堆支持的、基于时间的调度队列。　　 <span class="token class-name">SynchronousQueue</span> ：一个利用 <span class="token class-name">BlockingQueue</span> 接口的简单聚集（rendezvous）机制。      <span class="token number">3.1</span> <span class="token class-name">ArrayDeque</span>    默认<span class="token number">16</span>，最小<span class="token number">8</span>。 object<span class="token punctuation">[</span><span class="token punctuation">]</span>数组存储。    栈操作：push pop peek 队列：offer poll peek    一般操作：add<span class="token comment">//尾 </span>    remove <span class="token comment">//首</span>    <span class="token keyword">public</span> <span class="token class-name">E</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">removeFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/2021/03/15/java/%E9%98%9F%E5%88%97.png" alt="句柄"></p><ol start="2"><li><strong>Map</strong></li></ol><p>与List和set不同，由一对键值对组成的集合，key到value的映射。</p><p>a) HashMap</p><p><strong>链表+数组</strong>.内部定义hash表数组<code>Entry[] table</code>，元素通过哈希函数的到哈希地址转为数组存放索引，当有冲突同一个索引处保存链表。</p><p><img src="/2021/03/15/java/%E5%93%88%E5%B8%8C%E8%A1%A8%E7%BB%93%E6%9E%84.png" alt="句柄"></p><p><strong>初始大小16</strong>，容量必须为$2^{n}$（<code>h &amp; (length-1)</code>这条规律成立前提长度必须是2的n次方）。JDK1.8 链表升级为<strong>红黑树</strong>结构。当本索引冲突<strong>大于8</strong>链表就转为红黑树，当冲突值小于6再转为普通链表。</p><p>高位右移动是为了扰动，防止哈希冲突</p><p><img src="/2021/03/15/java/%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81%E9%AB%98%E4%BD%8D%E6%89%B0%E5%8A%A8.png" alt="句柄"></p><p>在对数组长度进行按位与运算后得到的结果相同，就发生了冲突。</p><p><code>h &gt;&gt;&gt; 16</code>过扰动计算之后，最终得到的index的值不一样了.</p><p>更多细节参考其他博客，写的比较详细，记住常问的就行。<a href="https://blog.csdn.net/xu_dongdong/article/details/80251936">https://blog.csdn.net/xu_dongdong/article/details/80251936</a> <a href="https://blog.csdn.net/woshimaxiao1/article/details/83661464">https://blog.csdn.net/woshimaxiao1/article/details/83661464</a></p><p>b) HashTable</p><ul><li><p><strong>线程安全</strong>，<code>(hash &amp; 0x7FFFFFFF) % tab.length</code>它是通过这句话直接对hash地址取模，不是像HashMap按位与。0x7FFFFFFF做一次按位与操作，主要是为了保证得到的index的第一位为0，也就是为了得到一个正数。因为有符号数第一位0代表正数，1代表负数。</p></li><li><p><strong>初始大小为11</strong>，之后每次扩充为<strong>原来的2n+1</strong>。HashTable的链表数组的默认大小是一个素数、奇数。之后的每次扩充结果也都是奇数。</p></li><li><p>当哈希表的大小为素数时，简单的取模哈希的结果会更加<strong>均匀</strong>。</p></li><li><p>和HashMap<strong>区别</strong></p></li></ul><p>1、继承的父类不同</p><p>   Hashtable继承自Dictionary类，而HashMap继承自AbstractMap类。但二者都实现了Map接口。</p><p>2、线程安全性不同</p><p> 如果多个线程同时访问一个哈希映射，而其中至少一个线程从结构上修改了该映射，则它必须保持外部同步。Hashtable 中的方法是Synchronize的，而HashMap中的方法在缺省情况下是非Synchronize的。在多线程并发的环境下，可以直接使用Hashtable，不需要自己为它的方法实现同步，但使用HashMap时就必须要自己增加同步处理。</p><p>3、只有HashMap可以让你将空值作为一个表的条目的key或value</p><p>c) ConcurrentHashMap</p><ul><li>ConcurrentHashMap的hash实现和HashMap一样，但是<strong>用了不同的哈希算法</strong>（Wang/Jenkins 哈希算法）。</li><li><strong>线程安全</strong> <strong>“分段锁”的概念</strong>，具体可以理解为把一个大的Map拆分成N个小的HashTable，根据key.hashCode()来决定把key放到哪个HashTable中。</li></ul><p>ConcurrentHashMap中，就是把Map分成了N个Segment，put和get的时候，都是现根据key.hashCode()算出放到哪个Segment中。</p><ul><li>通过把整个Map分为N个Segment（类似HashTable），可以提供相同的线程安全，<strong>但是效率提升N倍，默认提升16倍</strong>。</li></ul><p>ConcurrentHashMap原理可参考<a href="https://blog.csdn.net/xuefeng0707/article/details/40834595">https://blog.csdn.net/xuefeng0707/article/details/40834595</a></p><h3 id="gt-hashset-添加元素怎么判断对象是否重复的？"><a href="#gt-hashset-添加元素怎么判断对象是否重复的？" class="headerlink" title="> hashset 添加元素怎么判断对象是否重复的？"></a><font color="green">&gt; hashset 添加元素怎么判断对象是否重复的？</font></h3><p>1.第一，任何类都继承了Object类的hashcode（）方法，如果未重写hashcode，hashset会使用默认hashcode转化对象属性字段为散列码。<br>2.第二，当得到散列码确定插入的位置后，接下来hashset会调用 要添加对象的equals()方法 与已经在该位置上的所有对象进行比较，如果有一个为true，则不插入，如果为false，则插入。<br>注意，是调用的插入对象的equals方法，不是已经在hashset中的对象。</p><h3 id="gt-迭代器Iterator"><a href="#gt-迭代器Iterator" class="headerlink" title=">迭代器Iterator"></a>&gt;<font color="green">迭代器Iterator</font></h3><p>迭代器是一种模式，可以使得序列类型的结构数据的遍历行为与被遍历的对象分离。无需关心对象底层的实现，只要拿到这个对象，就可以使用迭代器遍历这个对象的内部。</p><ul><li>Iterable 实现这个接口的集合对象支持迭代。实现Iterable后可以配合foreach使用。</li><li>Iterator 迭代器，提供迭代机制的对象。</li></ul><p>Iterator三个方法经常使用<code>hasnext()</code> <code>next()</code> <code>remove()</code>。其中<code>remove()</code>的使用需要先调用<code>next()</code>。</p><p>迭代出的对象也是引用的拷贝，结果还是引用。可以根据迭代出的元素直接修改对象。</p><p>Iterator的remove方法可以保证不跑出ModificationException异常即<code>Fail-fast</code>机制。</p><ul><li>for 和 Iterator的区别</li></ul><ol><li>ArrayList对随机访问快速，而for循环中的<code>get()</code>方法采用的是随机访问的方法，因此在ArrayList里，for循环较快。</li><li>LinkedList顺序访问较快，Iterator中的<code>next()</code>方法使用顺序访问，因此在LinkedList里，使用iterator更快。</li><li>for循环适合快速指定元素拿取数据。Iterator适合链式结构。</li></ol><h3 id="lt-有没有goto语句"><a href="#lt-有没有goto语句" class="headerlink" title="<有没有goto语句"></a><font color="green">&lt;有没有<code>goto</code>语句</font></h3><p>有，也有<code>const</code>。JAVA只保留但基本不用了。</p><blockquote><p>一个<code>.class</code>文件可不可以有多个类</p></blockquote><p>可以有多个，但是public只有一个。两个以上public就不知道加载哪个类，会报错。</p><h3 id="lt-String-常量池"><a href="#lt-String-常量池" class="headerlink" title="< String 常量池"></a><font color="green">&lt; String 常量池</font></h3><p>字符串常量池底层是用<strong>HashTable</strong>实现的。</p><ol><li>创建对象的两种方式。</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">String</span> s1 <span class="token operator">=</span> <span class="token string">"hello"</span><span class="token punctuation">;</span>     <span class="token class-name">String</span> s2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s1<span class="token operator">==</span>s2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//false</span><span class="token comment">//第一种方式是在常量池中拿对象，第二种方式是直接在堆内存空间创建一个新的对象。 </span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ol start="2"><li>JDK版本中(1.7后), 字符串常量池被实现在Java堆内存中。</li></ol><pre class="line-numbers language-none"><code class="language-none">String str1 = "abc"; String str2 = "abc"; String str3 = "abc"; String str4 = new String("abc");String str5 = new String("abc");System.out.println(str4==str5);//false<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/2021/03/15/java/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%86%85%E5%AD%98.png" alt="句柄"></p><ol start="3"><li><p><strong>“双引号””声明字符串的方式</strong>, </p><p>JVM首先会去<strong>字符串池</strong>中查找是否存在”abc”这个对象：</p></li></ol><ul><li>不存在，在字符串池中创建”abc”这个对象，将”abc”这个对象的引用地址返回给字符串常量s1。</li><li>如果存在，直接将池中”abc”这个对象的地址返回，赋给字符串常量。</li></ul><ol start="4"><li><p><strong>new字符串</strong></p><p>JVM首先在字符串池中查找有没有”abc”这个字符串对象：</p></li></ol><ul><li>存在，<strong>直接在堆</strong>中创建一个”abc”字符串对象，然后将堆中的”abc”对象的地址返回赋给引用str4。</li><li>不存在，<strong>字符串池</strong>中创建一个”abc”字符串对象，然后再在<strong>堆</strong>中创建一个”abc”字符串对象，将堆中”abc”字符串对象的地址返回赋给s3引用。</li></ul><ol start="5"><li><strong>intern()</strong> </li></ol><p>调用 intern方法时，查字符串池中：</p><ul><li><p>与此对象字符串<strong>内容相同</strong>，如果池已经包含一个等于此String对象的字符串（用**equals(object)**方法确定），则返回池中的字符串。</p></li><li><p>不相同，将此String对象添加到池中，并返回此String对象在常量池中的引用。 对于任意两个字符串s和t，所有字面值字符串和字符串赋值常量表达式都使用 intern()进行操作。</p></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">String</span> str1 <span class="token operator">=</span> <span class="token string">"abc"</span><span class="token punctuation">;</span> <span class="token class-name">String</span> str2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token string">"ab"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">apend</span><span class="token punctuation">(</span><span class="token string">"c"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">String</span> str3 <span class="token operator">=</span> str2<span class="token punctuation">.</span><span class="token function">intern</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>str1<span class="token operator">==</span>str2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//false</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>str1<span class="token operator">==</span>str3<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//true</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>例题：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">String</span> s1 <span class="token operator">=</span> <span class="token string">"a"</span><span class="token punctuation">;</span><span class="token class-name">String</span> s2 <span class="token operator">=</span> s1 <span class="token operator">+</span> <span class="token string">"b"</span><span class="token punctuation">;</span><span class="token class-name">String</span> s3 <span class="token operator">=</span> <span class="token string">"a"</span> <span class="token operator">+</span> <span class="token string">"b"</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s2 <span class="token operator">==</span> <span class="token string">"ab"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s3 <span class="token operator">==</span> <span class="token string">"ab"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>第一条语句打印的结果为false，第二条语句打印的结果为true，这说明javac编译可以对字符串常量直接相加的表达式进行优化，不必要等到运行期再去进行加法运算处理，而是在编译时去掉其中的加号，直接将其编译成一个这些常量相连的结果。由于s2只能在运行期间才能确定，所以s2指向的不是常量池中的“ab”。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/** * 编译期确定 * 对于final修饰的变量，它在编译时被解析为常量值的一个本地拷贝存储到自己的常量池中或嵌入到它的字节码流中。 * 所以此时的"a" + s1和"a" + "b"效果是一样的。故结果为true。 */</span><span class="token class-name">String</span> s0 <span class="token operator">=</span> <span class="token string">"ab"</span><span class="token punctuation">;</span> <span class="token keyword">final</span> <span class="token class-name">String</span> s1 <span class="token operator">=</span> <span class="token string">"b"</span><span class="token punctuation">;</span> <span class="token class-name">String</span> s2 <span class="token operator">=</span> <span class="token string">"a"</span> <span class="token operator">+</span> s1<span class="token punctuation">;</span>  <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">(</span>s0 <span class="token operator">==</span> s2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//result = true</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>题目中的第一行代码被编译器在编译时优化后，相当于直接定义了一个”abcd”的字符串，所以，上面的代码应该只创建了一个String对象。写如下两行代码，</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">String</span> s <span class="token operator">=</span><span class="token string">"a"</span> <span class="token operator">+</span> <span class="token string">"b"</span> <span class="token operator">+</span><span class="token string">"c"</span> <span class="token operator">+</span> <span class="token string">"d"</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s<span class="token operator">==</span> <span class="token string">"abcd"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>最终打印的结果应该为true。</p><blockquote><p>java switch 作用于哪些类型</p></blockquote><p>char byte short int Charator Byte Short Integer String Enum枚举类型。</p><blockquote><p>short a=a+1; short a+=1;是否报错？</p></blockquote><p>short a =a+1。int转short强制类型编译报错。</p><p>+=是java内置符号，不会报错。</p><h3 id="lt-java-内存模型"><a href="#lt-java-内存模型" class="headerlink" title="< java 内存模型"></a><font color="green">&lt; java 内存模型</font></h3><p><img src="/2021/03/15/java/JAVA%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.png" alt="句柄"></p><p>Java内存模型的主要目标是定义程序中<strong>变量的访问规则</strong>。即在虚拟机中将变量存储到主内存或者将变量从主内存取出这样的底层细节。需要注意的是这里的<strong>变量跟我们写java程序中的变量不是完全等同的</strong>。这里的变量是指实例字段，静态字段，构成数组对象的元素，但是不包括局部变量和方法参数(因为这是线程私有的)。这里可以简单的认为主内存是java虚拟机内存区域中的堆，局部变量和方法参数是在虚拟机栈中定义的。但是在堆中的变量如果在多线程中都使用，就涉及到了堆和不同虚拟机栈中变量的值的一致性问题了。</p><ul><li><p>主内存：java虚拟机规定所有的变量(不是程序中的变量)都必须在主内存中产生，可以<strong>简单</strong>认为是堆区（仅仅做解释，实际不是）。不是物理内存，这里指的是虚拟机的主内存，它是虚拟机内存中的一部分。</p></li><li><p>工作内存：java虚拟机中每个线程都有自己的工作内存，该内存是线程私有的为了方便理解，可以认为是虚拟机栈。线程的工作内存保存了线程需要的变量在主内存中的副本。<strong>线程对主内存变量的修改必须在线程的工作内存中进行，不能直接读写主内存中的变量</strong>。不同的线程之间也不能相互访问对方的工作内存。如果线程之间需要传递变量的值，必须通过主内存来作为中介进行传递。</p></li></ul><p>java内存中线程的工作内存和主内存的交互是由java虚拟机定义了如下的8种操作来完成的。</p><ul><li><p><strong>lock(锁定)</strong>:作用于主内存的变量，一个变量在同一时间只能一个线程锁定，该操作表示这条线成独占这个变量</p></li><li><p><strong>unlock(解锁)</strong>:作用于主内存的变量，表示这个变量的状态由处于锁定状态被释放，这样其他线程才能对该变量进行锁定</p></li><li><p><strong>read(读取)</strong>:作用于主内存变量，表示把一个主内存变量的值传输到线程的工作内存，以便随后的load操作使用</p></li><li><p><strong>load(载入)</strong>:作用于线程的工作内存的变量，表示把read操作从主内存中读取的变量的值放到工作内存的变量副本中(副本是相对于主内存的变量而言的)</p></li><li><p><strong>use(使用)</strong>:作用于线程的工作内存中的变量，表示把工作内存中的一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时就会执行该操作</p></li><li><p><strong>assign(赋值)</strong>:作用于线程的工作内存的变量，表示把执行引擎返回的结果赋值给工作内存中的变量，每当虚拟机遇到一个给变量赋值的字节码指令时就会执行该操作</p></li><li><p><strong>store(存储)</strong>:作用于线程的工作内存中的变量，把工作内存中的一个变量的值传递给主内存，以便随后的write操作使用</p></li><li><p><strong>write(写入)</strong>:作用于主内存的变量，把store操作从工作内存中得到的变量的值放入主内存的变量中</p></li></ul><p>执行这些操作需要遵循文中一开始记录的<strong>Happens-before</strong>原则。</p><h3 id="lt-引用类型"><a href="#lt-引用类型" class="headerlink" title="< 引用类型"></a><font color="green">&lt; 引用类型</font></h3><p>JAVA <strong>4种</strong>引用类型。</p><ol><li>强引用</li></ol><p>java默认的声明就是强引用。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Object</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//只要obj还指向Object对象，Object对象就不会被回收</span>obj <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>  <span class="token comment">//手动置null</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>只要强引用存在，垃圾回收就不会回收它。除非你手动置为空，或者对象的生存周期结束（局部对象，函数调用完毕）。</p><ol start="2"><li>软引用</li></ol><p>JAVA 1.2之后，用<code>java.lang.ref.SoftReference</code>表示软引用。</p><p>当内存不够用时，才会回收软引用对象。如果回收后内存还不够用，才会OOM（Out Of  Memory)。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> buff <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token number">1024</span> <span class="token operator">*</span> <span class="token number">1024</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token class-name">SoftReference</span><span class="token operator">&lt;</span><span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">&gt;</span> sr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SoftReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>buff<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>sr<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">!=</span><span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> rev <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> sr<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment">// 还没有被回收器回收，直接获取</span><span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>buff <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">new</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token number">1024</span> <span class="token operator">*</span> <span class="token number">1024</span><span class="token punctuation">]</span><span class="token punctuation">;</span>      <span class="token comment">// 由于内存吃紧，所以对软引用的对象回收了</span>sr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SoftReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>buff<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">// 重新构建</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果设置JVM内存只有<strong>2M</strong>，下面这个代码每次分配1M的内存，看看什么结果：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestOOM</span> <span class="token punctuation">{</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token function">testSoftReference</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">testSoftReference</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> buff <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token number">1024</span> <span class="token operator">*</span> <span class="token number">1024</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token class-name">SoftReference</span><span class="token operator">&lt;</span><span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">&gt;</span> sr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SoftReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>buff<span class="token punctuation">)</span><span class="token punctuation">;</span>list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>sr<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">gc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//主动通知垃圾回收</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> list<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token class-name">Object</span> obj <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">SoftReference</span><span class="token punctuation">)</span> list<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/2021/03/15/java/OOM%E6%B5%8B%E8%AF%95.png" alt="句柄"></p><p>调用了很多次，只有一个对象时存在的，其他都是<code>null</code>被回收了。</p><ol start="3"><li>弱引用</li></ol><p>比软引用还弱。<strong>无论内存是否足够，只要JVM开始进行垃圾回收，那些被弱引用关联的对象都要回收。</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">testWeakReference</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> buff <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token number">1024</span> <span class="token operator">*</span> <span class="token number">1024</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token class-name">WeakReference</span><span class="token operator">&lt;</span><span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">&gt;</span> sr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WeakReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>buff<span class="token punctuation">)</span><span class="token punctuation">;</span>list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>sr<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">gc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//主动通知垃圾回收</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> list<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token class-name">Object</span> obj <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">WeakReference</span><span class="token punctuation">)</span> list<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>还是限定内存2M，每次byte数组使用1M，让其内存不够用，看结果：</p><p><img src="/2021/03/15/java/%E5%BC%B1%E5%BC%95%E7%94%A8.png" alt="句柄"></p><p>所有对象都回收了。</p><ol start="4"><li>虚引用</li></ol><p><code>PhantomReference</code>表示虚引用，它是最弱的引用。<strong>对象仅有虚引用，和没有引用一样，随时可能被回收</strong>。<strong>必须要和<code>ReferenceQueue</code>引用队列一起使用。</strong></p><p>看它的<code>PhantomReference</code>类的源代码：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">PhantomReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">extends</span> <span class="token class-name">Reference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>    <span class="token comment">/**     * Returns this reference object's referent.  Because the referent of a     * phantom reference is always inaccessible, this method always returns     * &lt;code&gt;null&lt;/code&gt;.     *     * @return  &lt;code&gt;null&lt;/code&gt;     */</span>    <span class="token keyword">public</span> <span class="token class-name">T</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token class-name">PhantomReference</span><span class="token punctuation">(</span><span class="token class-name">T</span> referent<span class="token punctuation">,</span> <span class="token class-name">ReferenceQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> <span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> q<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">(</span>referent<span class="token punctuation">,</span> q<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>它的get永远返回<code>null</code>。无法通过虚引用引用对象。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Object</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">ReferenceQueue</span> refQueue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReferenceQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">PhantomReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> phantomReference <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PhantomReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span>refQueue<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这没法引用对象，有<strong>他妈的</strong>啥用呢？</p><p><strong>可以用来跟踪对象呗。</strong>它的作用在于跟踪垃圾回收过程，在对象被收集器回收时收到一个系统通知。 当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在垃圾回收后，将这个虚引用加入引用队列，在其关联的虚引用出队前，不会彻底销毁该对象。 所以可以通过检查引用队列中是否有相应的虚引用来判断对象是否已经被回收了。</p><p>与软引用和弱引用不同，显式使用虚引用可以阻止对象被清除，只有在程序中显式或者隐式移除这个虚引用时，这个已经执行过finalize方法的对象才会被清除。想要显式的移除虚引用的话，只需要将其从引用队列中取出然后扔掉（置为null）即可。</p><p>有个例子：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">PhantomReferenceTest</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> TEST_DATA <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">ReferenceQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">TestClass</span><span class="token punctuation">&gt;</span></span> QUEUE <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReferenceQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">TestClass</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TestClass</span><span class="token punctuation">(</span><span class="token string">"Test"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">PhantomReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">TestClass</span><span class="token punctuation">&gt;</span></span> phantomReference <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PhantomReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> QUEUE<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 该线程不断读取这个虚引用，并不断往列表里插入数据，以促使系统早点进行GC</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                TEST_DATA<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token number">1024</span> <span class="token operator">*</span> <span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">try</span> <span class="token punctuation">{</span>                    <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">interrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>phantomReference<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 这个线程不断读取引用队列，当弱引用指向的对象被回收时，该引用就会被加入到引用队列中</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token class-name">Reference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">TestClass</span><span class="token punctuation">&gt;</span></span> poll <span class="token operator">=</span> QUEUE<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>poll <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"--- 虚引用对象被jvm回收了 ---- "</span> <span class="token operator">+</span> poll<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"--- 回收对象 ---- "</span> <span class="token operator">+</span> poll<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        obj <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">TestClass</span> <span class="token punctuation">{</span>        <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token class-name">TestClass</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token string">"TestClass - "</span> <span class="token operator">+</span> name<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>程序输出：</p><p><img src="/2021/03/15/java/%E8%99%9A%E5%BC%95%E7%94%A8%E8%B7%9F%E8%B8%AA%E5%AF%B9%E8%B1%A1%E5%AD%98%E6%B4%BB%E7%8A%B6%E6%80%81.png" alt="句柄"></p><h3 id="lt-内存泄漏"><a href="#lt-内存泄漏" class="headerlink" title="< 内存泄漏"></a><font color="green">&lt; 内存泄漏</font></h3><p>JAVA GC回收本质上还是判断一个对象是否被引用的方式。如果，<strong>JVM误以为此对象还在引用中，无法回收，造成内存泄漏。</strong></p><p>8种常见情况：</p><p>1）<strong>static字段太多</strong></p><p>原因：静态字段拥有和整个应用程序一样的生命周期。<strong>想一想单例模式的static，对象如果太大就gg了</strong></p><p>解决办法：最大限度的减少静态变量的使用；单例模式时，依赖于延迟加载对象而不是立即加载方式。</p><p>2）<strong>未关闭资源</strong></p><p>原因：每次使用JAVA IO流等创建读取流时，JVM都会为这些资源分配内存。</p><p>解决办法：使用finally块关闭资源；关闭资源的代码，不应该有异常；jdk1.7后，可以使用try-with-resource块。</p><p>3）<strong>hashcode()和不正确的equals()</strong></p><p>原因：在HashMap和HashSet这种集合中，equal()和hashCode()来比较对象，如果重写不合理，将会成为潜在的内存泄露问题。</p><p>比如：当一个对象被存储进HashSet集合中，不能修改这个对象中的那些参与计算哈希值的字段了，否则，对象修改后的哈希值与最初存储进HashSet集合中时的哈希值就不同，始终让GC以为对象有引用，无法回收。</p><p>解决办法：用最佳的方式重写equals()和hashCode。</p><ol start="4"><li><strong>引用外部类的内部类</strong></li></ol><p>原因： <strong>非静态内部类</strong>的初始化，需要外部类实例才能使用；默认情况下，每个非静态内部类有对外部类的引用，引用了这个内部类，那么外部类对象超出范围后，它也不会被垃圾收集。</p><p>解决办法：如果内部类不需要访问包含的类成员，考虑转换为静态类。</p><p>5）<strong>finalize()方法造成的内存泄露</strong></p><p>原因：重写finalize()方法时，该类的对象不会立即被垃圾收集器收集，如果finalize()方法的代码有问题，那么会潜在的引发OOM；</p><p>解决办法：避免重写finalize()。</p><p>6）<strong>ThreadLocal</strong></p><p>使用ThreadLocal时，每个线程只要处于存活状态就可保留对ThreadLocal变量的调用。使用不当，就会引起内存泄露。</p><p>一旦线程不在存在，ThreadLocals就应该被垃圾收集，而现在线程的创建都是使用线程池，线程池有线程重用的功能，因此线程就不会被垃圾回收器回收。所以使用到ThreadLocals来保留线程池中线程的变量副本时，ThreadLocals没有显示的删除时，就会一直保留在内存中，不会被垃圾回收。</p><p>解决办法：不在使用ThreadLocal时，调用remove()方法，该方法删除了此变量的当前线程值。不要使用ThreadLocal.set(null)，它只是查找与当前线程关联的Map并将键值对设置为当前线程为null。</p><p>7）<strong>常量字符串</strong></p><p>原因：读取一个很大的String对象，并调用了intern(），它将放到字符串池中，只要应用程序运行，该字符串就会保留，这就会占用内存，可能造成OOM。</p><p>解决办法：增加PermGen的大小，-XX:MaxPermSize=512m（1.7前）；升级Java版本，JDK1.7后字符串池转移到了堆中。</p><h3 id="gt-栈溢出"><a href="#gt-栈溢出" class="headerlink" title="> 栈溢出"></a><font color="green">&gt; 栈溢出</font></h3><h3 id="gt-栈泄露"><a href="#gt-栈泄露" class="headerlink" title="> 栈泄露"></a><font color="green">&gt; 栈泄露</font></h3><p>B+树缺点</p><h3 id="lt-Fail-Fast机制"><a href="#lt-Fail-Fast机制" class="headerlink" title="< Fail-Fast机制"></a><font color="green">&lt; Fail-Fast机制</font></h3><p>HashMap 中有这种描述：</p><p>注意，迭代器的<strong>快速失败</strong>行为不能得到保证，一般来说，存在非同步的并发修改时，不可能作出任何坚决的保证。快速失败迭代器尽最大努力抛出 <code>ConcurrentModificationException</code>。因此，编写依赖于此异常的程序的做法是错误的，正确做法是：迭代器的快速失败行为应该仅用于检测程序错误。</p><p>“快速失败”也就是 fail-fast，它是 Java 集合的一种<strong>错误检测机制。</strong></p><p>当多个线程对集合进行结构上的改变的操作时，有可能会产生 fail-fast 机制。记住是有可能，而不是一定。</p><ul><li>产生原因</li></ul><p> fail-fast 产生的原因就在于程序在对 collection 进行迭代时，某个线程对该 collection 在结构上对其做了修改，这时迭代器就会抛出 <code>ConcurrentModificationException</code> 异常信息，从而产生 fail-fast。</p><p>你可以自己翻翻看<code>ArrayList</code>的源代码，发现有如下判断：</p><p><code>modCount != expectedModCount</code> ，就会抛出这个异常。</p><p>下面是<code>ArrayList</code>的迭代器示例代码：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">class</span> <span class="token class-name">Itr</span> <span class="token keyword">implements</span> <span class="token class-name">Iterator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> cursor<span class="token punctuation">;</span>            <span class="token keyword">int</span> lastRet <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> expectedModCount <span class="token operator">=</span> <span class="token class-name">ArrayList</span><span class="token punctuation">.</span><span class="token keyword">this</span><span class="token punctuation">.</span>modCount<span class="token punctuation">;</span><span class="token comment">//传进来时是外部的modCount，arraylist的实际大小</span>            <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>cursor <span class="token operator">!=</span> <span class="token class-name">ArrayList</span><span class="token punctuation">.</span><span class="token keyword">this</span><span class="token punctuation">.</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">public</span> <span class="token class-name">E</span> <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">checkForComodification</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">/** 省略此处代码 */</span>            <span class="token punctuation">}</span>            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>lastRet <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>                    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalStateException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">checkForComodification</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">/** 省略此处代码 */</span>            <span class="token punctuation">}</span>            <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">checkForComodification</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">ArrayList</span><span class="token punctuation">.</span><span class="token keyword">this</span><span class="token punctuation">.</span>modCount <span class="token operator">==</span> <span class="token keyword">this</span><span class="token punctuation">.</span>expectedModCount<span class="token punctuation">)</span>                    <span class="token keyword">return</span><span class="token punctuation">;</span>                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">ConcurrentModificationException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>int expectedModCount = ArrayList.this.modCount;</code>所以调用这个方法后它的值是不可能会修改的，所以会变的就是 <code>modCount</code>。<code>modCount</code> 是在 AbstractList 中定义的，为全局变量，记录集合的实际大小。</p><p><code>ArrayList</code> 中无论<code> add、remove、clear</code> 方法只要是涉及了改变<code>ArrayList</code>元素的个数的方法都会导致 <code>modCount </code>的改变。</p><p>两个线程（线程 A，线程 B），其中线程 A 负责遍历 list、线程B修改 list。线程 A 在遍历 list 过程的某个时候（此时 <code>expectedModCount = modCount=N</code>），线程启动，同时线程B增加一个元素，这是 modCount 的值发生改变（<code>modCount + 1 = N + 1</code>）。线程 A 继续遍历执行 next 方法时，通告 <code>checkForComodification</code> 方法发现 <code>expectedModCount = N </code>，而 <code>modCount = N + 1</code>，两者不等，这时就抛出<code>ConcurrentModificationException</code> 异常，从而产生 fail-fast 机制。</p><h3 id="lt-final关键字修饰一个变量"><a href="#lt-final关键字修饰一个变量" class="headerlink" title="< final关键字修饰一个变量"></a><font color="green">&lt; final关键字修饰一个变量</font></h3><p>final关键字修饰一个变量是引用不能变，还是引用的对象不能变？</p><p><strong>引用不能变，对象内容可以变。</strong></p><h3 id="lt-finally关键字"><a href="#lt-finally关键字" class="headerlink" title="<finally关键字"></a><font color="green">&lt;finally关键字</font></h3><p>final : 修饰类时，不能被继承。</p><p>​            修饰方法时，不能被重写。</p><p>​            修饰变量时，只能赋值一次。</p><p>finally:是try语句中的一个语句体，不能单独使用，用来释放资源。</p><p>finalize:是一个方法，当垃圾回收器确定不存在该对象的更多引用时，由对象的垃圾回收器调用此方法。</p><p>finally是在<code>return</code>语句之后执行。如果catch里面有return语句，此时会先执行return将返回值打包并创建一个返回路径等待，接着往下搜寻有没有finally语句，如果有则需先执行finally语句，再根据创建好的返回路径返回。</p><p><font color="red">匿名内部类参数必须是final的。这是因为实例变量是在堆中的，局部变量在栈中，Lambda表达式会在另一个线程中执行。如果在线程中要访问一个局部变量，可能线程执行时该局部变量被销毁了，而final类型的局部变量在Lamda表达式中其实是一个拷贝。</font></p><h3 id="lt-接口和抽象类"><a href="#lt-接口和抽象类" class="headerlink" title="< 接口和抽象类"></a><font color="green">&lt; 接口和抽象类</font></h3><p>接口是否可继承接口?抽象类是否可实现(implements)接口?抽象类是否可继承具体类(concreteclass)?抽象类中是否可以有静态的main方法？</p><p>接口可以继承接口。抽象类可以实现(implements)接口，抽象类可以继承具体类。抽象类中可以有静态的main方法。</p><p>备注：只要明白了接口和抽象类的本质和作用，这些问题都很好回答，你想想，如果你是java语言的设计者，你是否会提供这样的支持，如果不提供的话，有什么理由吗？如果你没有道理不提供，那答案就是肯定的了。</p><p>只要记住抽象类与普通类的唯一区别就是不能创建实例对象和允许有abstract方法。</p><p>抽象类和接口中都可以包含静态成员变量，抽象类中的静态成员变量的访问类型可以任意，但接口中定义的变量只能是<code>public static final</code>类型，并且默认即为<code>public static final</code>类型。</p><p><font color="red">接口强调特定功能的实现，而抽象类强调所属关系。</font></p><h3 id="lt-8种基本类型的包装类和常量池"><a href="#lt-8种基本类型的包装类和常量池" class="headerlink" title="< 8种基本类型的包装类和常量池"></a><font color="green">&lt; 8种基本类型的包装类和常量池</font></h3><ul><li>Java 基本类型的包装类除了Float和Double，即Byte,Short,Integer,Long,Character；这几种包装类默认创建了数值**[-128，127]<strong>的相应类型的</strong>缓存**数据，但是超出此范围仍然会去创建新的对象。</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Integer</span> i1 <span class="token operator">=</span> <span class="token number">33</span><span class="token punctuation">;</span><span class="token class-name">Integer</span> i2 <span class="token operator">=</span> <span class="token number">33</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>i1 <span class="token operator">==</span> i2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 输出true</span><span class="token class-name">Integer</span> i11 <span class="token operator">=</span> <span class="token number">333</span><span class="token punctuation">;</span><span class="token class-name">Integer</span> i22 <span class="token operator">=</span> <span class="token number">333</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>i11 <span class="token operator">==</span> i22<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 输出false 因为两个对象比较</span><span class="token class-name">Double</span> i3 <span class="token operator">=</span> <span class="token number">1.2</span><span class="token punctuation">;</span><span class="token class-name">Double</span> i4 <span class="token operator">=</span> <span class="token number">1.2</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>i3 <span class="token operator">==</span> i4<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 输出false</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Integer 源代码：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/***始终缓存-128到127（包括端点）范围内的值，其他值是创建的对象。*/</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Integer</span> <span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&gt;=</span> <span class="token class-name">IntegerCache</span><span class="token punctuation">.</span>low <span class="token operator">&amp;&amp;</span> i <span class="token operator">&lt;=</span> <span class="token class-name">IntegerCache</span><span class="token punctuation">.</span>high<span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token class-name">IntegerCache</span><span class="token punctuation">.</span>cache<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token operator">-</span><span class="token class-name">IntegerCache</span><span class="token punctuation">.</span>low<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Integer i1=40；Java 在编译的时候会直接将代码封装成Integer i1=Integer.valueOf(40);，从而使用常量池中的对象。</p><p>Integer i1 = new Integer(40);这种情况下会创建新的对象。</p><p><strong>JAVA8的ConcurrentHashMap为什么放弃了分段锁？</strong></p><p>原因：通过 JDK 的源码和官方文档看来， 他们认为的弃用分段锁的原因由以下几点： 1、加入多个分段锁浪费内存空间。 2、生产环境中， map 在放入时竞争同一个锁的概率非常小，分段锁反而会造成更新等操作的长时间等待。 3、为了提高 GC 的效率</p><p>既然弃用了分段锁， 那么一定由新的线程安全方案， 我们来看看源码是怎么解决线程安全的呢？CAS</p><p>首先通过 hash 找到对应链表过后， 查看是否是第一个object， 如果是， 直接用cas原则插入，无需加锁，然后如果不是链表第一个object， 则直接用链表第一个object加锁，这里加的锁是synchronized，虽然效率不如 ReentrantLock， 但节约了空间，这里会一直用第一个object为锁， 直到重新计算map大小， 比如扩容或者操作了第一个object为止。</p><p><a href="https://blog.csdn.net/ddxd0406/article/details/81389583">https://blog.csdn.net/ddxd0406/article/details/81389583</a></p><p><a href="https://www.cnblogs.com/nullzx/p/8647220.html">https://www.cnblogs.com/nullzx/p/8647220.html</a></p><h3 id="lt-静态代码块、构造代码块、构造函数执行顺序"><a href="#lt-静态代码块、构造代码块、构造函数执行顺序" class="headerlink" title="< 静态代码块、构造代码块、构造函数执行顺序"></a><font color="green">&lt; 静态代码块、构造代码块、构造函数执行顺序</font></h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">{</span>        <span class="token comment">/**         * 构造代码         */</span>        <span class="token punctuation">{</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"执行构造代码块..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment">/**         * 无参构造函数         */</span>        <span class="token keyword">public</span> <span class="token class-name">Test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"执行无参构造函数..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment">/**         * 有参构造函数         * @param id  id         */</span>        <span class="token keyword">public</span> <span class="token class-name">Test</span><span class="token punctuation">(</span><span class="token class-name">String</span> id<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"执行有参构造函数..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面定义了一个非常简单的类，该类包含无参构造函数、有参构造函数以及构造代码块，同时在上面也提过代码块是没有独立运行的能力，他必须要有一个可以承载的载体，那么编译器会如何来处理构造代码块呢？编译器会将代码块<strong>按照他们的顺序(假如有多个代码块)插入到所有的构造函数的最前端</strong>，这样就能保证不管调用哪个构造函数都会执行所有的构造代码块。</p><p>静态代码块，静态，其作用级别为类，构造代码块、构造函数，构造，其作用级别为对象。</p><p>1、静态代码块，它是随着类的加载而被执行，只要类被加载了就会执行，而且只会加载一次，主要用于给类进行初始化。</p><p>2、构造代码块，每创建一个对象时就会执行一次，且优先于构造函数，主要用于初始化不同对象共性的初始化内容和初始化实例环境。</p><p>3、构造函数，每创建一个对象时就会执行一次。同时构造函数是给特定对象进行初始化，而构造代码是给所有对象进行初始化，作用区域不同。</p><p>通过上面的分析，他们三者的执行顺序应该为：静态代码块 &gt; 构造代码块 &gt; 构造函数。</p><h3 id="java-反射"><a href="#java-反射" class="headerlink" title="java 反射"></a><font color="green">java 反射</font></h3><ul><li>概念</li></ul><p>程序在运行时可以获取某个类的所有信息。</p><ul><li>优点</li></ul><p>静态编译：在编译时确定类型，绑定对象，即通过。</p><p>动态编译：在运行时确定类型，绑定对象。动态编译最大限度发挥了java的灵活性，体现了多态的应用，降低类之间的耦合性。</p><p>（主要是体现了很大的灵活性）</p><ul><li>缺点</li></ul><p>反射是一种解释操作，我们告诉JVM某个类要做什么，这种方式慢于直接执行相同的操作。</p><ul><li>三种创建方式</li></ul><ol><li>Class.forName()</li><li>.class</li><li>.getClass();</li></ol><ul><li>和new的区别</li></ul><ol><li><p>new出来的对象无法访问其私有属性，但反射可以通过设置<code>setAccessible()</code>方法访问私有属性。</p></li><li><p>使用new创建实例必须知道类名，但是反射机制创建对象不知道类名也可。（比如说某个变量var已经定义好了 var.class 你就可以获得其类名是啥了,然后你再调用<code>newInstance()</code>）。</p></li></ol><h3 id="lt-switch语句能否作用在byte上，能否作用在long上，能否作用在String上"><a href="#lt-switch语句能否作用在byte上，能否作用在long上，能否作用在String上" class="headerlink" title="< switch语句能否作用在byte上，能否作用在long上，能否作用在String上?"></a><font color="green">&lt; switch语句能否作用在byte上，能否作用在long上，能否作用在String上?</font></h3><p>在switch（e）中，e只能是一个整数表达式或者枚举常量（更大字体），整数表达式可以是int基本类型或Integer包装类型，由于byte,short,char都可以隐含转换为int，所以，这些类型以及这些类型的包装类型也是可以的。显然，long和String类型都不符合switch的语法规定，并且不能被隐式转换成int类型，所以，它们不能作用于swtich语句中。</p><p><em>switch语句能否作用在String上说错了，Java1.7之后已经支持这种写法了！</em></p><h3 id="lt-a-hashCode-有什么用？与-a-equals-b-有什么关系？"><a href="#lt-a-hashCode-有什么用？与-a-equals-b-有什么关系？" class="headerlink" title="<&nbsp;**a.hashCode() 有什么用？与 a.equals(b) 有什么关系？**"></a><font color="green">&lt;&nbsp;**a.hashCode() 有什么用？与 a.equals(b) 有什么关系？**</font></h3><p>hashCode() 方法对应对象整型的 hash 值。它常用于基于 hash 的集合类，如 Hashtable、HashMap、LinkedHashMap等等。它与 equals() 方法关系特别紧密。根据 Java 规范，两个使用 equal() 方法来判断相等的对象，必须具有相同的 hash code。</p><h3 id="3-多线程"><a href="#3-多线程" class="headerlink" title=" 3. 多线程"></a><font color="green"> 3. 多线程</font></h3><h3 id="gt-volatile关键字"><a href="#gt-volatile关键字" class="headerlink" title="> volatile关键字"></a><font color="green">&gt; volatile关键字</font></h3><p>MESI缓存一致性协议。</p><p>多CPU从主存读取同一数据到各自缓存区中，该数据在lock前缀指令执行期间已经在处理器内存的缓存中被锁定，缓存被锁定期间其他CPU无法读写该数据，直到该缓存数据被修改同步回主存后，其他CPU通过总线嗅探机制感知数据变化及时失效自己缓存中的数据，在下一轮指令周期从主存重新load数据。</p><p>缓存一致性协议,也就是说的MESI，目前大多数cpu就是采用的缓存一致性协议，于是就</p><p>有了以下的架构。</p><pre><code>M:修改，该cache line有效，数据被修改了，和内存中的数据不一样，数据只存在于本cache中E:独享、互斥，该cache line有效，数据和内存中的数据一致，数据只存在于本cache中'S:共享，该cache line有效，数据和内存中的数据一致，数据存在于很多cache中I:无效，该cache无效。</code></pre><p>MESI是怎么保证缓存一直性的呢？举个栗子：</p><pre><code>假设主内存中有一个变量x=1，当cpu1读取了之后，cpu1中就会有缓存变量x(E)就会有一个时刻监听(总线嗅探机制)去监听主内存，,这时候，加入cpu2也读取了，那么cpu1中就会变成x(S),而cpu2中也会存在x(S)，cpu2也会对主内存监听，这时候，当cpu1对x做了修改，那么cpu1中就变成了X(M),当cpu通知了主内存之后，cpu1中就变成了X(E),而cpu2中则变成了X(I),于是cpu2中的x就被抛弃，这时候会重新获取，重新获取之后，cpu1和2中都会变成X(S)。</code></pre><p>那么假如两个线程同时修改了X，怎么办？</p><pre><code>加入同时修改，当在一个指令周期内，会进行裁决，裁决胜利的就可以修改，失败的话，怎么处理看cpu，不同的cpu指令不一样。取决于指令(像java中，就有unsafe来处理)。</code></pre><p>从主内存中，读取锁的最小单位是缓存行，加入一个数据的长度大于一个缓存行，这时候就会出现缓存行失效问题，当缓存行失 效，就会走总线加锁。</p><p>1.保持可见性。</p><p>可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。（强制重读）</p><p>可见性不能保证线程安全。线程安全的三个条件：原子性、可见性、禁止重排序。三者的解释可参考<a href="https://www.cnblogs.com/dolphin0520/p/3920373.html">https://www.cnblogs.com/dolphin0520/p/3920373.html</a></p><p>2.禁止指令重排序。</p><pre class="line-numbers language-none"><code class="language-none">x = 10;         //语句1y = x;         //语句2x++;           //语句3x = x + 1;     //语句4<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>如果语句3是带有volatile关键字的，位于语句3前面的语句不能重排序至其后面，语句3后面的语句不能重排序到3前面。语句3前面的语句可以随便重排序，只要自己不要越过语句3就行。</p><p><strong>经典问题</strong>：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">volatile</span> <span class="token keyword">int</span> inc <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>       <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token keyword">final</span> <span class="token class-name">Test</span> test <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">10</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>           <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>               <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                   <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span><span class="token number">1000</span><span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span>                       test<span class="token punctuation">.</span><span class="token function">increase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>               <span class="token punctuation">}</span><span class="token punctuation">;</span>           <span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token punctuation">}</span>   <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">increase</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>       inc<span class="token operator">++</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果小于10000。原因：</p><p>假如某个时刻变量inc的值为10，</p><p>　　线程1对变量进行自增操作，线程1先读取了变量inc的原始值，线程2对变量进行自增操作，然后线程1被阻塞了；</p><p>　　由于线程1只是对变量inc进行读取操作，而没有对变量进行修改操作，所以不会导致线程2的工作内存中缓存变量inc的缓存行无效，所以线程2会直接去主存读取inc的值，发现inc的值时10，然后进行加1操作，并把11写入工作内存，最后写入主存。</p><pre class="line-numbers language-none"><code class="language-none">i++操作可以被拆分为三步：     1，线程读取i的值     2、i进行自增计算     3、刷新回i的值<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>　　然后线程1接着进行加1操作，注意此时在线程1的工作内存中inc的值更新为11（volatile强制重读），但是线程1之前卡在了自增计算（非原子性操作，操作的还是10自增）所以线程1对inc进行加1操作后inc的值为11，然后将11写入工作内存（11替换强制更新的11），最后写入主存。</p><p>　　那么两个线程分别进行了一次自增操作后，inc只增加了1，结果都为11。</p><ul><li><strong>单例模式中的volatile</strong> 双检锁机制</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DoubleCheckedLocking</span> <span class="token punctuation">{</span> <span class="token comment">// 1</span><span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">static</span> <span class="token class-name">Instance</span> instance<span class="token punctuation">;</span> <span class="token comment">// 2</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Instance</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 3</span><span class="token keyword">if</span> <span class="token punctuation">(</span>instance <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 4:第一次检查</span><span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token class-name">DoubleCheckedLocking</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 5:加锁</span><span class="token keyword">if</span> <span class="token punctuation">(</span>instance <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token comment">// 6:第二次检查</span>instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Instance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 7:问题的根源出在这里</span><span class="token punctuation">}</span> <span class="token comment">// 8</span><span class="token punctuation">}</span> <span class="token comment">// 9</span><span class="token keyword">return</span> instance<span class="token punctuation">;</span> <span class="token comment">// 10</span><span class="token punctuation">}</span> <span class="token comment">// 11</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>第7行实际上编译后分为3步：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">memory <span class="token operator">=</span> <span class="token function">allocate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>　　<span class="token comment">// 1：分配对象的内存空间</span><span class="token function">ctorInstance</span><span class="token punctuation">(</span>memory<span class="token punctuation">)</span><span class="token punctuation">;</span>　<span class="token comment">// 2：初始化对象</span>instance <span class="token operator">=</span> memory<span class="token punctuation">;</span>　　<span class="token comment">// 3：设置instance指向刚分配的内存地址</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>编译期会做指令重排序，所以会有：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">memory <span class="token operator">=</span> <span class="token function">allocate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>　　<span class="token comment">// 1：分配对象的内存空间</span>instance <span class="token operator">=</span> memory<span class="token punctuation">;</span>　　<span class="token comment">// 3：设置instance指向刚分配的内存地址</span><span class="token comment">// 注意，此时对象还没有被初始化！</span><span class="token function">ctorInstance</span><span class="token punctuation">(</span>memory<span class="token punctuation">)</span><span class="token punctuation">;</span>　<span class="token comment">// 2：初始化对象</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>当A线程上面132的顺序分配了对象，但是当A刚刚执行完毕3，B看到了instance已经不为<code>null</code>，B此时调用了空对象，发生<font color="red">错误</font>。</p><h3 id="lt-happens-before原则"><a href="#lt-happens-before原则" class="headerlink" title="< happens-before原则"></a><font color="green">&lt; happens-before原则</font></h3><ul><li>程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作</li><li>锁定规则：一个unLock操作先行发生于后面对同一个锁lock操作</li><li>volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作</li><li>传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C</li><li>线程启动规则：Thread对象的start()方法先行发生于此线程的每个一个动作</li><li>线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生</li><li>线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行</li><li>对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始</li></ul><h3 id="lt-JAVA-并发"><a href="#lt-JAVA-并发" class="headerlink" title="< JAVA 并发"></a><font color="green">&lt; JAVA 并发</font></h3><p>最初的计算机只能接受一些特定的指令，用户每输入一个指令，计算机就做出一个操作。当用户在思考或者输入时，计算机就在等待。这样效率非常低下，在很多时候，计算机都处在等待状态。</p><p><strong>批处理操作系统</strong></p><p>后来有了<strong>批处理操作系统</strong>,把一系列需要操作的指令写下来，形成一个<strong>清单</strong>，一次性交给计算机。</p><p>批处理操作系统在一定程度上提高了计算机的效率，但是由于<strong>批处理操作系统的指令运行方式仍然是串行的，内存中始终只有一个程序在运行</strong>，后面的程序需要等待前面的程序执行完成后才能开始执行，而前面的程序有时会由于I/O操作、网络等原因阻塞，所以<strong>批处理操作效率也不高</strong>。</p><p><strong>进程的提出</strong></p><p>批处理操作系统的瓶颈在于内存中只存在一个程序，那么内存中能不能存在多个程序呢？进程应运而生。</p><p>进程就是<strong>应用程序在内存中分配的空间，也就是正在运行的程序</strong>，各个进程之间互不干扰。同时进程保存着程序每一个时刻运行的状态。</p><blockquote><p>程序：用某种编程语言(java、python等)编写，能够完成一定任务或者功能的代码集合,是指令和数据的有序集合，是<strong>一段静态代码</strong>。</p></blockquote><p>此时，CPU采用时间片轮转的方式运行进程：CPU为每个进程分配一个时间段，称作它的时间片。如果在时间片结束时进程还在运行，则暂停这个进程的运行，并且CPU分配给另一个进程（这个过程叫做上下文切换）。如果进程在时间片结束前阻塞或结束，则CPU立即进行切换，不用等待时间片用完。 </p><blockquote><p>当进程暂停时，它会保存当前进程的状态（进程标识，进程使用的资源等），在下一次切换回来时根据之前保存的状态进行恢复，接着继续执行。</p></blockquote><p>使用进程+CPU时间片轮转方式的操作系统，在宏观上看起来同一时间段执行多个任务，<strong>进程让操作系统的并发成为了可能</strong>。虽然并发从宏观上看有多个任务在执行，但在事实上，对于<strong>单核CPU</strong>来说，任意具体时刻都只有一个任务在占用CPU资源。</p><p><strong>对操作系统的要求进一步提高</strong></p><p>虽然进程的出现，使得操作系统的性能大大提升，但是随着时间的推移，人们并不满足一个进程在一段时间只能做一件事情，如果一个进程有多个子任务时，只能逐个得执行这些子任务，很影响效率。</p><blockquote><p>比如杀毒软件在检测用户电脑时，如果在某一项检测中卡住了，那么后面的检测项也会受到影响。或者说当你使用杀毒软件中的扫描病毒功能时，在扫描病毒结束之前，无法使用杀毒软件中清理垃圾的功能，这显然无法满足人们的要求。</p></blockquote><p><strong>线程的提出</strong></p><p><strong>让一个线程执行一个子任务，这样一个进程就包含了多个线程，每个线程负责一个单独的子任务。</strong></p><blockquote><p>使用线程之后，事情就变得简单多了。当用户使用扫描病毒功能时，就让扫描病毒这个线程去执行。同时，如果用户又使用清理垃圾功能，那么可以先暂停扫描病毒线程，先响应用户的清理垃圾的操作，让清理垃圾这个线程去执行。响应完后再切换回来，接着执行扫描病毒线程。</p></blockquote><p>总之，进程和线程的提出极大的提高了操作系统的性能。<strong>进程让操作系统的并发性成为了可能，而线程让进程的内部并发成为了可能。</strong></p><p><strong>多进程的方式也可以实现并发，为什么要使用多线程？</strong></p><p>多进程方式确实可以实现并发，但使用多线程，有以下几个好处：</p><ul><li>进程间的通信比较复杂，而线程间的通信比较简单，通常情况下，我们需要使用共享资源，这些资源在线程间的通信比较容易。</li><li>进程是重量级的，而线程是轻量级的，故多线程方式的系统开销更小。</li></ul><p><strong>进程和线程的区别</strong></p><p>进程是一个独立的运行环境，而线程是在进程中执行的一个任务。他们两个本质的区别是<strong>是否单独占有内存地址空间及其它系统资源（比如I/O）</strong>：</p><ul><li>进程单独占有一定的内存地址空间，所以进程间存在内存隔离，数据是分开的，数据共享复杂但是同步简单，各个进程之间互不干扰；而线程共享所属进程占有的内存地址空间和资源，数据共享简单，但是同步复杂。 </li><li>进程单独占有一定的内存地址空间，一个进程出现问题不会影响其他进程，不影响主程序的稳定性，可靠性高；一个线程崩溃可能影响整个程序的稳定性，可靠性较低。 </li><li>进程单独占有一定的内存地址空间，进程的创建和销毁不仅需要保存寄存器和栈信息，还需要资源的分配回收以及页调度，开销较大；线程只需要保存寄存器和栈信息，开销较小。</li></ul><p><strong>进程是操作系统进行资源分配的基本单位，而线程是操作系统进行调度的基本单位</strong>，即CPU分配时间的单位 。</p><h3 id="lt-上下文切换"><a href="#lt-上下文切换" class="headerlink" title="< 上下文切换"></a><font color="green">&lt; 上下文切换</font></h3><p>上下文切换（有时也称做进程切换或任务切换）是指 CPU 从一个进程（或线程）切换到另一个进程（或线程）。上下文是指<strong>某一时间点 CPU 寄存器和程序计数器的内容。</strong></p><blockquote><p>寄存器是cpu内部的少量的速度很快的闪存，通常存储和访问计算过程的中间值提高计算机程序的运行速度。</p><p>程序计数器是一个专用的寄存器，用于表明指令序列中 CPU 正在执行的位置，存的值为正在执行的指令的位置或者下一个将要被执行的指令的位置，具体实现依赖于特定的系统。</p><p>举例说明 线程A - B  </p><p>1.先挂起线程A，将其在cpu中的状态保存在内存中。  </p><p>2.在内存中检索下一个线程B的上下文并将其在 CPU 的寄存器中恢复,执行B线程。  </p><p>3.当B执行完，根据程序计数器中指向的位置恢复线程A。</p></blockquote><p>CPU通过为每个线程分配CPU时间片来实现多线程机制。CPU通过时间片分配算法来循环执行任务，当前任务执行一个时间片后会切换到下一个任务。</p><p>但是，在切换前会保存上一个任务的状态，以便下次切换回这个任务时，可以再加载这个任务的状态。所以任务从保存到再加载的过程就是一次上下文切换。</p><p>上下文切换通常是计算密集型的，意味着此操作会<strong>消耗大量的 CPU 时间，故线程也不是越多越好</strong>。减少系统中上下文切换次数.</p><h3 id="gt-进程创建的几种方式"><a href="#gt-进程创建的几种方式" class="headerlink" title="&nbsp;>进程创建的几种方式"></a><font color="green">&nbsp;&gt;进程创建的几种方式</font></h3><ol><li>Thread 继承Tread，重写run方法。</li><li>Runnable 接口 重写run方法。</li><li>Callable接口，使用FutureTask类创建线程。</li><li>使用线程池。</li></ol><h3 id="lt-JAVA-线程状态"><a href="#lt-JAVA-线程状态" class="headerlink" title="< JAVA 线程状态"></a><font color="green">&lt; JAVA 线程状态</font></h3><p>java线程有6个状态：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">enum</span> <span class="token class-name">State</span><span class="token punctuation">{</span>    NEW<span class="token punctuation">,</span>    RUNNABLE<span class="token punctuation">,</span>    BLOCKED<span class="token punctuation">,</span>    WAITING<span class="token punctuation">,</span>    TIMED_WAITING<span class="token punctuation">,</span>    TERMINATED<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li>NEW状态</li></ol><p>线程此时尚未启动。（还没有调用<code>start()</code>方法。）</p><p>注意：不可反复调用<code>start()</code>方法，会抛出不合法线程异常。</p><p>一个线程执行完毕（TERMINATED)，这个线程不可再调用start方法（仍然会返回TERMINATED状态）。</p><ol start="2"><li>RUNNABLE</li></ol><p>正在虚拟机种运行。</p><ol start="3"><li>BLOCKED</li></ol><p>等待锁释放。</p><ol start="4"><li>WAITING</li></ol><p>等待状态，处于等待状态的线程变为RUNNABLE状态需要被其他线程唤醒。以下三个方法：</p><ul><li><code>Object.wait()</code>：使得当前线程处于等待状态直到另一个线程唤醒它。</li><li><code>Thread.join()</code>：等待线程执行完毕，底层调用的时Object实例的wait方法。</li><li><code>LockSupport.park()</code>：除非获得调用许可，否则禁用当前线程进行调度。</li></ul><ol start="5"><li>超时等待</li></ol><ul><li><code>Thread.sleep(long millis)</code>：使当前线程睡眠指定时间；</li><li><code>Object.wait(long timeout)</code>：线程休眠指定时间，等待期间可以通过notify()/notifyAll()唤醒；</li><li><code>Thread.join(long millis)</code>：等待当前线程最多执行millis毫秒，如果millis为0，则会一直执行；</li><li><code>LockSupport.parkNanos(long nanos)</code>： 除非获得调用许可，否则禁用当前线程进行线程调度指定时间；</li><li><code>LockSupport.parkUntil(long deadline)</code>：同上，也是禁止线程进行调度指定时间；</li></ul><ol start="6"><li>TERMINATED</li></ol><p>终止状态，此时线程执行完毕。</p><p><img src="/2021/03/15/java/%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E5%88%87%E6%8D%A2.png" alt="句柄"></p><h3 id="lt-CAS-与原子操作"><a href="#lt-CAS-与原子操作" class="headerlink" title="< CAS 与原子操作"></a><font color="green">&lt; CAS 与原子操作</font></h3><p>比较与交换（<strong>Compare And Swap</strong>）。在CAS中，有这样三个值：</p><ul><li>V：要更新的变量（var）</li><li>E：预期值（expected）</li><li>N：新值（new）</li></ul><p>过程如下：判断V是否等于E，如果等于，则将V的值设置为N。如果不等，则说明已经有其他线程更新了V，则当前线程放弃更新，什么不做。</p><p><strong>预期值E的本质就是指上一次的“旧值”。</strong></p><p>举个例子：</p><ol><li>如果有一个多个线程共享的变量<code>i</code>原本等于5，我现在在线程A中，想把它设置为新的值6;</li><li>我们使用CAS来做这个事情；</li><li>首先我们用i去与5对比，发现它等于5，说明没有被其它线程改过，那我就把它设置为新的值6，此次CAS成功，<code>i</code>的值被设置成了6；</li><li>如果不等于5，说明<code>i</code>被其它线程改过了（比如现在<code>i</code>的值为2），那么我就什么也不做，此次CAS失败，<code>i</code>的值仍然为2</li></ol><p><code>i</code>就是V，5就是E，6就是N。</p><p>CAS是一种原子操作，是一种系统原语，是一条CPU的原子指令，从CPU层面保证它的原子性。当多个线程同时使用CAS操作一个变量，只有一个会胜出并更新，但失败的进程不会挂起，仅被告知失败，并且允许再次尝试，当然也允许失败的线程放弃操作。</p><h4 id="JAVA-实现CAS原理"><a href="#JAVA-实现CAS原理" class="headerlink" title="JAVA 实现CAS原理"></a>JAVA 实现CAS原理</h4><p>使用了Unsafe类</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">boolean</span> <span class="token function">compareAndSwapObject</span><span class="token punctuation">(</span><span class="token class-name">Object</span> o<span class="token punctuation">,</span> <span class="token keyword">long</span> offset<span class="token punctuation">,</span><span class="token class-name">Object</span> expected<span class="token punctuation">,</span> <span class="token class-name">Object</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">boolean</span> <span class="token function">compareAndSwapInt</span><span class="token punctuation">(</span><span class="token class-name">Object</span> o<span class="token punctuation">,</span> <span class="token keyword">long</span> offset<span class="token punctuation">,</span><span class="token keyword">int</span> expected<span class="token punctuation">,</span><span class="token keyword">int</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">boolean</span> <span class="token function">compareAndSwapLong</span><span class="token punctuation">(</span><span class="token class-name">Object</span> o<span class="token punctuation">,</span> <span class="token keyword">long</span> offset<span class="token punctuation">,</span><span class="token keyword">long</span> expected<span class="token punctuation">,</span><span class="token keyword">long</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>Unsafe中对CAS的实现是C++写的，它的具体实现和操作系统、CPU都有关系。</p><p>Linux的X86下主要是通过<code>cmpxchgl</code>这个指令在CPU级完成CAS操作的，但在多处理器情况下必须使用<code>lock</code>指令加锁来完成。当然不同的操作系统和处理器的实现会有所不同，大家可以自行了解。</p><p>当然，Unsafe类里面还有其它方法用于不同的用途。比如支持线程挂起和恢复的<code>park</code>和<code>unpark</code>， LockSupport类底层就是调用了这两个方法。还有支持反射操作的<code>allocateInstance()</code>方法。</p><h3 id="java-util-concurrent-atomic-原子操作"><a href="#java-util-concurrent-atomic-原子操作" class="headerlink" title="java.util.concurrent.atomic 原子操作"></a>java.util.concurrent.atomic 原子操作</h3><p>JDK提供了一些用于原子操作的类，在<code>java.util.concurrent.atomic</code>包下面。在JDK 11中，有如下17个类：</p><p><img src="/2021/03/15/java/%E5%8E%9F%E5%AD%90%E7%B1%BB.jpg" alt="句柄"></p><p>从名字看出大概用途：</p><ul><li>原子更新基本类型</li><li>原子更新数组</li><li>原子更新引用</li><li>原子更新字段（属性）</li></ul><h3 id="java线程池用过没有？"><a href="#java线程池用过没有？" class="headerlink" title="java线程池用过没有？"></a><font color="green">java线程池用过没有？</font></h3><blockquote><p>Executors提供了四种方法来创建线程池。</p></blockquote><ol><li>newFixedThreadPool() :创建固定大小的线程池。</li><li>newCachedThreadPool(): 创建无限大小的线程池，线程池中线程数量不固定，可根据需求自动更改。</li><li>newSingleThreadPool() : 创建单个线程池，线程池中只有一个线程。</li><li>newScheduledThreadPool() 创建固定大小的线程池，可以延迟或定时的执行任务。</li></ol><h5 id="线程池作用"><a href="#线程池作用" class="headerlink" title="线程池作用"></a>线程池作用</h5><ol><li>限制线程个数，避免线程过多导致系统运行缓慢或崩溃。</li><li>不需要频繁的创建和销毁，节约资源、响应更快。</li></ol><h3 id="Synchronized与ReetrantLock锁区别"><a href="#Synchronized与ReetrantLock锁区别" class="headerlink" title="Synchronized与ReetrantLock锁区别"></a><font color="green">Synchronized与ReetrantLock锁区别</font></h3><p>Synchronized 和ReetrantLock都是阻塞式同步。</p><p>其中Synchronized是Java关键字，需要jvm实现。它进入编译，会在同步块前后形成<code>monitorenter</code>和<code>monitorexit</code>两个字节码指令。执行<code>monitorenter</code>指令时，首先要尝试获取对象锁，如果这个对象锁没被锁定，或者当前线程已经拥有了那个对象锁，把锁的计算器加1。相应的，在执行monitorexit指令时会将锁计算器减1，当计算器为0时，锁被释放。如果对象所获得失败，就要阻塞。</p><p>ReentrantLock 是juc(java.util.concurrent)包下提供的一套互斥锁，属于API层面。它有以下Synchronized没有的功能：</p><ol><li>等待可中断。持有锁的线程长期不释放时，等待的线程选择放弃等待。</li><li>公平锁。默认构造函数改为true。</li><li>可绑定多个对象。</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">notify</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token class-name">Lock</span> lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReetrantLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Condition</span> contidtion <span class="token operator">=</span> lock<span class="token punctuation">.</span><span class="token function">newCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>condition<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>condition<span class="token punctuation">.</span><span class="token function">signal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Synchronized与锁"><a href="#Synchronized与锁" class="headerlink" title="Synchronized与锁"></a><font color="green">Synchronized与锁</font></h3><p>对外的依赖多少。</p><ol><li>无锁状态</li><li>偏向锁状态</li><li>轻量级锁状态</li><li>重量级锁状态</li></ol><p><img src="/2021/03/15/java/%E9%94%81%E5%8D%87%E7%BA%A7.PNG"></p><p>偏向锁CAS机制while 改成if。轻量级锁就是CAS（C++写的），如果竞争激烈，就转换为重量级锁（调用操作系统的阻塞）。</p><p>无锁就是没有对资源进行锁定，任何线程都可以尝试去修改它。</p><p>锁的升级很容易发生，但是锁降级发生的条件比较苛刻，锁降级发生在<code>Stop the world</code>期间，当JVM进入安全点的时候，会检查是否有闲置锁，然后进行降级。</p><ul><li>JAVA对象头</li></ul><p>java对象的锁都是基于对象的。非数组类型，则用2个字宽来存储对象头（64位机子，一个字宽64位）。数组类型用3个字宽来存储对象头。对象头内容如下表：</p><table><thead><tr><th align="center">长度</th><th align="center">内容</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">32/64bit</td><td align="center">Mark Word</td><td align="center">存储对象的hashCode或锁信息等</td></tr><tr><td align="center">32/64bit</td><td align="center">Class Metadata Address</td><td align="center">存储到对象类型数据的指针</td></tr><tr><td align="center">32/64bit</td><td align="center">Array length</td><td align="center">数组的长度（如果是数组）</td></tr></tbody></table><p>我们主要来看看Mark Word的格式：</p><table><thead><tr><th align="center">锁状态</th><th align="center">29 bit 或 61 bit</th><th align="center">1 bit 是否是偏向锁？</th><th align="center">2 bit 锁标志位</th></tr></thead><tbody><tr><td align="center">无锁</td><td align="center"></td><td align="center">0</td><td align="center">01</td></tr><tr><td align="center">偏向锁</td><td align="center">线程ID</td><td align="center">1</td><td align="center">01</td></tr><tr><td align="center">轻量级锁</td><td align="center">指向栈中锁记录的指针</td><td align="center">此时这一位不用于标识偏向锁</td><td align="center">00</td></tr><tr><td align="center">重量级锁</td><td align="center">指向互斥量（重量级锁）的指针</td><td align="center">此时这一位不用于标识偏向锁</td><td align="center">10</td></tr><tr><td align="center">GC标记</td><td align="center"></td><td align="center">此时这一位不用于标识偏向锁</td><td align="center">11</td></tr></tbody></table><p>当对象状态为偏向锁时，<code>Mark Word</code>存储的是偏向的线程ID；当状态为轻量级锁时，<code>Mark Word</code>存储的是指向线程栈中<code>Lock Record</code>的指针；当状态为重量级锁时，<code>Mark Word</code>为指向堆中的monitor对象的指针。</p><ul><li>偏向锁</li></ul><p>偏向锁偏向于第一个访问锁的线程，如果在接下来的运行过程中，该锁没有被其他线程访问，则持有偏向锁的线程将永远不需要触发同步。 <strong>偏向锁在资源无竞争的情况下消除了同步语句，连CAS操作都不做，提高了程序的运行性能。</strong></p><p><img src="/2021/03/15/java/%E5%81%8F%E5%90%91%E9%94%81%E6%93%8D%E4%BD%9C%E6%B5%81%E7%A8%8B.png" alt="句柄"></p><p>偏向锁使用一种<strong>等待竞争出现才释放锁的机制</strong>。</p><p>偏向锁升级成轻量级锁时，会暂停拥有偏向锁的线程，重置偏向锁标识，这个过程看起来容易，实则开销还是很大的，大概的过程如下：</p><ol><li>在一个安全点（在这个时间点上没有字节码正在执行）停止拥有锁的线程。</li><li>遍历线程栈，如果存在锁记录的话，需要修复锁记录和Mark Word，使其变成无锁状态。</li><li>唤醒被停止的线程，将当前锁升级成轻量级锁。</li></ol><p><img src="/2021/03/15/java/%E5%81%8F%E5%90%91%E9%94%81%E7%9A%84%E6%92%A4%E9%94%80.png" alt="句柄"></p><ul><li>轻量级锁</li></ul><p>多个线程在不同时段获取同一把锁，不存在锁竞争的情况，使用轻量级锁来避免线程的阻塞和唤醒。</p><p>加锁：JVM为每个线程在当前线程的栈帧中创建用于存储锁记录的空间——<code>Displaced Mark Word</code>。如果一个线程获得锁时发现时轻量级锁，会把<code>Mark Word</code>复制到自己的<code>Displaced Marked Word</code>中。</p><p>然后线程尝试用CAS将锁的<code>Mark Word</code>替换为指向锁记录的指针。成功则获得锁，失败则<code>Mark World</code>被替换成了其他线程的锁记录，说明与其他线程存在竞争锁，当前线程就尝试使用<code>自旋</code>来获取锁。</p><p><font color="green">自旋</font></p><p>自旋要消耗CPU，如果一直获不得锁，则一直处于自旋状态。JDK使用<font color="green">自适应自旋</font>，如果线程自旋成功，则下次自旋的次数会更多，如果失败了，则自旋的次数会减少。</p><p>如果一直自旋失败，则这个线程阻塞，同时锁升级为重量级锁。</p><p><font color="green">轻量级锁的释放：</font></p><p>释放锁时，当前线程使用CAS将<code>Dispalced Mark Word</code>的内容复制回锁的<code>Mark Word</code>里面。如果没有发生竞争，则这个复制操作成功。如果因为竞争升级成了重量级锁，那么CAS操作会操作失败，此时释放锁并唤醒被阻塞的线程。</p><p><img src="/2021/03/15/java/%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81.png" alt="句柄"></p><ul><li>重量级锁</li></ul><p>重量级锁依赖于操作系统的互斥量（mutex)实现，而操作系统线程间状态的转换需要比较长的时间，所以重量级锁的效率很低，但被阻塞的线程不会消耗CPU。</p><p>每一个对象都可以当成一个锁，当多个线程同时请求某一个对象锁时，对象锁设置几种状态用来区分请求的线程：</p><pre class="line-numbers language-none"><code class="language-none">Contention List：所有请求锁的线程将被首先放置到该竞争队列Entry List：Contention List中那些有资格成为候选人的线程被移到Entry ListWait Set：那些调用wait方法被阻塞的线程被放置到Wait SetOnDeck：任何时刻最多只能有一个线程正在竞争锁，该线程称为OnDeckOwner：获得锁的线程称为Owner!Owner：释放锁的线程<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果线程获得锁后调用<code>Object.wait</code>方法，则会将线程加入到WaitSet中，当被<code>Object.notify</code>唤醒后，会将线程从WaitSet移动到Contention List或EntryList中去。需要注意的是，当调用一个锁对象的<code>wait</code>或<code>notify</code>方法时，<strong>如当前锁的状态是偏向锁或轻量级锁则会先膨胀成重量级锁</strong>。</p><h3 id="总结锁的升级流程"><a href="#总结锁的升级流程" class="headerlink" title="总结锁的升级流程"></a>总结锁的升级流程</h3><p>每一个线程在准备获取共享资源时： 第一步，检查MarkWord里面是不是放的自己的ThreadId ,如果是，表示当前线程是处于 “偏向锁” 。</p><p>第二步，如果MarkWord不是自己的ThreadId，锁升级，这时候，用CAS来执行切换，新的线程根据MarkWord里面现有的ThreadId，通知之前线程暂停，之前线程将Markword的内容置为空。</p><p>第三步，两个线程都把锁对象的HashCode复制到自己新建的用于存储锁的记录空间，接着开始通过CAS操作， 把锁对象的MarKword的内容修改为自己新建的记录空间的地址的方式竞争MarkWord。</p><p>第四步，第三步中成功执行CAS的获得资源，失败的则进入自旋 。</p><p>第五步，自旋的线程在自旋过程中，成功获得资源(即之前获的资源的线程执行完成并释放了共享资源)，则整个状态依然处于 轻量级锁的状态，如果自旋失败 。</p><p>第六步，进入重量级锁的状态，这个时候，自旋的线程进行阻塞，等待之前线程执行完成并唤醒自己。</p><table><thead><tr><th>锁</th><th>优点</th><th>缺点</th><th>适用场景</th></tr></thead><tbody><tr><td>偏向锁</td><td>加锁和解锁不需要额外的消耗，和执行非同步方法比仅存在纳秒级的差距。</td><td>如果线程间存在锁竞争，会带来额外的锁撤销的消耗。</td><td>适用于只有一个线程访问同步块场景。</td></tr><tr><td>轻量级锁</td><td>竞争的线程不会阻塞，提高了程序的响应速度。</td><td>如果始终得不到锁竞争的线程使用自旋会消耗CPU。</td><td>追求响应时间。同步块执行速度非常快。</td></tr><tr><td>重量级锁</td><td>线程竞争不使用自旋，不会消耗CPU。</td><td>线程阻塞，响应时间缓慢。</td><td>追求吞吐量。同步块执行时间较长。</td></tr></tbody></table><p>泛型</p><p><strong>把类型明确的工作推迟到创建对象或调用方法的时候</strong></p><h2 id="4-JAVA-8-新特性"><a href="#4-JAVA-8-新特性" class="headerlink" title="4. JAVA 8 新特性"></a>4. JAVA 8 新特性</h2><p>接口中的<code>default</code>新方法、<code>static</code>可以修饰方法了，并且提供实现。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">interface</span> <span class="token class-name">Formula</span><span class="token punctuation">{</span>    <span class="token keyword">double</span> <span class="token function">calculate</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">default</span> <span class="token keyword">double</span> <span class="token function">sqrt</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">sqrt</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>        <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">process</span><span class="token punctuation">(</span><span class="token class-name">String</span> hello<span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过使用<code>default</code>方法可以在接口中实现具体方法（非抽象方法）<font color="red"> <code>default</code>方法不能被子类重写，只能继承</font>。</p><h4 id="1-Stream"><a href="#1-Stream" class="headerlink" title="1. Stream"></a>1. Stream</h4><p><code>1. 中间操作</code>（返回<code>Stream&lt;T&gt;</code>和<code>终端操作</code>（返回定义类型的结果）。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">long</span> count <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">distinct</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="2"><li>可以替代循环的<code>anymatch</code></li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">String</span> string <span class="token operator">:</span> list<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>string<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment">//可以替换为如下：</span><span class="token keyword">boolean</span> isExist <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">anyMatch</span><span class="token punctuation">(</span>element <span class="token operator">-&gt;</span> element<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="3"><li>过滤，选出想要的元素 <code>Filtering</code></li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"One"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"OneAndOnly"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"Derek"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"Change"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"factory"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"justBefore"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"Italy"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"Italy"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"Thursday"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span>list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Stream</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> stream <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>element <span class="token operator">-&gt;</span> <span class="token function">contains</span><span class="token punctuation">(</span><span class="token string">"d"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="4"><li>通过一个函数转换你想得到的结果 <code>Mapping</code></li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> uris <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>uris<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"C:\\My.txt"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Stream</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Path</span><span class="token punctuation">&gt;</span></span> stream <span class="token operator">=</span> uris<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>uri <span class="token operator">-&gt;</span> <span class="token class-name">Paths</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>uri<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ol start="5"><li><code>Matching</code></li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">boolean</span> isValid <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">anyMatch</span><span class="token punctuation">(</span>element <span class="token operator">-&gt;</span> element<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span><span class="token string">"h"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">boolean</span> isValidOne <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">allMatch</span><span class="token punctuation">(</span>element <span class="token operator">-&gt;</span> element<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span><span class="token string">"h"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">boolean</span> isvalidTwo <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">noneMatch</span><span class="token punctuation">(</span>element <span class="token operator">-</span> <span class="token operator">&gt;</span> element<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span><span class="token string">"h"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ol start="6"><li><code>Reduction</code> </li></ol><p>Imagine that you have a <em>List<integer></integer></em> and you want to have a sum of all these elements and some initial <em>Integer</em> (in this example 23). So, you can run the following code and result will be 26 (23 + 1 + 1 + 1).</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> integers <span class="token operator">=</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Integer</span> reduced <span class="token operator">=</span> integers<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token number">23</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> a <span class="token operator">+</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ol start="7"><li><code>Collecting</code></li></ol><p>把stream转为Collection或map。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> resultList <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>element <span class="token operator">-&gt;</span> element<span class="token punctuation">.</span><span class="token function">toUpperCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span><span class="token class-name">Collectors</span><span class="token punctuation">.</span><span class="token function">toList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>操作系统</title>
      <link href="2021/03/15/operate/"/>
      <url>2021/03/15/operate/</url>
      
        <content type="html"><![CDATA[<h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><h2 id="1-操作系统的概念"><a href="#1-操作系统的概念" class="headerlink" title="1.操作系统的概念"></a>1.操作系统的概念</h2><ol><li>操作系统特征： 并发、 共享 、 虚拟、 异步。</li></ol><p><img src="/2021/03/15/operate/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5-1615794509246.PNG"></p><p>补充：进程是一个程序的执行过程。执行前需要将程序放入内存，才能被CPU处理。</p><p><img src="/2021/03/15/operate/%E7%9F%A5%E8%AF%86%E6%80%BB%E8%A7%88-1615794509247.PNG"></p><h3 id="1-1处理器的两种状态"><a href="#1-1处理器的两种状态" class="headerlink" title="1.1处理器的两种状态"></a>1.1处理器的两种状态</h3><p><img src="/2021/03/15/operate/%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E4%B8%A4%E7%A7%8D%E7%8A%B6%E6%80%81-1615794509247.PNG"></p><p><img src="/2021/03/15/operate/%E4%B8%A4%E7%A7%8D%E7%A8%8B%E5%BA%8F-1615794509247.PNG"></p><h3 id="1-2-大内核微内核"><a href="#1-2-大内核微内核" class="headerlink" title="1.2 大内核微内核"></a>1.2 大内核微内核</h3><p><img src="/2021/03/15/operate/%E5%A4%A7%E5%86%85%E6%A0%B8%E5%BE%AE%E5%86%85%E6%A0%B81-1615794509248.PNG"></p><p>微内核：只包含一些必不可少的功能。</p><p>大内核：除了微内核还有其他非必要功能。</p><p><img src="/2021/03/15/operate/%E5%A4%A7%E5%86%85%E6%A0%B8%E5%BE%AE%E5%86%85%E6%A0%B82-1615794509248.PNG"></p><h3 id="1-3-中断和异常"><a href="#1-3-中断和异常" class="headerlink" title="1.3 中断和异常"></a>1.3 中断和异常</h3><p><img src="/2021/03/15/operate/%E4%B8%AD%E6%96%AD%E6%8E%A7%E5%88%B6%E5%99%A8.PNG"></p><p><img src="/2021/03/15/operate/%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86%E6%98%A0%E5%B0%84%E8%A1%A8.PNG"></p><p>中断映射表，存储中断处理代码入口。寄存器里面解析出来的向量值，然后查映射表，就知道什么中断程序了。</p><p><img src="/2021/03/15/operate/%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B81-1615794509248.PNG"></p><p><img src="/2021/03/15/operate/%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B82-1615794509248.PNG"></p><p><img src="/2021/03/15/operate/%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B83-1615794509248.PNG"></p><p>这些操作执行完成后，操作系统会把CPU的使用权交还给应用进程。</p><p><img src="/2021/03/15/operate/%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B84-1615794509248.PNG"></p><p>进程无法直接中断，所以只能通过系统调用的方式请求输出。</p><p>tips： </p><ul><li>由于操作系统的管理工作需要使用特权指令，因此CPU要从用户态转为核心态。中断可以使CPU从用户态切换为核心态，使操作系统获得计算机的控制权。有了中断，才能实现多道程序并发执行。</li><li><font color="red">用户态—&gt;核心态是通过中断实现的，并且中断是唯一途径。</font>核心态—&gt;用户态的切换是通过执行特权指令，将程序状态字(PSW)的标志位设置为”用户态”。</li></ul><h4 id="1-3-1中断的分类"><a href="#1-3-1中断的分类" class="headerlink" title="1.3.1中断的分类"></a>1.3.1中断的分类</h4><p><img src="/2021/03/15/operate/%E4%B8%AD%E6%96%AD%E7%9A%84%E5%88%86%E7%B1%BB-1615794509248.PNG"></p><p><font color="red">看中断是来自CPU内部还是外部。</font></p><p><img src="/2021/03/15/operate/%E4%B8%AD%E6%96%AD%E7%9A%84%E5%88%86%E7%B1%BB1-1615794509248.PNG"></p><h3 id="1-4-系统调用"><a href="#1-4-系统调用" class="headerlink" title="1.4 系统调用"></a>1.4 系统调用</h3><ul><li>系统调用是操作系统提供给应用程序使用的接口，可以理解为一种可供应用程序调用的特殊函数，应用程序可以发出系统调用来请求操作系统的服务。</li><li>系统调用和库函数有区别。</li></ul><h3 id="1-4-1库函数和系统调用的关系"><a href="#1-4-1库函数和系统调用的关系" class="headerlink" title="1.4.1库函数和系统调用的关系"></a>1.4.1库函数和系统调用的关系</h3><p><img src="/2021/03/15/operate/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8-1615794509248.PNG"></p><ul><li>传递系统调用参数—&gt;执行陷入指令（用户态）—&gt;执行系统调用相应的服务程序(核心态)—&gt;返回用户程序</li><li>陷入指令是在用户态执行的，执行陷入指令之后立即引发一个内中断，从而CPU进入核心态。</li><li>发出系统调用请求是在用户态，而对系统调用的相应处理在核心态进行。</li><li>陷入指令是唯一一个只能在用户态执行，而不可在核心态执行的指令</li><li>凡是与资源有关的操作、会直接影响到其他进程的操作，一定需要操作系统介入，需要系统调用来实现。</li></ul><h2 id="2-进程与线程"><a href="#2-进程与线程" class="headerlink" title="2. 进程与线程"></a>2. 进程与线程</h2><h3 id="2-1-状态转移"><a href="#2-1-状态转移" class="headerlink" title="2.1 状态转移"></a>2.1 状态转移</h3><p><img src="/2021/03/15/operate/%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81-1615794509248.PNG"></p><ul><li>为了方便对各个进程的管理，操作系统将进车给划分为几种状态，三种基本状态：<ol><li>运行态</li><li>就绪态</li><li>阻塞态</li></ol></li></ul><p><img src="/2021/03/15/operate/%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%811-1615794509248.PNG"></p><h3 id="2-2-进程控制"><a href="#2-2-进程控制" class="headerlink" title="2.2 进程控制"></a>2.2 进程控制</h3><p>对系统中的所有进程进行有效管理。</p><ul><li>使用原语对进程的控制。</li></ul><p><img src="/2021/03/15/operate/%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6-1615794509249.PNG"></p><p>进程控制原语要做三类事情：</p><ul><li>更新PCB中的信息（如修改进程状态标志、将运行环境保存到PCB）<ol><li>所有进程控制原语一定都会修改进程状态标志</li><li>剥夺当前运行进程的CPU使用权必然需要保存其运行环境</li><li>某进程开始运行前必然要回复运行环境</li></ol></li><li>将PCB插入合适队列</li><li>分配/回收资源</li></ul><ol><li>进程创建原语</li></ol><p><img src="/2021/03/15/operate/%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B62-1615794509249.PNG"></p><ol start="2"><li>进程撤销原语</li></ol><p><img src="/2021/03/15/operate/%E8%BF%9B%E7%A8%8B%E7%BB%88%E6%AD%A2-1615794509249.PNG"></p><ol start="3"><li>进程阻塞和唤醒</li></ol><p>阻塞和唤醒是成对出现的。</p><p><img src="/2021/03/15/operate/%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B63-1615794509249.PNG"></p><ol start="4"><li>进程的切换原语</li></ol><p><img src="/2021/03/15/operate/%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B64-1615794509249.PNG"></p><h3 id="2-3-进程通信"><a href="#2-3-进程通信" class="headerlink" title="2.3 进程通信"></a>2.3 进程通信</h3><ul><li>进程之间的信息交换和传递。</li><li>操作系统通信分类</li></ul><p><img src="/2021/03/15/operate/%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1-1615794509249.PNG"></p><ol><li>共享存储</li></ol><p><img src="/2021/03/15/operate/%E5%85%B1%E4%BA%AB%E5%AD%98%E5%82%A8-1615794509249.PNG"></p><ol start="2"><li>管道通信</li></ol><p><img src="/2021/03/15/operate/%E7%AE%A1%E9%81%93%E9%80%9A%E4%BF%A1-1615794509249.PNG"></p><ol start="3"><li>消息传递</li></ol><p><img src="/2021/03/15/operate/%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92-1615794509249.PNG"></p><h3 id="2-4-进程调度"><a href="#2-4-进程调度" class="headerlink" title="2.4 进程调度"></a>2.4 进程调度</h3><p>调度有三个层次：</p><ol><li>高级调度 （调入内存）</li></ol><p><img src="/2021/03/15/operate/%E9%AB%98%E7%BA%A7%E8%B0%83%E5%BA%A6-1615794509249.PNG"></p><ol start="2"><li>中级调度</li></ol><p><img src="/2021/03/15/operate/%E4%B8%AD%E7%BA%A7%E8%B0%83%E5%BA%A6-1615794509249.PNG"></p><ul><li>挂起状态的七状态模型</li></ul><p><img src="/2021/03/15/operate/%E6%8C%82%E8%B5%B77%E7%8A%B6%E6%80%81-1615794509249.PNG"></p><ul><li>低级调度（进程调度）</li></ul><p><img src="/2021/03/15/operate/%E4%BD%8E%E7%BA%A7%E8%B0%83%E5%BA%A6-1615794509249.PNG"></p><h3 id="2-5-进程调度时机和切换过程"><a href="#2-5-进程调度时机和切换过程" class="headerlink" title="2.5 进程调度时机和切换过程"></a>2.5 进程调度时机和切换过程</h3><h4 id="2-5-1-调度算法"><a href="#2-5-1-调度算法" class="headerlink" title="2.5.1 调度算法"></a>2.5.1 调度算法</h4><ol><li>先来先服务（FCFS)</li></ol><ul><li>主要从公平的角度考虑。</li><li>用于进程调度时，考虑的是哪个进程先到达就绪队列。</li><li>非抢占式算法。</li></ul><ol start="2"><li>短作业优先（SJF）</li></ol><ul><li>当前到达的运行时间最短的进程。（默认非抢占式）</li><li>抢占式的短作业优先调度算法。</li></ul><p>每当有进程加入就绪队列就需要重新调度。如果新到达的进程剩余时间比当前运行的进程剩余时间更短，则新进程抢占处理机。</p><ol start="3"><li>高响应优先（HRRN)</li></ol><ul><li><p>非抢占式算法</p></li><li><p>每次调度时先计算各个进程的响应比，选择响应比最高的作业/进程为其服务。</p></li><li><p>响应比= （等待时间+要求服务时间）/要求服务时间</p></li></ul><p>tips:这三种算法主要适用于早期的批处理系统。</p><h3 id="2-5-2-新调度算法"><a href="#2-5-2-新调度算法" class="headerlink" title="2.5.2 新调度算法"></a>2.5.2 新调度算法</h3><ol><li>时间片轮转</li></ol><ul><li><p>按照各个进程到达就绪队列的顺序，轮流让各个进程执行一个时间片。若进程未在一个时间片内执行完，则剥夺处理机，将进程重新放到就绪队列队尾重新排队。</p></li><li><p>分时操作系统</p></li><li><p>如果时间片太大，就会退化为先来先服务算法。</p></li><li><p>时间片太小，进程切换太频繁。</p></li><li><p>切换进程的开销不超过1%才是合适的时间片。</p></li></ul><ol start="2"><li>优先级调度算法</li></ol><ul><li><p>为每一个进程设置优先级，选择优先级最高的进程</p></li><li><p>非抢占式</p></li><li><p>抢占式</p></li></ul><p>当前出现的进程优先级最高，那么优先级高的会抢占处理机。</p><ul><li>操作系统会更偏好I/O型进程</li></ul><ol start="3"><li>多级反馈队列调度算法（折中平衡）</li></ol><ul><li>对其他调度算法的折中权衡</li><li>抢占式算法</li></ul><p><img src="/2021/03/15/operate/%E5%A4%9A%E7%BA%A7%E5%8F%8D%E9%A6%88%E9%98%9F%E5%88%97-1615794509250.PNG"></p><ul><li>注意新进程先进入第一级队列。</li><li>优先级高的队列内容会抢占处理机。</li></ul><h3 id="2-6-进程同步和互斥"><a href="#2-6-进程同步和互斥" class="headerlink" title="2.6 进程同步和互斥"></a>2.6 进程同步和互斥</h3><ul><li><p>异步性：各并发执行的进程各自独立、不可预知的速度推进。</p><p><img src="/2021/03/15/operate/%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5-1615794509250.PNG"></p></li><li><p>进程互斥的四个原则</p></li></ul><p><img src="/2021/03/15/operate/%E4%BA%92%E6%96%A5%E7%9A%84%E5%9B%9B%E4%B8%AA%E5%8E%9F%E5%88%99-1615794509250.PNG"></p><ol start="2"><li><p>软件实现方法</p></li><li><p>单标志法</p></li></ol><p>两个进程在访问完临界区后会把适用临界区的权限转交给另一个进程。每个进程进入临界区的权限只能被另一个进程赋予。</p><ul><li>违背了空闲让进原则</li></ul><ol start="2"><li>双标志先检查</li></ol><p>设置布尔型数组，数组中各个元素来标记各进程想进入临界区的意愿。</p><ul><li>违背忙则等待原则</li></ul><p><img src="/2021/03/15/operate/%E5%8F%8C%E6%A0%87%E5%BF%97%E6%A3%80%E6%9F%A5%E6%B3%95-1615794509250.PNG"></p><ol start="3"><li>双标志后检查</li></ol><p><img src="/2021/03/15/operate/%E5%8F%8C%E6%A0%87%E5%BF%97%E5%90%8E%E6%A3%80%E6%9F%A5-1615794509250.PNG"></p><ul><li>违背了“空闲让进”和“有限等待”</li></ul><ol start="4"><li>Peterson算法</li></ol><ul><li>孔融让梨</li></ul><p><img src="/2021/03/15/operate/peterson%E6%A3%80%E6%9F%A5-1615794509250.PNG"></p><h3 id="2-7-信号量机制"><a href="#2-7-信号量机制" class="headerlink" title="2.7 信号量机制"></a>2.7 信号量机制</h3><ul><li>信号量其实就是一个变量，用来表示系统中某种资源的数量。</li></ul><ol><li>整型信号量</li></ol><ul><li><p>表示系统中某种资源的数量。</p></li><li><p>一直等待</p></li></ul><ol start="2"><li>记录型信号量</li></ol><ul><li>解决忙等问题</li></ul><ul><li>信号量机制在“前操作”之后对相应的同步变量执行V操作。</li><li>在“后操作”之前对相应的同步变量执行P操作。</li></ul><h3 id="2-8-管程"><a href="#2-8-管程" class="headerlink" title="2.8 管程"></a>2.8 管程</h3><p>高级的同步机制。因为PV操作还得程序员自己写很复杂，所以管程相当于把这些操作封装成一个类。</p><p>管程可以直接使用这些定义的函数。</p><p>每次只允许一个进程在管程内执行某个内部过程。 </p><h3 id="2-9-死锁"><a href="#2-9-死锁" class="headerlink" title="2.9 死锁"></a>2.9 死锁</h3><p>进程并发执行，各个进程互相等待对方手里的资源，导致被阻塞都无法向前推进。</p><ul><li>饥饿。由于长期得不到想要的资源，某进程无法向前推进的现象。（操作系统分配资源不合理，比如短进程优先算法）。</li><li>死循环。某进程执行过程中一直跳不出来的现象。</li></ul><ol><li>预防死锁。</li></ol><p>破坏死锁产生的四个必要条件中的一个或几个。</p><ul><li>破坏不可剥夺条件</li></ul><p>a 当某个进程请求新的资源得不到满足时，它必须立即释放所有资源，待以后需要时再重新申请。即使某些资源尚未使用完，也需要主动释放，从而破坏了不可剥夺条件。</p><p>可能会造成某个进程之前得工作失效。</p><ul><li>请求和保持条件</li></ul><p>解释：进程已经保持了一个资源，但是提出新的资源请求，而该资源又被其他进程所占有，此时请求进程被阻塞，但是又对自己有的资源保持不放。</p><p>a 可以采用静态分配方法，即进程在运行前申请完它所需要的全部资源，在它的资源未满足前，不让它投入运行。</p><ul><li>破坏循环等待条件</li></ul><p>a 采用顺序资源分配法。首先给系统中的资源编号，规定每个进程必须按照编号递增的顺序请求资源。同类资源（即编号相同的资源）一次申请完。（一个进程只有小的资源才能申请大的资源，有大的资源后不会再申请小的资源）。</p><ol start="2"><li>避免死锁。</li></ol><p>用某种方法防止系统进入不安全状态，从而避免死锁（银行家算法）。</p><ul><li>银行家算法</li></ul><p>如果分配了资源之后，找不到任何一种安全序列，系统进入了不安全状态。</p><p>a 检查此次申请是否超过了之前声明的最大需求数</p><p>b 检查此时系统剩余的可用资源是否还能满足这次请求</p><p>c 试探分配，更改各数据结构</p><p>d 用安全算法检查此次分配是否会导致系统进入不安全状态</p><ol start="3"><li>死锁的检测和避免。</li></ol><p>允许死锁的发生，不过操作系统会负责检测出死锁的发生，然后采取某种措施解除死锁。</p><p><font color="red"> 死锁定理</font>：如果某时刻系统的资源分配图是不可完全简化的，那么此时系统死锁。</p><p>用死锁检测算法简化资源分配图后，还连这边的那些进程就是死锁进程。</p><p>解除死锁的几种方法：</p><ul><li>资源剥夺法。挂起某些死锁进程，并抢占它的资源，将它的资源分配给其他死锁进程。但是应该防止被挂起的进程长时间得不到资源而饥饿。</li><li>撤销进程法。强制撤销部分、甚至全部死锁进程，并剥夺这些进程的资源。这种方式的优点是实现简单，但所付出的代价可能很大。因为有些进程运行了很长时间接近结束。</li><li>进程回退法： 让一个或多个死锁进程回退到足以避免死锁的地步。这就要求系统记录进程的历史信息，设置还原点。</li></ul><h3 id="3-内存管理"><a href="#3-内存管理" class="headerlink" title="3. 内存管理"></a>3. 内存管理</h3><h4 id="3-1-地址转换"><a href="#3-1-地址转换" class="headerlink" title="3.1 地址转换"></a>3.1 地址转换</h4><p>三种装入方式：</p><p>a 绝对装入 编译时产生绝对地址 （编译器负责）</p><p>b 可重定位装入 装入时将逻辑地址转换为物理地址（装入器地址）</p><p>c 动态运行时装入 运行时将逻辑地址转换为物理地址，需设置重定位寄存器 （现代操作系统）</p><h4 id="3-2-内存保护"><a href="#3-2-内存保护" class="headerlink" title="3.2 内存保护"></a>3.2 内存保护</h4><p>一个进程只能访问自己的内存空间。</p><p>两种方式：</p><p>a 设置上下限寄存器</p><p>b 利用重定位寄存器、界地址寄存器（限长寄存器）</p><h4 id="4-3-覆盖与交换"><a href="#4-3-覆盖与交换" class="headerlink" title="4.3 覆盖与交换"></a>4.3 覆盖与交换</h4><p>覆盖技术：</p><p><img src="/2021/03/15/operate/%E8%A6%86%E7%9B%96%E6%8A%80%E6%9C%AF-1615794509250.PNG"></p><p>交换技术：</p><p>内存紧张，内存中某些进程暂时换出外存。 </p><p>对换区和文件区。</p><h4 id="4-4-连续分配管理方式"><a href="#4-4-连续分配管理方式" class="headerlink" title="4.4 连续分配管理方式"></a>4.4 连续分配管理方式</h4><p>a 固定分区</p><p>b 单一连续分配方式</p><ul><li>分区说明表 </li></ul><p><img src="/2021/03/15/operate/%E5%9B%BA%E5%AE%9A%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D-1615794509250.PNG"></p><p>动态分区分配：不会预先划分内存分区，而是在进程装入内存时根据进程的大小动态建立分区。</p><p>使用的数据结构：空闲分区表和空闲分区链。</p><p><font color="red">动态分区分配算法:</font></p><p>概念：在动态分区分配方式中，当有很多个空闲分区都能满足需求时，应该选择哪个分区进行分配？</p><ul><li>首次适应算法(First Fit)</li></ul><p>每次都从最低地址开始查找，找到第一个能满足大小的空闲分区。空闲分区以地址递增的次序排列。每次分配内存时顺序查找空闲分区链，找到大小能满足要求的第一个空闲分区。</p><ul><li>最佳适应算法(Best Fit)</li></ul><p>（为分区大小排了序）为各个进程分配的空间必须是连续的一整片区域。因此为了保证“大进程”到来时能有连续的大片空间，可以尽可能多地留下大片的空闲区，优先使用更小的空闲区。</p><ul><li>最坏适应算法(Worst Fit)</li></ul><p>优先使用最大的连续空闲分区。（为了解决最佳适应算法留下太多难以利用的小碎片）。</p><ul><li>邻近适应算法(Next Fit)</li></ul><p>解决首次适应算法中的问题。</p><p>分区以地址递增顺序排列，每次分配内存从上次查找结束的位置开始查找空闲分区链。</p><p><img src="/2021/03/15/operate/%E5%8A%A8%E6%80%81%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D%E7%AE%97%E6%B3%95-1615794509250.PNG"></p><h4 id="4-5非连续分区分配"><a href="#4-5非连续分区分配" class="headerlink" title="4.5非连续分区分配"></a>4.5非连续分区分配</h4><p>页面和页框是一一对应的关系。页号和页内偏移量。</p><p>页号=逻辑地址/页面长度(取除法的整数部分)</p><p>页内偏移量=逻辑地址%页面长度（取除法的余数部分）</p><p><font color="red">地址转换：</font></p><ol><li>算出逻辑地址对应的页号</li><li>该页号对应页面在内存中的起始地址</li><li>算出偏移量</li><li>物理地址=页面始址+页内偏移量</li></ol><p>基本地址变换机构可以借助进程的页表将逻辑地址转换为物理地址。 页表：页表存储了几个页。每个页叫页表项。</p><p>通常会在系统中设置一个页表寄存器(PTR)，存放<font color="red">页表在内存中的起始地址F和页表长度M</font>。进程未执行时，页表的始址和页表长度放在进程控制块（PCB）中，当进程被调度时，操作系统内核会把它们放在页表寄存器中。</p><p>每个进程有一个页表，页表项由页号和块号组成。</p><p><img src="/2021/03/15/operate/page-1615794509250.PNG"></p><ul><li></li></ul><p><img src="/2021/03/15/operate/%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2-1615794509251.PNG"></p><h3 id="4-6-具有快表的地址变换结构"><a href="#4-6-具有快表的地址变换结构" class="headerlink" title="4.6 具有快表的地址变换结构"></a>4.6 具有快表的地址变换结构</h3><ul><li><p>时间局部性</p><p>不久之后某条指令会再次被执行</p></li><li><p>空间局部性</p><p>一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也很有可能会被访问。（很多数据在内存中都是连续存放的）。</p><p>所以，连续很多次查到的是同一个页表项。</p></li></ul><p>概念： 快表，又称为联想存储器，是一种访问速度比内存快很多的高速缓冲存储器。</p><p><img src="/2021/03/15/operate/%E5%9F%BA%E6%9C%AC%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2%E6%9C%BA%E6%9E%84-1615794509250.PNG"></p><h3 id="4-7-两级页表"><a href="#4-7-两级页表" class="headerlink" title="4.7 两级页表"></a>4.7 两级页表</h3><ul><li>单级页表问题</li></ul><p>某计算机地址按字节寻址，支持32位的逻辑地址，采用分页存储管理，页面大小为4KB，页表项长度为4B。</p><p>4KB=$2^{12}$B，因此页内地址要用12位表示，剩余20位表示页号。</p><p>因此，该系统中用户进程最多有$2^{20}$页，一个进程的页表中，最多会有$2^{20}=1M$个页表项，所以一个页表项最大需要$2^{20}*4B=2^{22}B$，共需要$2^{22} / 2^{12} = 2^{10}$个页框存储该页表。</p><ul><li>页表要连续存放，因此当页表很大，需要占用很多连续页框</li><li>没必要让整个页表常驻内存，因为进程在一段时间内只需要访问某几个特定的页面。</li></ul><p>再分配页目录表。</p><ul><li>代价，增加内存访问次数。</li></ul><p><img src="/2021/03/15/operate/%E4%B8%A4%E7%BA%A7%E9%A1%B5%E8%A1%A8%E5%8E%9F%E7%90%86-1615794509251.PNG"></p><h4 id="4-8-基本分段存储管理"><a href="#4-8-基本分段存储管理" class="headerlink" title="4.8 基本分段存储管理"></a>4.8 基本分段存储管理</h4><p>与“分页”最大的区别就是离散分配时所分配地址空间的基本单位不同。 段表寄存器。</p><p>进程的地址空间：按照程序自身的逻辑关系划分为若干段，每个段都有一个段名，每段从0开始编址。</p><p>内存分配规则：以段为单位进行分配，每个段在内存中占据连续空间，但各段之间可以不相邻。</p><p>每个进程建立一张段映射表，简称“段表”。</p><p><img src="/2021/03/15/operate/%E5%88%86%E6%AE%B5%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86-1615794509251.PNG"></p><p>和分页管理的区别：</p><ul><li>分页每个页面长度相同。分段不同</li><li>分页不需要对页内偏移量越界检查，分段必须要。</li></ul><h3 id="4-9-段页式存储管理"><a href="#4-9-段页式存储管理" class="headerlink" title="4.9 段页式存储管理"></a>4.9 段页式存储管理</h3><p><img src="/2021/03/15/operate/%E6%AE%B5%E9%A1%B5%E5%BC%8F%E5%AD%98%E5%82%A8-1615794509251.PNG"></p><p>一个进程对应一个段表，一个进程可能对应多个页表。</p><p><img src="/2021/03/15/operate/%E6%AE%B5%E9%A1%B5%E5%BC%8F%E5%AD%98%E5%82%A81-1615794509251.PNG"></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token class-name">A</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//分段 1 </span><span class="token operator">&lt;</span> <span class="token number">10</span> 给页内偏移量。 <span class="token class-name">A</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="5-虚拟内存"><a href="#5-虚拟内存" class="headerlink" title="5. 虚拟内存"></a>5. 虚拟内存</h2><p>虚拟内存的最大容量由计算机的地址结构确定的</p><p>虚拟内存的实际容量 = min(内存和外存容量之和，CPU寻址范围)</p><p>特征：</p><ul><li>多次性：无需在作业运行时一次性全部装入内存，而是允许被分成多次调度内存。</li><li>对换性：在作业运行时无需一直常驻内存，而是允许在作业运行过程中，将作业换入、换出。</li><li>虚拟性：逻辑上扩充内存容量。看到的容量远远大于实际容量。</li></ul><p>虚拟内存技术需要建立在<font color="red">离散分配</font>的内存管理方式的基础上。</p><h3 id="5-1-请求分页管理方式"><a href="#5-1-请求分页管理方式" class="headerlink" title="5.1 请求分页管理方式"></a>5.1 请求分页管理方式</h3><p><img src="/2021/03/15/operate/%E9%A1%B5%E8%A1%A8%E6%9C%BA%E5%88%B6-1615794509251.PNG"></p><p><img src="/2021/03/15/operate/%E7%BC%BA%E9%A1%B5%E4%B8%AD%E6%96%AD%E6%9C%BA%E6%9E%84-1615794509251.PNG"></p><p><img src="/2021/03/15/operate/%E7%BC%BA%E9%A1%B5%E4%B8%AD%E6%96%AD-1615794509251.PNG"></p><p>与基本分页的区别</p><p><img src="/2021/03/15/operate/%E4%B8%8E%E5%9F%BA%E6%9C%AC%E5%88%86%E9%A1%B5%E5%8C%BA%E5%88%AB-1615794509251.PNG"></p><p><img src="/2021/03/15/operate/%E6%9F%A5%E6%85%A2%E8%A1%A8%E5%92%8C%E5%BF%AB%E8%A1%A8-1615794509251.PNG"></p><h3 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h3><p>页面的换入换出需要磁盘IO，因此次数要尽可能少。</p><ol><li>最佳置换</li></ol><p>每次选择淘汰的页面将是以后永不使用，或者在最长时间内不再被访问的页面。根据以后的序列的出现次序定替换哪个算法。</p><ol start="2"><li>先进先出</li></ol><p>每次淘汰的页面是最早进入内存的页面。当为进程分配的物理块数增大时，缺页次数不减反增（belady异常）。</p><ol start="3"><li><p>最近最久未使用 LRU算法 </p></li><li><p>时钟置换算法</p></li></ol><p><img src="/2021/03/15/operate/%E6%97%B6%E9%92%9F%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95-1615794509251.PNG"></p><ol start="5"><li>改进型的时钟置换算法</li></ol><p><img src="/2021/03/15/operate/%E6%94%B9%E8%BF%9B%E5%9E%8B%E7%AE%97%E6%B3%95-1615794509251.PNG"></p><h3 id="5-3-页面分配策略"><a href="#5-3-页面分配策略" class="headerlink" title="5.3 页面分配策略"></a>5.3 页面分配策略</h3><p>驻留集：指请求分页存储管理中给进程分配的物理块的集合。</p><p>驻留集有固定分配和可变分配两种分配方式。区别在运行期间可以适当增加和减少。</p><p>局部置换： 发生缺页时只能选进程自己的物理块进行置换。</p><p>全局置换：将系统保留的空闲物理块分配给缺页进程。</p><p>合起来总共有三种分配策略：</p><ol><li>固定分配局部置换（固定分配没有全局置换）。</li><li>可变分配全局置换。系统有一个空闲物理块队列。</li><li>可变分配局部置换。根据缺页的频率动态地增加和减少进程的物理块。</li></ol><ul><li><p>何时调入页面</p><ol><li><p>预调页策略：根据局部性原理，一次调入若干个相邻页面可能比一次调入一个页面更高效。<font color="red">主要用于进程的首次进入</font></p></li><li><p>请求调页策略：程序在运行期间发现缺页时才将所缺页面调入内存。</p></li></ol></li><li><p>何处调入页面</p><p>外存： 对换区和文件区。</p></li></ul><h3 id="5-4-总结"><a href="#5-4-总结" class="headerlink" title="5.4 总结"></a>5.4 总结</h3><h4 id="5-4-1-虚拟地址空间"><a href="#5-4-1-虚拟地址空间" class="headerlink" title="5.4.1 虚拟地址空间"></a>5.4.1 虚拟地址空间</h4><p>在早期的计算机中，程序是直接运行在物理内存上的，那个时候的计算机和程序内存都很小。程序运行时会把其全部加载到内存，只要程序所需的内存不超过计算机剩余内存就不会出现问题。</p><p>但由于程序是可以直接访问物理内存的，这也带来了内存数据的不安全性，轻则程序挂掉，重则操作系统崩溃。</p><p>所以，我们希望程序间的内存数据是安全的互不影响的。同时计算机程序直接运行在物理内存上也导致了内存使用率较低，程序运行内存地址不确定，不同的运行顺序甚至会出错。此时在程序的执行过程中，已经存在着大量在物理内存和硬盘之间的数据交换过程。</p><p>基于以上问题，那我们可以是不是考虑在物理内存之上增加一个中间层，让程序通过虚拟地址去间接的访问物理内存呢。通过虚拟内存，每个进程好像都可以独占内存一样，每个进程看到的内存都是一致的，这称为虚拟地址空间。</p><p>（这种思想在现在也用的很广泛，例如很多优秀的中间层：Nginx、Redis 等等）</p><p>这样只要系统处理好虚拟地址到物理地址的映射关系，就可以保证不同的程序访问不同的内存区域，就可以达到物理内存地址隔离的效果，进而保证数据的安全性。</p><h4 id="5-4-2-分段与分页"><a href="#5-4-2-分段与分页" class="headerlink" title="5.4.2 分段与分页"></a>5.4.2 分段与分页</h4><p>进程是操作系统资源分配的最小单元。操作系统分配给进程的内存空间中包含五种段：数据段、代码段、BSS、堆、栈。</p><ul><li>数据段：存放程序中的静态变量和已初始化且不为零的全局变量。</li><li>代码段：存放可执行文件的操作指令，代码段是只读的，不可进行写操作。这部分的区域在运行前已知其大小。</li><li>BSS 段( Block Started By Symbol)：存放未初始化的全局变量，在变量使用前由运行时初始化为零。</li><li>堆：存放进程运行中被动态分配的内存，其大小不固定。</li><li>栈：存放程序中的临时的局部变量和函数的参数值。</li></ul><p><img src="/2021/03/15/operate/0df091d25f30b7c46fda45d4739ad8b9.png" alt="img"></p><p>那么分段的技术可以解决什么问题呢？</p><blockquote><p>假设程序 A 的虚拟地址空间是 0x00000000<del>0x00000099，映射到的物理地址空间是 0x00000600</del>0x00000699，程序 B 的虚拟地址空间是 0x00000100<del>0x00000199，映射到的物理地址空间是 0x00000300</del>0x00000399。</p><p>假设你手残，在程序 A 中操作了地址 0x00000150，但是此时的地址 0x00000150 是虚拟的，而虚拟化的操作是在操作系统的掌控中的，所以，操作系统有能力判断，这个虚拟地址 0x00000150 是有问题的，然后阻止后续的操作。所以，这里体现出了隔离性。（另一种体现隔离性的方式就是，操作同一个虚拟地址，实际上可能操作的是不同的物理地址）</p></blockquote><p>所以通过分段机制，我们可以更好的控制不同段的属性，这有利于内存的组织安排，可以对不同的属性代码、数据进行更方便的管理。如果是打乱的放在内存中，那么读写属性就很难控制。</p><p>程序运行地址和物理地址的隔离保证了程序内存数据的安全性，也解决了同一个程序运行地址不确定的问题，但是物理内存使用效率低下的问题依然没有得到解决，因为分段机制映射的是一片连续的物理内存。</p><p>于是大佬们又提出了分页的办法。分页其实就是把段空间更细分了一下，粒度更小。此时物理内存被划分为一小块一小块，每块被称为帧(Frame)。分配内存时，帧是分配时的最小单位。</p><p>在分段方法中，每次程序的运行都会被全部加载到虚拟内存中；而分页方法则不同，单位不是整个程序，而是某个“页”，一段虚拟地址空间组成的某一页映射到一段物理地址空间组成的某一页。它将少部分要运行的代码加载到虚拟内存中，通过映射在物理内存中运行，从而提高了物理内存的使用率。</p><p><img src="/2021/03/15/operate/e542f644edefb86a8014fe7d17690496.jpeg" alt="img"></p><p>为了方便 CPU 高效执行管理物理内存，每一次都需要从虚拟内存中拿一个页的代码放到物理内存。虚拟内存页有三种状态，分别是未分配、已缓存和未缓存状态。</p><p><strong>未分配：</strong>指的是未被操作系统分配或者创建的，未分配的虚拟页不存在任何数据和代码与它们关联，因此不占用磁盘资源；</p><p><strong>已缓存：</strong>表示的是物理内存中已经为该部分分配的，存在虚拟内存和物理内存映射关系的；</p><p><strong>未缓存：</strong>指的是已经加载到虚拟内存中的，但是未在物理内存中建立映射关系的。</p><h4 id="5-4-3-页表"><a href="#5-4-3-页表" class="headerlink" title="5.4.3 页表"></a>5.4.3 页表</h4><p>虚拟内存中的一些虚拟页是要缓存在物理内存中才能被执行的，因此操作系统存在一种机制用来判断某个虚拟页是否被缓存在物理内存中，还需要知道这个虚拟页存放在磁盘上的哪个位置，从而在物理内存中选择空闲页或者更新缓存页，并将需要的虚拟页从磁盘复制到物理内存中。这些功能是由软硬件结合完成的，其存放在物理内存中一个叫页表的数据结构中。</p><p>虚拟内存和物理内存的映射通过页表(page table)来实现。每个页表实际上是一个数组，数组中的每个元素称为页表项(PTE, page table entry)，每个页表项负责把虚拟页映射到物理页上。在 物理内存中，每个进程都有自己的页表。</p><p><img src="/2021/03/15/operate/62f59325912379a00cea940552d8ba75.png" alt="img"></p><p>因为有一个表可以查询，就会遇到两种情况，一种是命中(Page Hit)，另一种则是未命中(Page Fault)。</p><p>命中的时候，即访问到页表中蓝色条目的地址时，因为在 DRAM 中有对应的数据，可以直接访问。</p><p>不命中的时候，即访问到 page table 中灰色条目的时候，因为在 DRAM 中并没有对应的数据，所以需要执行缺页置换。</p><p>在上图中，四个虚拟页 VP1 , VP2, VP4 , VP7 是被缓存在物理内存中。两个虚拟页 VP0, VP5 还未被分配。但是剩下的虚拟页 VP3 ,VP6 已经被分配了，但是还没有缓存到物理内存中去执行。</p><h4 id="5-4-4-总结"><a href="#5-4-4-总结" class="headerlink" title="5.4.4 总结"></a>5.4.4 总结</h4><p>通过虚拟地址空间和页表的回顾，现在大家应该明白为什么要引入虚拟内存了吧。</p><p>虚拟内存是计算机系统内存管理的一种技术，虚拟地址空间构成虚拟内存。它使得应用程序认为它拥有连续可用的内存（一个连续完整的地址空间），而实际上，它通常是被分隔成多个物理内存碎片。还有部分暂时存储在外部磁盘存储器上（Swap），在需要时进行数据交换。</p><p><strong>虚拟内存不只是用磁盘空间来扩展物理内存</strong> 的意思——这只是扩充内存级别以使其包含硬盘驱动器而已。把内存扩展到磁盘只是使用虚拟内存技术的一个结果。除了扩展内存空间，虚拟内存技术还有隔离运行内存和确定运行地址的作用。</p><p>使用虚拟内存主要是基于以下三个方面考虑，也就是说虚拟内存主要有三个作用：</p><p>作为缓存工具，提高内存利用率：使用 DRAM 当做部分的虚拟地址空间的缓存（虚拟内存就是存储在磁盘上的 N 个连续字节的数组，数组的部分内容会缓存在 DRAM 中）。扩大了内存空间，当发生缺页异常时，将会把内存和磁盘中的数据进行置换。</p><p>作为内存管理工具，简化内存管理：每个进程都有统一的线性地址空间（但实际上在物理内存中可能是间隔、支离破碎的），在内存分配中没有太多限制，每个虚拟页都可以被映射到任何的物理页上。这样也带来一个好处，如果两个进程间有共享的数据，那么直接指向同一个物理页即可。</p><p>作为内存保护工具，隔离地址空间：进程之间不会相互影响；用户程序不能访问内核信息和代码。页表中的每个条目的高位部分是表示权限的位，MMU 可以通过检查这些位来进行权限控制（读、写、执行）。</p><h2 id="6-文件管理"><a href="#6-文件管理" class="headerlink" title="6. 文件管理"></a>6. 文件管理</h2><ul><li><p>文件如何存储</p></li><li><p>文件内部应该如何组织</p></li><li><p>文件之间应该如何组织</p></li></ul><h3 id="6-1-文件的逻辑结构"><a href="#6-1-文件的逻辑结构" class="headerlink" title="6.1 文件的逻辑结构"></a>6.1 文件的逻辑结构</h3><ul><li><p>无结构文件</p><p>文件内部的数据是一系列二进制文件流或字符流组成。又称为”流式文件“。如windows操作系统的.txt文件。</p></li><li><p>有结构文件</p><ul><li>顺序文件<ul><li>文件中的记录一个接一个地顺序排列（逻辑上），记录可以是定长的或可变长的。各个记录在物理上可以顺序存储或链实存储。</li></ul></li><li>索引文件</li><li>索引顺序文件</li></ul></li></ul><p>记录式文件，由一组相似的记录组成，比如excel表中的学生信息。</p><h3 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a><font color="blue">内存管理</font></h3><p>简述进程切换的流程<br>涉及公司：阿里云实习生</p><p>如果想要从A进程切换到 B 进程，必定要先从用户态切换到内核态，因为这个切换的工作你不能让用户进程去实现，不然当 CPU 在用户进程手上的时候，他可以选择一直执行，不让出 CPU，这肯定是不允许的。所以操作系统需要先挂起正在占用 CPU 的 A 进程，才能切换到 B 进程。</p><p>由于从用户态切换到内核态的时候，CPU 是在用户进程手中，所以这个是通过硬中断来实现的。在从用户态切换到内核态之前需要保存用户进程的上下文，以便下一次执行时可以继续之前的工作。</p><p>这个上下文就是进程执行的环境，包括所有的寄存器变量，进程打开的文件、内存信息等。一个进程的上下文可以分为用户级上下文，寄存器上下文，系统级上下文。用户级上下文存储的是用户进程的内存数据以及堆栈数据等；寄存器上下文是一些通用寄存器；系统级上下文是内核栈、PCB (进程控制块)等。</p><h3 id="进程在地址空间中会划分为哪些区域"><a href="#进程在地址空间中会划分为哪些区域" class="headerlink" title="进程在地址空间中会划分为哪些区域"></a><font color="blue">进程在地址空间中会划分为哪些区域</font></h3><p>涉及公司：阿里云实习生</p><p>这个问题在我之前的工作中其实还是有所涉及的，我来简单讲一下把文件加载到内存中的一个过程，以 Window 平台为例吧，PE 文件我比较熟，在 PE 文件中，有一个叫节的概念，节是PE文件中存放代码和数据的基本单元，用以存储不同类型的数据，比如 data 节、code 节等，一个节的所有原始数据必须加载到连续的内存空间里，这也就造成了在虚拟地址空间中的区块划分。</p><p>在虚拟地址空间中会按照节划分为代码段、数据段、未初始化的数据段以及堆栈这些区块。</p><h3 id="栈与堆有什么区别"><a href="#栈与堆有什么区别" class="headerlink" title="栈与堆有什么区别"></a><font color="blue">栈与堆有什么区别</font></h3><p>涉及公司：阿里云实习生、拼多多实习生</p><p>我们常说堆栈堆栈，其实堆栈是两个不同的概念，最直观的理解，堆是由用户来控制的，我们可以使用 malloc 这种命令来在堆中申请内存，而栈是由操作系统控制的，在栈中存储的是这个进程的局部变量等，比如我们用 malloc 来申请一块内存，内存本身是在堆中开辟的，而指向这块内存的指针存储在栈中。</p><h3 id="操作系统为什么分内核态和用户态，这两者之间如何切换"><a href="#操作系统为什么分内核态和用户态，这两者之间如何切换" class="headerlink" title="操作系统为什么分内核态和用户态，这两者之间如何切换"></a><font color="blue">操作系统为什么分内核态和用户态，这两者之间如何切换</font></h3><p>涉及公司：拼多多实习生</p><p>因为在CPU的指令中，有一些是非常危险的，比如清理内存、设置时钟等，如果所有的程序都能使用，就可能造成系统的崩溃，所以，CPU 将指令分为特权指令和非特权指令，对于那些危险的指令，只允许操作系统使用。CPU 的特权级别有四级，从 Ring0 到 Ring3，正常使用时一般只有两级，即用户态的 Ring3 和内核态的 Ring0。Ring3 状态不能访问 Ring0 的地址空间，包括代码和数据。</p><h3 id="用户态切换到内核态的三种方式"><a href="#用户态切换到内核态的三种方式" class="headerlink" title="用户态切换到内核态的三种方式"></a><font color="blue">用户态切换到内核态的三种方式</font></h3><p>系统调用（系统调用是通过软中断实现的）<br>中断（硬）<br>异常</p><h3 id="malloc的实现机制"><a href="#malloc的实现机制" class="headerlink" title="malloc的实现机制"></a><font color="blue">malloc的实现机制</font></h3><p>涉及公司：阿里云实习生</p><p>malloc 本质上是维护了一个内存空闲链表，每次我们调用 malloc 申请空间的时候，链表就会从头开始遍历，来寻找一个合适的空闲内存空间，然后把这个空间给分割开，一步步分配给用户，另一部分继续标注为空闲，而当没有足够大的空闲块时，malloc 就会通过系统调用来申请更多的内存块。而我们调用 free 来释放内存块的时候，该内存块就会回到链表中，并且相邻的内存块会被合并。</p><p>搜索空闲块的算法主要有首次适配、下一次适配、最佳适配，首次适配即第一次找到足够大的内存块就分配，但这样会产生很多的内存碎片，也因此第二次适配被提出来缓解这个问题。另一个极端则是最佳适配，即找到一块刚好大于我们所需内存大小的内存块，这种做法一方面耗时长，另一方面也会产生一些极小的内存碎片。<br>这两种思路可以看出是在性能和空间利用率上寻找一个平衡点，在工程中实际上有很多这种没有完美解决方案，只能寻找平衡的问题。</p><h3 id="虚拟地址怎么映射到物理地址"><a href="#虚拟地址怎么映射到物理地址" class="headerlink" title="虚拟地址怎么映射到物理地址"></a><font color="blue">虚拟地址怎么映射到物理地址</font></h3><p>涉及公司：阿里云实习生、腾讯实习生</p><p>虚拟地址的构成为页目录索引 (10位) +页表索引 (10位) +表内偏移 (12位)</p><p>以 win32 系统为例，页目录和页表都为 1024 个，页大小为 4KB，一共是 4G 的虚拟内存空间</p><p>而从虚拟地址映射到物理地址实际上就是通过页目录和页表的索引找到内存页。</p><p>在页表项中有一位标志位，用来标识包含此数据的页是否在物理内存中，如果在的话，就直接做地址映射，否则，抛出缺页中断，操作系统会把次数据页调入内存。</p><h3 id="socket-编程中怎么处理并发请求"><a href="#socket-编程中怎么处理并发请求" class="headerlink" title="socket 编程中怎么处理并发请求"></a><font color="blue">socket 编程中怎么处理并发请求</font></h3><p>涉及公司：阿里云实习生、腾讯实习生</p><p>对多线程的处理与单线程不同的位置在于各个不同的进程可能会访问相同的资源，如果是对资源进行修改的话，就需要用到锁</p><h3 id="简述-IO-多路复用"><a href="#简述-IO-多路复用" class="headerlink" title="简述 IO 多路复用"></a><font color="blue">简述 IO 多路复用</font></h3><p>涉及公司：阿里云实习生、腾讯实习生</p><p>Linux的IO访问通常是先将数据拷贝到操作系统的内核缓冲区，然后再从内核缓冲区拷贝到应用程序的地址空间。在这两个阶段中，有不同的 IO 方式，主要分为阻塞 IO、非阻塞 IO、异步 IO 以及 IO 多路复用。</p><p>阻塞 IO 即当数据还未准备好，也就是数据还在操作系统的内核缓存区时，用户进程就会一直阻塞，等待数据从操作系统内核缓冲区拷贝到应用程序的地址空间。阻塞IO在这两个阶段都是阻塞的。</p><p>非阻塞 IO 则是如果数据还没准备好，操作系统会给应用程序返回一个 error，并不阻塞应用程序，而一般应用程序会持续询问内核数据是否准备好，所以从另一个角度来说也是阻塞的。</p><p>而异步 IO 才是真正的不阻塞，当用户程序发起read后，操作系统会立即进行回复，这样用户程序就可以去做其他事情，当数据被拷贝到用户程序的地中空间后，操作系统会给用户程序发一个信号，而用户程序可以采用回调函数的方式对这个信号进行响应。</p><p>IO 多路复用则是允许一个程序同时等待多个文件描述符，当任意一个文件描述符就绪，select 函数就会返回，当然 IO 多路复用在本质上还术语阻塞IO，只不过可以同时进行多个 IO 操作。</p><p>Linux 的 IO 多路复用机制中有 select、poll、epoll 三种，<br>select 和 poll 的时间复杂度都是 O(n),因为他们都是在对IO列表进行轮询，不同点在于 select 能监视的文件描述符有上限，一般为 1024，当然这个是在 Linux 内核中进行的宏定义，是可以修改的，而 poll 是基于链表来存储的，所以没有这个上限。<br>而 epoll 是基于事件驱动的，所以不需要轮询，epoll 会把事件和每一个IO流对应起来。并且 epoll 是通过一块共享内存来实现内核空间和用户空间的通信的，比起 select 和 poll 的大量数据拷贝效率更高。<br>不过 lect 的优点在于兼容不同的操作系统，而 poll 和 epoll 都只能在 linux 上使用。</p><p><font color="blue">简述进程通信的各种方法</font><br>涉及公司：腾讯实习生</p><p>进程间通信的方式通常分为管道、系统 IPC、套接字三种，其中管道有无名管道、命名管道，系统 IPC 有消息队列、信号、共享内存</p><p>无名管道的本质是在内核缓冲区的环形队列，每次读取数据后缓冲区都会移动，并且无名管道只能在有亲缘关系的进程间使用<br>命名管道则以文件的形式存在，由于有一个路径名，使用没有亲缘关系的进程间也可以使用命名管道<br>消息队列是存放在内核中的消息链表，具有特定的格式，支持多种数据类型，且允许多个进程进行读写<br>信号是软件层次上对中断机制的一种模拟，是一种异步通信方式，并且信号可以在用户空间进程和内核之间直接交互<br>共享内存顾名思义就是两个进行对同一块内存进行读写，是最快的 IPC 形式，但不适合大量的数据传输<br>Socket 是对 TCP/IP 协议族的封装，不仅可以用于本机上的进程间通信，更多的被用于网络通信中<br>进程线程管理<br>进程的互斥与同步<br>在操作系统中，进程是占有资源的最小单位，对于那种只能同时被一个进程持有的资源我们称为临界资源，对于临界资源的访问，必须是互斥的。（对于；临界资源的访问过程分为：进入区、临界区、退出区、剩余区）</p><p>而进程之间访问临界资源时可以构成同步与互斥两种关系，同步即两个进程的资源访问必须是先后关系，比如经典的生产者消费者问题，读者写着问题。而互斥则是两种在进行资源抢到，比如购票问题。</p><p>通常在软件层面可以使用替换算法来实现，即每个进程持有一个标志，每次当使用资源时则将自己的标志与资源的标志互换，如果在互换的过程中发现自己获得的标志是正在使用的状态，则在此循环等待。这种方法的缺点在于每个进程都需要进行循环等待，比较低效。所以一般是通过硬件层面的信号量即PV操作来实现进程的临界资源管理。</p><p>死锁的解决方法<br>涉及公司：阿里云实习生</p><p>死锁的产生是在这样一种环境中：比如我们有两个进程AB，他们都需要资源1和资源2，当进程A持有资源1，进线程B持有资源2的时候，他们都需要对方手上的进程，而一般操作系统又不允许抢占，这个时候就发生了死锁。</p><p>从这个例子中其实可以总结出死锁的几个必要条件：</p><p>1.一个资源只能被一个进程所占有，不能共享<br>2.一个线程请求资源失败时，它会等待而不是释放<br>3.一个线程在释放资源之前其他进程不能抢夺资源<br>4.循环等待<br>从死锁产生的原因未明可以设计一些方法去避免死锁的发生</p><p>1.静态分配资源，一开始就把一个进程所需的全部资源都分配给它，但这样会降低资源的使用效率<br>2.允许抢占，需要设置进程的不同优先级，高优先级的进程可以抢占低优先级的进程的资源<br>3.把资源进行编号，申请资源必须按照资源的编号顺序来申请<br>如果死锁已经发生了，就需要去解开死锁，其本质思想就是分配资源打破循环等待</p><p>1.可以运行抢占，从一个或多个进程中抢出资源来给其他进程<br>2.也可以终止一些进程，来达到释放资源的目的<br>进程调度算法<br>先来先服务调度算法<br>对长作业比较有利，但对短作业不利<br>时间片轮转调度法<br>每个进程只能运行一个时间片<br>时间片的大小对系统性能的影响很大，时间片过大就和先来先服务算法一样，时间片过小会导致进行切换开销大<br>短作业优先调度算法<br>对长作业不利，不能保证紧迫性作业（进程）被及时处理<br>最短剩余时间优先<br>允许抢占，总是选择预期剩余时间最短的进程<br>高响应比优先调度算法<br>R=(w+s)/s （R 为响应比，w 为等待处理的时间，s 为预计的服务时间），选择 R 最大的进行执行<br>优先级调度算法<br>进程优先级可以分为静态优先级和动态优先级<br>多级反馈队列调度算法<br>分为多个队列，每个队列中按时间片轮转调度算法来进行进程调度，每一级的队列时间片大小也不一样，如果进行在第一个队列的时间片内没有完成，就会进入第二个队列，以此类推，只有当第一个队列为空才执行第二个队列的进行<br>短作业有限且长作业不会太长时间不被处理<br>磁盘调度算法<br>先来先服务算法（FCFS）<br>根据进程请求访问磁盘的先后次序进行调度<br>优点是公平、简单<br>缺点是吞吐量低，寻道时间长<br>最短寻道时间优先算法（SSTF）<br>访问与当前磁头所在的磁道距离最近的磁道<br>优点是可以得到比较好的吞吐量<br>缺点是对内外边缘磁道的请求将会被无限延迟<br>扫描算法（SCAN）电梯调度算法<br>优先考虑磁头当前的移动方向，再考虑欲访问的磁道与当前磁道的距离<br>优点是避免了饥饿现象的出现<br>缺点是两侧磁道被访问的频率仍低于中间磁道<br>循环扫描算法（CSCAN）<br>在SCAN算法的基础上，磁头只单向移动，当磁头移到最外的被访问磁道时，磁头立即返回到最里的欲访磁道<br>优点是访问请求均匀分布<br>页面调度算法<br>先进先出调度算法（FIFO，First In First Out）<br>最近最少使用算法(LFU, Least Frequently Used)<br>最近最久未使用算法（LRU，Least Recently Used）<br>时钟置换算法——为每一页设置访问位和修改位，将内存中所有页面通过连接指针接成循环队列，当页面被访问时访问位置 1，被修改则修改位置 1，每次淘汰时，从指针当前位置开始循环遍历，第一次寻找访问位和修改位都为0的页面，如果没有则将扫描过的节点访问位为 1 的置为 0，找到第一个访问位为 0 的将其淘汰。这个算法的原则就的在LRU的基础上偏向于淘汰未被修改的页面。<br>最佳置换算法——理想算法，找一个未来最长时间才会被访问的页面进行淘汰。</p><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>UNIX中进程将内存划分为三部分:<code>text segment 文本区</code>、<code>data segment 数据区</code>、<code>stack segment 栈区域</code>（私有变量）。数据向上增长，堆栈向下增长。</p><p><img src="/2021/03/15/operate/%E8%BF%9B%E7%A8%8B%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D-1615794509251.PNG"></p><p><strong>进程是操作系统进行资源分配的基本单位，而线程是操作系统进行调度的基本单位</strong>，即CPU分配时间的单位 。</p><p>——————————————</p><h1 id="operate2"><a href="#operate2" class="headerlink" title="operate2"></a>operate2</h1><h2 id="操作系统的四大特性"><a href="#操作系统的四大特性" class="headerlink" title="操作系统的四大特性"></a>操作系统的四大特性</h2><ul><li>并发：同一段时间内多个程序执行</li><li>共享：系统中的资源可以被内存中多个并发执行的进线程共同使用</li><li>虚拟：通过时分复用（如分时系统）以及空分复用（如虚拟内存）技术实现把一个物理实体虚拟为多个</li><li>异步：系统中的进程是以走走停停的方式执行的，且以一种不可预知的速度推进</li></ul><h2 id="操作系统基本功能"><a href="#操作系统基本功能" class="headerlink" title="操作系统基本功能"></a>操作系统基本功能</h2><ul><li><p>进程管理</p><p>：</p><ul><li>进程控制、进程同步、进程通信、死锁处理、处理机调度等</li></ul></li><li><p>内存管理</p><p>：</p><ul><li>内存分配、地址映射、内存保护与共享、虚拟内存等</li></ul></li><li><p>文件管理</p><p>：</p><ul><li>文件存储空间的管理、目录管理、文件读写管理和保护等</li></ul></li><li><p>设备管理</p><p>：</p><ul><li>完成用户的 I/O 请求，方便用户使用各种设备，并提高设备的利用率。主要包括缓冲管理、设备分配、设备处理、虛拟设备等</li></ul></li></ul><h2 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h2><ul><li>CPU（中央处理器）</li><li>进程是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础</li><li><strong>资源分配的最小单位是进程，而CPU调度的最小单位是时间片</strong></li><li>系统为进程分配资源，不对线程分配资源</li></ul><h3 id="CPU调度"><a href="#CPU调度" class="headerlink" title="CPU调度"></a>CPU调度</h3><ul><li>高级调度（作业调度）：<ul><li>多道批处理操作系统中，从输入系统的一批作业中按照预定的调度策略挑选若干作业进入内存，为其分配资源并创建对应的作业用户进程</li><li>作业是任务实体，进程是完成任务的执行实体。<strong>作业的概念多用于批处理操作系统，而进程用于各种多道程序设计系统</strong></li></ul></li><li>中级调度<ul><li>根据内存资源情况决定内存中所能容纳的进程数目，并完成外存和内存中的进程对换工作（挂起）。起到短期均衡系统负载的作用</li></ul></li><li>低级调度（进程调度/线程调度）<ul><li><strong>根据某种原则决定就绪队列中哪个进程/线程获得处理器，并将处理器出让给它使用</strong></li></ul></li></ul><h3 id="Q：某一进程CPU使用率-50-是什么意思？"><a href="#Q：某一进程CPU使用率-50-是什么意思？" class="headerlink" title="Q：某一进程CPU使用率 50% 是什么意思？"></a>Q：某一进程CPU使用率 50% 是什么意思？</h3><ul><li>CPU使用率是来描述CPU的使用情况的，表明了一段时间内CPU被占用的情况。使用率越高，说明你的机器在这个时间上运行了很多程序，反之较少。使用率的高低与你的CPU强弱有直接关系。</li><li>CPU的占用率，一般指的就是对时间片的占用情况，CPU：50% 说明 CPU 有一半的时间在运行，一半的时间在休息（100MS 中50MS被进程占用，50MS处于空闲状态）</li></ul><h3 id="Q：如何让CPU使用率固定在50-【仅限于单核CPU】"><a href="#Q：如何让CPU使用率固定在50-【仅限于单核CPU】" class="headerlink" title="Q：如何让CPU使用率固定在50%【仅限于单核CPU】"></a>Q：如何让CPU使用率固定在50%【仅限于单核CPU】</h3><ul><li><p>CPU的占有率是由进程的忙和空闲来决定的，即 rate=(busy_time)/(busy_time+idle_time);</p></li><li><p>让CPU使用率固定在50%，只要让计算机有一半的时间在运行，一半的时间在休息就可以了。</p></li><li><p>busy可以用循环（这个循环用空循环，以便好控制），idle可以用sleep</p></li><li><p>比如先让任务管理器的cpu使用率始终保持在50%左右，那么在一个主循环中，让空循环和sleep运行同样的一小段时间。sleep的时间好搞，空循环的怎么办呢？可以在运行的时候设定空循环的运行时间</p><p><code>public</code> <code>static</code> <code>void</code> <code>main(String args[]) ``throws</code> <code>InterruptedException{``   ``int</code> <code>busyTime = ``10``;``   ``int</code> <code>idleTime = busyTime;``   ``//设定空循环的运行时间``   ``while``(``true``){``     ``long</code> <code>startTime = System.currentTimeMillis();``     ``//busy loop:``     ``while``((System.currentTimeMillis()-startTime)&lt;=busyTime)``       ``;``     ``Thread.sleep(idleTime);``   ``}`` ``}</code></p></li></ul><h2 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h2><p>内存的内部是由各种 IC 电路组成的，它的种类很庞大，但是其主要分为三种存储器：</p><ul><li>随机存储器（RAM）：内存中最重要的一种，表示既可以从中读取数据，也可以写入数据。当机器关闭时，内存中的信息会丢失</li><li>只读存储器（ROM）：ROM 一般只能用于数据的读取，不能写入数据，但是当机器停电时，这些数据不会丢失</li><li>高速缓存（Cache）：Cache 也是我们经常见到的，它分为一级缓存（L1 Cache）、二级缓存（L2 Cache）、三级缓存（L3 Cache）这些数据，它位于内存和 CPU 之间，是一个读写速度比内存更快的存储器。当 CPU 向内存写入数据时，这些数据也会被写入高速缓存中。当 CPU 需要读取数据时，会直接从高速缓存中直接读取，当然，如需要的数据在Cache中没有，CPU会再去读取内存中的数据.</li></ul><h3 id="内存管理机制"><a href="#内存管理机制" class="headerlink" title="内存管理机制"></a>内存管理机制</h3><ul><li><p>操作系统的内存管理主要负责<strong>内存的分配与回收</strong>（malloc 函数：申请内存，free 函数：释放内存），另外地址转换也就是<strong>将逻辑地址转换成相应的物理地址</strong>等功能也是操作系统内存管理做的事情</p></li><li><p>连续分配管理方式</p><p>：连续分配管理方式是指为一个用户程序分配一个连续的内存空间，常见的如</p><p>块式管理</p><ul><li><strong>块式管理</strong>：将内存分为几个固定大小的块，每个块中只包含一个进程。如果程序运行需要内存的话，操作系统就分配给它一块，如果程序运行只需要很小的空间的话，分配的这块内存很大一部分几乎被浪费了。这些在每个块中未被利用的空间，我们称之为碎片</li></ul></li><li><p>非连续分配管理方式</p><p>：非连续分配管理方式允许一个程序使用的内存分布在离散或者说不相邻的内存中</p><ul><li><strong>页式管理</strong> ：把主存分为大小相等且固定的一页一页的形式，页较小，相对相比于块式管理的划分力度更大，提高了内存利用率，减少了碎片。<strong>页式管理通过页表对应逻辑地址和物理地址</strong></li><li><strong>段式管理</strong> ： 页式管理虽然提高了内存利用率，但是页式管理其中的页实际并无任何实际意义。 段式管理把主存分为一段段的，每一段的空间又要比一页的空间小很多 。但是，最重要的是<strong>段是有实际意义的，每个段定义了一组逻辑信息</strong>，例如,有主程序段 MAIN、子程序段 X、数据段 D 及栈段 S 等。 <strong>段式管理通过段表对应逻辑地址和物理地址</strong></li><li><strong>段页式管理机制</strong> ：段页式管理机制结合了段式管理和页式管理的优点。简单来说段页式管理机制就是<strong>把主存先分成若干段，每个段又分成若干页</strong>，也就是说<strong>段页式管理机制中段与段之间以及段的内部的都是离散的</strong>。</li></ul></li></ul><h4 id="分页和分段共同点和区别"><a href="#分页和分段共同点和区别" class="headerlink" title="分页和分段共同点和区别"></a>分页和分段共同点和区别</h4><ul><li><p>共同点</p><p>：</p><ol><li>分页机制和分段机制都是为了提高内存利用率，较少内存碎片</li><li><strong>页和段都是离散存储的</strong>，所以两者都是离散分配内存的方式。但是，<strong>每个页和段中的内存是连续的</strong></li></ol></li><li><p>分段和分页的不同</p><p>：</p><ol><li><strong>目的不同</strong>：<strong>分页是由于系统管理的需要</strong>而不是用户的需要，它是信息的物理单位；<strong>分段的目的是为了能更好地满足用户的需要</strong>，它是信息的逻辑单位，它含有一组其意义相对完整的信息；</li><li><strong>大小</strong>不同：<strong>页的大小固定且由系统决定</strong>；而<strong>段的长度却不固定，由其所完成的功能决定</strong>；</li><li>地址空间不同： 段向用户提供二维地址空间；页向用户提供的是一维地址空间；</li><li>信息共享：段是信息的逻辑单位，便于存储保护和信息的共享，页的保护和共享受到限制；</li><li><strong>内存碎片</strong>：页式存储管理的优点是没有外碎片（因为页的大小固定），但会产生内碎片（一个页可能填充不满）；而段式管理的优点是没有内碎片（因为段大小可变，改变段大小来消除内碎片）。但段换入换出时，会产生外碎片（比如4k的段换5k的段，会产生1k的外碎片）。</li></ol></li></ul><h4 id="基本分页储存管理方式"><a href="#基本分页储存管理方式" class="headerlink" title="基本分页储存管理方式"></a>基本分页储存管理方式</h4><ul><li>在分页内存管理中，很重要的两点是：<strong>1. 虚拟地址到物理地址的转换要快【快表】；2. 解决虚拟地址空间大，页表也会很大的问题【多级分页】</strong></li><li>因为程序数据存储在不同的页面中，而页面又离散的分布在内存中，因此需要一个<strong>页表来记录逻辑地址和实际存储地址之间的映射关系</strong>，<strong>以实现从页号到物理块号的映射</strong></li><li>由于页表也是存储在内存中的，因此访问分页系统中内存数据需要两次的内存访问【一次是从内存中访问页表，从中找到指定的物理块号，加上页内偏移得到实际物理地址；第二次就是根据第一次得到的物理地址访问内存取出数据】</li><li><strong>为了减少两次访问内存导致的效率影响，分页管理中引入了快表机制</strong>，当要访问内存数据的时候，首先将页号在快表中查询，如果查找到说明要访问的页表项在快表中，那么直接从快表中读取相应的物理块号；如果没有找到，那么访问内存中的页表，从页表中得到物理地址，同时将页表中的该映射表项添加到快表中</li><li><strong>在某些计算机中如果内存的逻辑地址很大，将会导致程序的页表项会很多，而页表在内存中是连续存放的，所以相应的就需要较大的连续内存空间</strong>。为了解决这个问题，可以采用<strong>两级页表或者多级页表的方法</strong></li><li>其中外层页表一次性调入内存且连续存放，内层页表离散存放。相应的访问内存页表的时候需要一次地址变换，访问逻辑地址对应的物理地址的时候也需要一次地址变换，而且一共需要访问内存3次才可以读取一次数据</li></ul><h4 id="基本分段储存管理方式"><a href="#基本分段储存管理方式" class="headerlink" title="基本分段储存管理方式"></a>基本分段储存管理方式</h4><ul><li>分页是为了提高内存利用率，而分段是为了满足程序员在编写代码的时候的一些逻辑需求【比如数据共享，数据保护，动态链接等】</li><li><strong>分段内存管理当中，地址是二维的，一维是段号，一维是段内地址</strong>；其中每个段的长度是不一样的，而且每个段内部都是从0开始编址的</li><li>由于分段管理中，<strong>每个段内部是连续内存分配，但是段和段之间是离散分配的</strong>，因此也存在一个逻辑地址到物理地址的映射关系，相应的就是<strong>段表机制</strong>。段表中的每一个表项记录了该段在内存中的起始地址和该段的长度。段表可以放在内存中也可以放在寄存器中。</li><li>访问内存的时候根据段号和段表项的长度计算当前访问段在段表中的位置，然后访问段表，得到该段的物理地址，根据该物理地址以及段内偏移量就可以得到需要访问的内存。由于也是两次内存访问，所以分段管理中同样引入了<a href="https://www.nowcoder.com/jump/super-jump/word?word=%E8%81%94%E6%83%B3">联想</a>寄存器。</li></ul><h4 id="段页式内存管理"><a href="#段页式内存管理" class="headerlink" title="段页式内存管理"></a>段页式内存管理</h4><ul><li><p><strong>页式存储管理能有效地提高内存利用率，而分段存储管理能反映程序的逻辑结构并有利于段的共享</strong></p></li><li><p>段页式管理就是将程序分为多个逻辑段，在每个段里面又进行分页，即将分段和分页组合起来使用。</p></li><li><p>为了实现地址变换，系统为每个进程建立一张段表，而每个分段有一张页表（在一个进程中，段表只有一个，而页表可能有多个）</p></li><li><p>在进行地址变换时，<strong>首先通过段表查到页表起始地址，然后通过页表找到页帧号，最后形成物理地址</strong>。如图所示，<strong>进行一次访问实际需要至少三次访问主存</strong>，这里同样可以使用快表以加快查找速度，其关键字由段号、页号组成，值是对应的页帧号和保护码。</p></li><li><p>三次内存访问</p><p>：</p><ol><li>访问内存中的段表查到页表的起始地址</li><li>访问内存中的页表找到页帧号，形成物理地址</li><li>得到物理地址后，再一次访问内存，存取指令或者数据</li></ol></li></ul><h4 id="Q：页式存储，段式存储，段页式存储，引入快表，访问内存次数"><a href="#Q：页式存储，段式存储，段页式存储，引入快表，访问内存次数" class="headerlink" title="Q：页式存储，段式存储，段页式存储，引入快表，访问内存次数"></a>Q：页式存储，段式存储，段页式存储，引入快表，访问内存次数</h4><ul><li><p>页式存储（2次）</p><ol><li>访问内存中的页表，利用逻辑地址中的页号查找到页帧号，与逻辑地址中的页内偏移拼接形成物理地址；</li><li>得到物理地址后，再一次访问内存，存取指令或者数据。</li></ol></li><li><p><strong>段式存储（2次）</strong>：同页式存储</p></li><li><p>段页式存储（3次）</p><ol><li>访问内存中的段表查到页表的起始地址</li><li>访问内存中的页表找到页帧号，形成物理地址</li><li>得到物理地址后，再一次访问内存，存取指令或者数据</li></ol></li><li><p><strong>多级页表</strong>：若页表划分为N级，则需要访问内存N+1次。若系统有快表，则在快表命中时，只需访问1次内存即可</p></li><li><p>引入快表</p><p>：</p><ul><li>因为把页表放在内存中，至少需要访问两次内存才能存取一条指令或者数据（一次得到物理地址地址，一次存取），比较慢；因此在地址变换机构中增设了一个具有并行查找能力的高速缓冲寄存器—— 快表（全局只有一个，不在内存中！！！），用来存放当前访问的若干页表项（比较小，只能存放部分页表项）</li><li><strong>若快表命中</strong>，则可直接得到页帧号，与页内偏移拼接成物理地址后访问内存，进行指令或者数据的存取。（<strong>只需访问一次内存</strong>）</li><li><strong>若快表不命中</strong>，则需去内存中访问页表，形成物理地址后，再一次访问内存进行指令或者数据的存取。（需要访问两次内存）</li></ul></li></ul><h3 id="物理内存-amp-虚拟内存"><a href="#物理内存-amp-虚拟内存" class="headerlink" title="物理内存 &amp; 虚拟内存"></a>物理内存 &amp; 虚拟内存</h3><ul><li><p><strong>正在运行的一个进程，他所需的内存是有可能大于内存条容量之和</strong>的，比如你的<strong>内存条是256M，你的程序却要创建一个2G的数据区</strong>，那么不是所有数据都能一起加载到内存（物理内存）中，势必有一部分数据要放到其他介质中（比如硬盘），待进程需要访问那部分数据时，在通过调度进入物理内存。所以，虚拟内存是进程运行时所有内存空间的总和，并且可能有一部分不在物理内存中，而物理内存就是我们平时所了解的内存条。有的地方呢，也叫这个虚拟内存为内存交换区。</p></li><li><p><strong>虚拟内存的作用就是，将需要大内存的分块，一块一块的递给物理内存</strong>。换言之，<strong>虚拟内存是通过页面调度实现的</strong></p></li><li><p>虚拟内存的目的是为了</p><p>让物理内存扩充成更大的逻辑内存，从而让程序获得更多的可用内存</p><p>。</p><ul><li>为了更好的管理内存，操作系统将内存抽象成地址空间。每个程序拥有自己的地址空间，这个地址空间被分割成多个块，每一块称为一页。</li><li>这些页被映射到物理内存，但不需要映射到连续的物理内存，也不需要所有页都必须在物理内存中。</li><li>当程序引用到不在物理内存中的页时，由硬件执行必要的映射，将缺失的部分装入物理内存并重新执行失败的指令。</li></ul></li></ul><h4 id="进程的内存分配-amp-内存访问"><a href="#进程的内存分配-amp-内存访问" class="headerlink" title="进程的内存分配 &amp; 内存访问"></a>进程的内存分配 &amp; 内存访问</h4><ul><li><strong>进程是在虚拟内存中的</strong>，每个进程运行时都会得到4G的虚拟内存，得到的这4G虚拟内存是一个连续的地址空间（这也只是进程认为），而实际上，它通常是被分隔成多个物理内存碎片，还有一部分存储在外部磁盘存储器上，在需要时进行数据交换</li><li>进程内存访问<ol><li>每次要访问地址空间上的某一个地址，都需要<strong>把虚拟地址翻译为实际物理内存地址</strong></li><li><strong>所有进程共享这整一块物理内存，每个进程只把自己目前需要的虚拟地址空间映射到物理内存上</strong></li><li>进程需要知道<strong>哪些地址空间上的数据在物理内存上</strong>，哪些不在（可能这部分存储在磁盘上），还有在物理内存上的哪里，这就需要通过<strong>页表</strong>来记录</li><li>页表的每一个表项分两部分，第一部分记录此页是否在物理内存上（页面号），第二部分记录物理内存页的地址（偏移量）</li><li><strong>当进程访问某个虚拟地址的时候，就会先去看页表，如果发现对应的数据不在物理内存上，就会发生缺页异常</strong></li><li><strong>缺页异常</strong>的处理过程，<strong>操作系统立即阻塞该进程，并将硬盘里对应的页换入内存</strong>，然后使该进程就绪，如果内存已经满了，没有空地方了，那就找一个页覆盖，至于具体覆盖的哪个页，就需要看操作系统选择的<strong>页面置换<a href="https://www.nowcoder.com/jump/super-jump/word?word=%E7%AE%97%E6%B3%95">算法</a></strong></li></ol></li></ul><h4 id="虚拟内存置换算法"><a href="#虚拟内存置换算法" class="headerlink" title="虚拟内存置换算法"></a>虚拟内存置换<a href="https://www.nowcoder.com/jump/super-jump/word?word=%E7%AE%97%E6%B3%95">算法</a></h4><ul><li><p>最佳(Optimal)置换<a href="https://www.nowcoder.com/jump/super-jump/word?word=%E7%AE%97%E6%B3%95">算法</a></p><p>：</p><ul><li>一种理论<a href="https://www.nowcoder.com/jump/super-jump/word?word=%E7%AE%97%E6%B3%95">算法</a>，无法实现，置换策略是将当前页面中在未来最长时间内不会被访问的页置换出去。</li></ul></li><li><p>先进先出(FIFO)页面置换<a href="https://www.nowcoder.com/jump/super-jump/word?word=%E7%AE%97%E6%B3%95">算法</a></p><p>：</p><ul><li>每次淘汰最早调入的页面。</li></ul></li><li><p>最近最久未使用<a href="https://www.nowcoder.com/jump/super-jump/word?word=%E7%AE%97%E6%B3%95">算法</a>LRU</p><p>：</p><ul><li><a href="https://www.nowcoder.com/jump/super-jump/word?word=%E7%AE%97%E6%B3%95">算法</a>赋予每个页面一个访问字段，用来记录一个页面自上次被访问以来所经历的时间t，当须淘汰一个页面时，选择现有页面中其t值最大的，即最近最久未使用的页面予以淘汰。</li></ul></li><li><p>时钟<a href="https://www.nowcoder.com/jump/super-jump/word?word=%E7%AE%97%E6%B3%95">算法</a>clock</p><p>(也被称为是</p><p>最近未使用<a href="https://www.nowcoder.com/jump/super-jump/word?word=%E7%AE%97%E6%B3%95">算法</a>NRU</p><p>)：</p><ul><li>页面设置一个访问位，并将页面链接为一个环形队列，页面被访问的时候访问位设置为1。页面置换的时候，如果当前指针所指页面访问为为0，那么置换，否则将其置为0，循环直到遇到一个访问为位0的页面。</li></ul></li><li><p>改进型Clock<a href="https://www.nowcoder.com/jump/super-jump/word?word=%E7%AE%97%E6%B3%95">算法</a></p><p>：</p><ul><li>在Clock<a href="https://www.nowcoder.com/jump/super-jump/word?word=%E7%AE%97%E6%B3%95">算法</a>的基础上添加一个修改位，替换时根据访问位和修改位综合判断。优先替换访问位和修改位都是0的页面，其次是访问位为0修改位为1的页面。</li></ul></li><li><p>最少使用<a href="https://www.nowcoder.com/jump/super-jump/word?word=%E7%AE%97%E6%B3%95">算法</a>LFU</p><p>：</p><ul><li>设置寄存器记录页面被访问次数，每次置换的时候置换当前访问次数最少的。</li></ul></li></ul><h3 id="用户态-amp-内核态"><a href="#用户态-amp-内核态" class="headerlink" title="用户态&amp;内核态"></a>用户态&amp;内核态</h3><ul><li><p>用户态：用户态运行的进程可以直接读取用户程序的数据</p></li><li><p>内核态：内核态运行的进程或程序几乎可以访问计算机的任何资源，不受限制</p></li><li><p>两者最重要的差别就在于<strong>特权级的不同</strong>，即权力的不同。<strong>运行在用户态下的程序不能直接访问操作系统内核数据结构和程序</strong>。当我们在系统中执行一个程序时，大部分时间是运行在用户态下的，在其需要操作系统帮助完成某些它没有权力和能力完成的工作时就会切换到内核态</p></li><li><p>用户态切换到内核态的3种方式</p><p>：</p><ol><li><strong>系统调用</strong>：这是用户态进程主动要求切换到内核态的一种方式，用户态进程通过系统调用申请使用操作系统提供的服务程序完成工作。而系统调用的机制其核心还是使用了操作系统为用户特别开放的一个中断来实现</li><li><strong>异常</strong>：当CPU在执行运行在用户态下的程序时，发生了某些事先不可知的异常，这时会触发由当前运行进程切换到处理此异常的内核相关程序中，也就转到了内核态，比如缺页异常</li><li><strong>外围设备的中断</strong>：当外围设备完成用户请求的操作后，会向CPU发出相应的中断信号，这时CPU会暂停执行下一条即将要执行的指令转而去执行与中断信号对应的处理程序，如果先前执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了由用户态到内核态的切换。（比如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后续操作等。）</li></ol></li></ul><h3 id="系统调度"><a href="#系统调度" class="headerlink" title="系统调度"></a>系统调度</h3><ul><li><p>Q：什么是系统调用</p><p>？</p><ul><li>我们运行的程序基本都是运行在用户态，如果需要调用操作系统提供的系统态级别的子功能，就需要系统调用。也就是说在我们运行的用户程序中，凡是与系统态级别的资源有关的操作（如<strong>文件管理、进程控制、内存管理</strong>等)，都必须<strong>通过系统调用方式向操作系统提出服务请求，并由操作系统代为完成</strong></li></ul></li><li><p>常见的系统调用：</p><ul><li>设备管理。完成设备的请求或释放，以及设备启动等功能</li><li>文件管理。完成文件的读、写、创建及删除等功能</li><li>进程控制。完成进程的创建、撤销、阻塞及唤醒等功能</li><li>进程通信。完成进程之间的消息传递或信号传递等功能</li><li>内存管理。完成内存的分配、回收以及获取作业占用内存区大小及地址等功能</li></ul></li></ul><h3 id="Q：Debug时看到的是物理内存还是虚拟内存-？"><a href="#Q：Debug时看到的是物理内存还是虚拟内存-？" class="headerlink" title="Q：Debug时看到的是物理内存还是虚拟内存 ？"></a>Q：Debug时看到的是物理内存还是虚拟内存 ？</h3><ul><li>虚拟内存，通常，<strong>在用户模式下，我们用调试器看到的内存地址都是虚拟内存</strong>。</li></ul><h2 id="操作系统是如何实现锁的？"><a href="#操作系统是如何实现锁的？" class="headerlink" title="操作系统是如何实现锁的？"></a>操作系统是如何实现锁的？</h2><ul><li><p>首先要搞清楚一个概念，<strong>在硬件层面，CPU提供了原子操作、关中断、锁内存总线的机制</strong>；<strong>OS基于这几个CPU硬件机制，就能够实现锁</strong>；再<strong>基于锁，就能够实现各种各样的同步机制</strong>（信号量、消息、Barrier等）</p></li><li><p>在多线程编程中，为了保证数据操作的一致性，操作系统引入了锁机制，用于保证临界区代码的安全。通过锁机制，能够保证在多核多线程环境中，在某一个时间点上，只能有一个线程进入临界区代码，从而保证临界区中操作数据的一致性。</p></li><li><p><strong>锁机制的一个特点是它的同步原语都是原子操作</strong></p></li><li><p>那么操作系统是如何保证这些同步原语的原子性呢？</p><ul><li>操作系统之所以能构建锁之类的同步原语，是因为硬件已经为我们提供了一些原子操作，例如：</li></ul><ol><li>中断禁止和启用（interrupt enable/disable）</li><li>内存加载和存入（load/store）测试与设置（test and set）指令</li></ol></li><li><p>禁止中断这个操作是一个硬件步骤，中间无法插入别的操作。同样，中断启用，测试与设置均为一个硬件步骤的指令。在这些硬件原子操作之上，我们便可以构建软件原子操作：锁，睡觉与叫醒，信号量等。</p></li></ul><h3 id="操作系统使用锁的原语操作"><a href="#操作系统使用锁的原语操作" class="headerlink" title="操作系统使用锁的原语操作"></a>操作系统使用锁的原语操作</h3><ul><li><p>可以使用<strong>中断禁止，测试与设置</strong>两种<strong>硬件原语来实现软件的锁原语</strong>。这两种方式比较起来，显然<strong>测试与设置</strong>更加简单，也因此使用的<strong>更为普遍</strong>。此外，<strong>test and set还有一个优点，就是可以在多CPU环境下工作，而中断启用和禁止则不能</strong></p></li><li><p>使用中断启用与禁止来实现锁</p><p>：</p><ul><li>要防止一段代码在执行过程中被别的进程插入，就要考虑在一个单处理器上，一个线程在执行途中被切换的途径。我们知道，要切换进程，必须要发生上下文切换，上下文切换只有两种可能：</li></ul><ol><li><strong>一个线程自愿放弃CPU而将控制权交给操作系统调度器</strong>（<strong>通过yield之类的操作系统调用来实现</strong>）；</li><li><strong>一个线程被强制放弃CPU而失去控制权（通过中断来实现）</strong></li></ol><ul><li>原语执行过程中，我们不会自动放弃CPU控制权，因此<strong>要防止进程切换，就要在原语执行过程中不能发生中断。所以采用禁止中断</strong>，且不自动调用让出CPU的系统调用，就可以防止进程切换，将一组操作变为原子操作。</li><li>中断禁止：就是禁止打断，<strong>使用可以将一系列操作变为原子操作</strong></li><li>中断启用：就是从这里开始，可以被打断，允许操作系统进行调度</li><li>缺点：使用中断实现锁，繁忙等待，不可重入</li></ul></li><li><p>使用测试与设置指令来实现锁</p><ul><li>测试与设置（test &amp; set）指令：以不可分割的方式执行如下两个步骤：</li></ul><ol><li>设置操作：将1写入指定内存单元；</li><li>读取操作：返回指定内存单元里原来的值（写入1之前的值）</li></ol><ul><li>缺点：繁忙等待，不可重入</li></ul></li></ul><h3 id="操作系统中的锁机制"><a href="#操作系统中的锁机制" class="headerlink" title="操作系统中的锁机制"></a>操作系统中的锁机制</h3><ul><li><p><strong>互斥锁</strong>：mutex，用于保证在任何时刻，都只能有一个线程访问该对象。只有取得互斥锁的进程才能进入临界区，无论读写，当获取锁操作失败时，线程会进入睡眠，等待锁释放时被唤醒</p></li><li><p>读写锁</p><p>：rwlock，分为读锁和写锁。读写锁要根据进程进入临界区的具体行为（读，写）来决定锁的占用情况。这样锁的状态就有三种了：读加锁、写加锁、无锁。</p><ol><li>无锁。读/写进程都可以进入；</li><li>读锁。读进程可以进入。写进程不可以进入；</li><li>写锁。读/写进程都不可以进入</li></ol></li><li><p>自旋锁</p><p>：spinlock，自旋锁是指在进程试图取得锁失败的时候选择忙等待而不是阻塞自己。</p><ul><li>选择忙等待的优点在于如果该进程在其自身的CPU时间片内拿到锁（说明锁占用时间都比较短），则相比阻塞少了上下文切换</li><li>注意这里还有一个隐藏条件：<strong>多处理器</strong>。因为单个处理器的情况下，由于当前自旋进程占用着CPU，持有锁的进程只有等待自旋进程耗尽CPU时间才有机会执行，这样CPU就空转了</li></ul></li><li><p>RCU</p><p>：read-copy-update，在修改数据时，首先需要读取数据，然后生成一个副本，对副本进行修改，修改完成后，再将老数据update成新的数据。【有点像 copy-on-write】</p><ul><li>使用RCU时，读者几乎不需要同步开销，既不需要获得锁，也不使用原子指令，不会导致锁竞争，因此就<strong>不用考虑死锁问题</strong>了。</li><li>对于写者的同步开销较大，它需要复制被修改的数据，还必须使用锁机制同步并行其它写者的修改操作。</li><li>在有大量读操作，少量写操作的情况下效率非常高。【读多写少】</li></ul></li></ul><h2 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h2><ul><li>早期计算机各个程序只能串行执行、系统资源利用低。为了解决上述问题，操作系统引入了中断机制，实现了<strong>多道程序的并发执行</strong>，提高了系统资源的利用率。</li><li><strong>中断是多程序并发执行的前提条件</strong></li></ul><ol><li>当一个时间片运行完后，CPU会接收到计时部件（操作系统内核的时钟管理部件）<strong>发出的中断信号，CPU立即进入核心态</strong>，把CPU的使用权限交还给操作系统</li><li>当中断发生后，当前运行的进程暂停运行，操作系统内核对中断进程处理，切换进程（根据进程调度<a href="https://www.nowcoder.com/jump/super-jump/word?word=%E7%AE%97%E6%B3%95">算法</a>），在完成切换进程的一系列工作后，操作系统又会将CPU的使用权交还给用户进程</li><li>切换到的进程2拿到CPU执行权就会在用户态下执行</li></ol><ul><li>中断的<strong>本质</strong>：<strong>发生中断就意味着需要操作系统介入</strong>，开展管理工作</li></ul><h3 id="中断的处理过程"><a href="#中断的处理过程" class="headerlink" title="中断的处理过程"></a>中断的处理过程</h3><ol><li>执行完每个指令后，CPU都要检查当前是否有外部中断信号</li><li><strong>如果检测到外部中断信号，则需要保护被中断进程的CPU环境</strong>（<a href="https://www.nowcoder.com/jump/super-jump/word?word=%E5%A6%82%E7%A8%8B">如程</a>序状态字PSW、<strong>程序计数器、各种通用寄存器</strong>）</li><li>根据中断信号类型转入相应的中断处理程序</li><li>恢复进程的CPU环境并退出中断，返回原进程继续往下执行</li></ol><h3 id="中断的分类"><a href="#中断的分类" class="headerlink" title="中断的分类"></a>中断的分类</h3><ul><li>中断可以分为：内中断和外中断</li><li>内中断：内中断的信号来源于CPU内部、与当前执行的指令有关。如整数除0</li><li>外中断：外中断的信号来源于CPU外部、与当前执行的指令无关。如用户强制结束一个进程、IO设备完成操作发生的中断信号</li></ul><h3 id="缺页中断"><a href="#缺页中断" class="headerlink" title="缺页中断"></a>缺页中断</h3><ul><li>在请求分页系统中，可以通过查询页表中的状态位来确定所要访问的页面是否存在于内存中。每当所要访问的页面不在内存是，会产生一次缺页中断，此时操作系统会根据页表中的外存地址在外存中找到所缺的一页，将其调入内存。</li><li>缺页本身是一种中断，与一般的中断一样，需要经过4个处理步骤：<ol><li>保护CPU现场</li><li>分析中断原因</li><li>转入缺页中断处理程序进行处理</li><li>恢复CPU现场，继续执行</li></ol></li><li>但是缺页中断是由于所要访问的页面不存在于内存时，由硬件所产生的一种特殊的中断，因此，与一般的中断存在区别：<ul><li>在指令执行期间产生和处理缺页中断信号</li><li>一条指令在执行期间，可能产生多次缺页中断</li><li>缺页中断返回的是，执行产生中断的一条指令，而一般的中断返回的是，执行下一条指令</li></ul></li></ul><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><h3 id="Q：操作系统临界资源的访问"><a href="#Q：操作系统临界资源的访问" class="headerlink" title="Q：操作系统临界资源的访问"></a>Q：操作系统临界资源的访问</h3><ul><li><strong>临界资源</strong>：<strong>一段时间内只允许一个线程访问的资源就称为临界资源或独占资源</strong></li><li><strong>临界区</strong>：对临界资源进行访问的那段代码称为临界区，通过对多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问</li><li><strong>多线程同步互斥的常见方法</strong>：</li></ul><ol><li><p>**互斥量(Mutex)**：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问。比如 <strong>Java 中的 synchronized 关键词和各种 Lock 都是这种机制，本质是一个计数器</strong></p></li><li><p>信号量PV(Semphares)</p><p>：它</p><p>允许同一时刻多个线程来访问同一资源</p><p>，但是需要控制同一时刻访问此资源的最大线程数量【用来实现生产者消费者模型】</p><ul><li>信号量的数据结构为一个值和一个指针，指针指向等待该信号量的下一个进程，信号量的值与相应资源的使用情况有关。当它的值大于0时，表示当前可用资源的数量；当它的值小于0时，其绝对值表示等待使用该资源的进程个数。</li><li>注意，<strong>信号量的值仅能由PV操作来改变</strong></li><li>p操作（wait）：申请一个单位资源，进程进入；v操作（signal）：释放一个单位资源，进程出来</li><li>PV操作的含义：<strong>PV操作由P操作原语和V操作原语组成（原语是不可中断的过程），对信号量进行操作</strong></li></ul></li><li><p><strong>事件event</strong>：通过通知操作的方式来保持多线程同步，还可以方便实现多线程优先级的比较操作，Wait/Notify</p></li></ol><h3 id="线程通信"><a href="#线程通信" class="headerlink" title="线程通信"></a>线程通信</h3><ul><li><p><strong>synchronized同步</strong>：本质上就是 “共享内存” 式的通信。多个线程需要访问同一个共享变量，谁拿到了锁（获得了访问权限），谁就可以执行。</p></li><li><p>while轮询的方式</p><p>：</p><ul><li>在这种方式下，ThreadA 不断地改变条件，ThreadB 不停地通过 while 语句检测这个条件比如说互斥量为0 是否成立 ，从而实现了线程间的通信。但是这种方式会浪费 CPU 资源。</li></ul></li><li><p>wait/notify机制</p><p>：</p><ul><li>当条件未满足时，ThreadA 调用 wait() 放弃 CPU，并进入阻塞状态。（不像 while 轮询那样占用 CPU）</li><li>当条件满足时，ThreadB 调用 notify() 通知线程 A，所谓通知线程 A，就是唤醒线程 A，并让它进入可运行状态</li></ul></li><li><p><strong>管道通信</strong>：java.io.PipedInputStream 和 java.io.PipedOutputStream进行通信</p></li></ul><h2 id="进程-1"><a href="#进程-1" class="headerlink" title="进程"></a>进程</h2><ul><li>进程控制块 (Process Control Block，PCB) 描述进程的基本信息和运行状态，所谓的创建进程和撤销进程，都是指对 PCB 的操作。</li></ul><h3 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h3><ul><li><p><strong>创建状态(new)</strong> ：进程正在被创建，尚未到就绪状态</p></li><li><p>**就绪状态(ready)**：进程已处于准备运行状态，即进程获得了除了处理器之外的一切所需资源，一旦得到处理器资源(处理器分配的时间片)即可运行</p></li><li><p><strong>运行状态(running)</strong> ：进程正在处理器上上运行（单核 CPU 下任意时刻只有一个进程处于运行状态）</p></li><li><p><strong>阻塞状态(waiting)</strong> ：又称为等待状态，进程正在等待某一事件而暂停运行如等待某资源为可用或等待 IO 操作完成。即使处理器空闲，该进程也不能运行</p></li><li><p><strong>结束状态(terminated)</strong> ：进程正在从系统中消失。可能是进程正常结束或其他原因中断退出运行</p></li><li><p><strong>只有就绪态和运行态可以相互转换，其它的都是单向转换</strong>。<strong>就绪状态</strong>的进程通过<strong>调度<a href="https://www.nowcoder.com/jump/super-jump/word?word=%E7%AE%97%E6%B3%95">算法</a><strong>从而</strong>获得 CPU 时间，转为运行状态</strong>；而<strong>运行状态</strong>的进程，<strong>在分配给它的 CPU 时间片用完之后就会转为就绪状态</strong>，等待下一次调度。</p></li><li><p><strong>阻塞状态是缺少需要的资源从而由运行状态转换而来</strong>，<strong>但是该资源不包括 CPU 时间，缺少 CPU 时间会从运行态转换为就绪态</strong></p></li><li><p>挂起</p><p>（换到外存）:</p><ul><li>挂起就绪：是指进程被对换到辅存时的就绪状态，是不能被直接调度的状态，只有当主存中没有活跃就绪态进程，或者是挂起就绪态进程具有更高的优先级，系统将把挂起就绪态进程调回主存并转换为活跃就绪。</li></ul></li></ul><h3 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h3><ol><li><p>临界区：对临界资源进行访问的那段代码称为临界区。</p></li><li><p>同步与互斥：</p><ul><li>同步：多个进程因为合作产生的直接制约关系，使得进程有一定的先后执行关系。</li><li>互斥：多个进程在同一时刻只有一个进程能进入临界区。</li></ul></li><li><p>信号量</p><p>：信号量（Semaphore）是一个整型变量，可以对其执行 down 和 up 操作，也就是常见的 P 和 V 操作。</p><ul><li>down : 如果信号量大于 0 ，执行 -1 操作；如果信号量等于 0，进程睡眠，等待信号量大于 0；</li><li>up ：对信号量执行 +1 操作，唤醒睡眠的进程让其完成 down 操作</li><li>down 和 up 操作需要被设计成原语，不可分割，通常的做法是在执行这些操作的时候<strong>屏蔽中断</strong></li><li>如果信号量的取值只能为 0 或者 1，那么就成为了 <strong>互斥量</strong>（Mutex） ，0 表示临界区已经加锁，1 表示临界区解锁。</li></ul></li><li><p>管程</p><p>：管程在功能上和信号量及PV操作类似，属于一种进程同步互斥工具，但是具有与信号量及PV操作不同的属性。</p><p>管程把控制的代码独立出来，封装了同步操作，对进程隐蔽了同步细节</p><p>，简化了同步功能的调用界面。用户编写并发程序如同编写顺序(串行)程序。</p><ul><li>管程有一个重要特性：在一个时刻只能有一个进程使用管程。进程在无法继续执行的时候不能一直占用管程，否则其它进程永远不能使用管程。</li><li>管程引入了<strong>条件变量</strong>以及相关的操作：<strong>wait() 和 signal() 来实现同步操作</strong>。对条件变量执行 wait() 操作会导致调用进程阻塞，把管程让出来给另一个进程持有。signal() 操作用于唤醒被阻塞的进程。</li></ul></li></ol><h4 id="进程同步和进程通信的区别"><a href="#进程同步和进程通信的区别" class="headerlink" title="进程同步和进程通信的区别"></a>进程同步和进程通信的区别</h4><ul><li>进程同步：控制多个进程按一定顺序执行</li><li>进程通信：进程间传输信息</li><li>进程通信是一种手段，而进程同步是一种目的。也可以说，为了能够达到进程同步的目的，需要让进程进行通信，传输一些进程同步所需要的信息</li></ul><h3 id="Q：常见的进程间的通信方式（IPC，Inter-Process-Communication）？"><a href="#Q：常见的进程间的通信方式（IPC，Inter-Process-Communication）？" class="headerlink" title="Q：常见的进程间的通信方式（IPC，Inter-Process Communication）？"></a>Q：常见的进程间的通信方式（IPC，Inter-Process Communication）？</h3><ul><li><p>管道</p><p>：</p><p>管道可用于具有亲缘关系的父子进程间的通信</p><p>。linux 系统操作执行命令时，将一个程序的输出交给另一个程序进行处理。一个进程往管道输入数据，则会阻塞等待别的进程从管道读取数据。管道是通过调用 pipe 函数创建的，fd[0] 用于读，fd[1] 用于写。</p><ul><li>它具有以下限制：1. <strong>只支持半双工通信（单向交替传输）</strong>；2. <strong>只能在父子进程或者兄弟进程中使用</strong></li></ul></li><li><p><strong>命名管道（FIFO）</strong>：克服了管道没有名字的限制，<strong>具有管道所具有的功能外，还允许无亲缘关系进程间的通信</strong>，去除了管道只能在父子进程中使用的限制</p></li><li><p><strong>信号（singal）</strong>：<strong>信号是在软件层次上对中断机制的一种模拟</strong>，一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。一个进程收到一个信号与处理器收到一个中断请求效果上可以说是一致的。</p></li><li><p>消息队列</p><p>：消息队列提供了从一个进程向另一个进程发送一个数据块的方法。</p><ul><li><strong>相比于命名管道的优点</strong>：<strong>消息队列可以独立于读写进程存在</strong>，从而避免了 FIFO 中同步管道的打开和关闭时可能产生的困难；<strong>避免了 FIFO 的同步阻塞问题</strong>，不需要进程自己提供同步方法；读进程可以<strong>根据消息类型有选择地接收消息</strong>，而不像 FIFO 那样只能默认地接收。</li><li><strong>缺点</strong>：使用消息队列进行进程间通信，可能会收到数据块最大长度的限制约束等。如果频繁的发生进程间的通信行为，那么进程需要频繁地读取队列中的数据到内存，相当于间接地从一个进程拷贝到另一个进程，这需要花费时间</li></ul></li><li><p>共享内存</p><p>：共享内存可以很好解决拷贝消耗的时间。</p><ul><li><strong>允许多个进程共享一个给定的存储区，不同进程可以及时看到对方进程中对共享内存中数据变更</strong>。因为数据不需要在进程之间复制，所以这是<strong>最快的一种 IPC</strong></li><li>共享内存需要依靠某种同步操作，如互斥锁和信号量等，<strong>需要使用信号量用来同步对共享存储的访问</strong>。</li><li>系统加载一个进程的时候，分配给进程的内存并不是实际物理内存，而是虚拟内存空间。可以让<strong>两个进程各自拿出一块虚拟地址空间，然后映射到相同的物理内存中</strong>，这样，两个进程虽然有着独立的虚拟内存空间，但有一部分却是映射到相同的物理内存，这就完成了内存共享机制了</li></ul></li><li><p>信号量（mutex）</p><p>：为了避免共享内存多进程竞争内存的问题（线程安全），使用信号量。</p><ul><li>信号量的<strong>本质就是一个计数器</strong>，用来<strong>实现进程之间的互斥与同步</strong>，<strong>用于为多个进程提供对共享数据对象的访问</strong>，信号量也是进程之间的一种通信方式。</li></ul></li><li><p><strong>Socket</strong>：Socket套接字进行通信，与其他机制不同的是，它<strong>可用于不同机器之间的进程间通信</strong>，应用非常广泛。</p></li></ul><h3 id="进程的调度"><a href="#进程的调度" class="headerlink" title="进程的调度"></a>进程的调度</h3><p>一. <strong>批处理系统</strong></p><ul><li><p>批处理系统没有太多的用户操作，在该系统中，<strong>调度<a href="https://www.nowcoder.com/jump/super-jump/word?word=%E7%AE%97%E6%B3%95">算法</a>目标是保证吞吐量和周转时间</strong>（从提交到终止的时间）</p></li><li><p>先来先服务调度<a href="https://www.nowcoder.com/jump/super-jump/word?word=%E7%AE%97%E6%B3%95">算法</a></p><p>（FCFS）：</p><ul><li>每次调度是<strong>从就绪队列中选择一个最先进入该队列的进程</strong>，为之分配处理机，使之投入运行。该进程一直运行到完成或发生某事件而阻塞后才放弃处理机。</li><li>比较有利于长作业（进程），而不利于短作业（进程）</li><li><strong>有利于CPU繁忙型作业（进程） ，而不利于I/O繁忙型作业（进程）</strong></li><li>用于批处理系统，不适于分时系统</li></ul></li><li><p>短进程优先调度<a href="https://www.nowcoder.com/jump/super-jump/word?word=%E7%AE%97%E6%B3%95">算法</a></p><p>：</p><ul><li><strong>从就绪队列中选出一个估计运行时间最短的进程</strong>，将处理机分配给它，使它立即执行并一直执行到完成，或发生某事件而被阻塞放弃处理机时再重新调度。</li><li>对长作业不利，未考虑作业(进程)的紧迫程度，因而不能保证紧迫性作业(进程)会被及时处理</li></ul></li><li><p>最短剩余时间优先</p><p>shortest remaining time next（SRTN）</p><ul><li>最短作业优先的抢占式版本，按剩余运行时间的顺序进行调度。 当一个新的作业到达时，其整个运行时间与当前进程的剩余时间作比较。如果新的进程需要的时间更少，则挂起当前进程，运行新的进程。否则新的进程等待。</li></ul></li></ul><p>二. <strong>交互式系统</strong></p><ul><li><p>交互式系统有大量的用户交互操作，在该系统中调度<a href="https://www.nowcoder.com/jump/super-jump/word?word=%E7%AE%97%E6%B3%95">算法</a>的目标是快速地进行响应</p></li><li><p>时间片轮转法</p><p>：</p><ul><li>系统将所有的就绪进程按先来先服务的原则排成一个队列，每次调度时，<strong>把CPU分配给队首进程，并令其执行一个时间片</strong>。当执行的时间片用完时，由一个计时器发出时钟中断请求，调度程序便据此信号来停止该进程的执行，并将它<strong>送往就绪队列的末尾</strong>；然后，再把处理机分配给<strong>就绪队列中新的队首进程，同时也让它执行一个时间片</strong>。</li><li>紧迫任务响应慢。</li></ul></li><li><p>多级反馈队列调度<a href="https://www.nowcoder.com/jump/super-jump/word?word=%E7%AE%97%E6%B3%95">算法</a></p><p>：</p><ol><li><strong>设置多个就绪队列</strong>，并为各个队列赋予不同的<strong>优先级</strong>；该<a href="https://www.nowcoder.com/jump/super-jump/word?word=%E7%AE%97%E6%B3%95">算法</a>赋予<strong>各个队列中进程执行时间片</strong>的大小也各不相同，在<strong>优先权愈高</strong>的队列中，为<strong>每个进程所规定的执行时间片就愈小</strong>。</li><li>当一个新进程进入内存后，首先将它放入<strong>第一队列的末尾</strong>，<strong>按FCFS原则排队等待调度</strong>；当轮到该进程执行时，如它能在该时间片内完成，便可准备撤离系统；<strong>如果它在一个时间片结束时尚未完成，调度程序便将该进程转入第二队列的末尾</strong>，<strong>再同样地按FCFS原则等待调度执行</strong>；</li><li><strong>仅当第一队列空闲时，调度程序才调度第二队列中的进程运行</strong></li></ol></li><li><p>优先权调度<a href="https://www.nowcoder.com/jump/super-jump/word?word=%E7%AE%97%E6%B3%95">算法</a></p><p>：</p><p>把处理机分配给就绪队列中优先权最高的进程</p><ul><li>**非抢占式优先权<a href="https://www.nowcoder.com/jump/super-jump/word?word=%E7%AE%97%E6%B3%95">算法</a>**：系统一旦把处理机分配给就绪队列中优先权最高的进程后，该进程便一直执行下去，直至完成；</li><li><strong>抢占式优先权调度<a href="https://www.nowcoder.com/jump/super-jump/word?word=%E7%AE%97%E6%B3%95">算法</a><strong>：系统把处理机分配给优先权最高的进程，使之执行。但</strong>在其执行期间</strong>，<strong>只要出现了另一个其优先权更高的进程</strong>，<strong>进程调度程序就立即停止当前进程</strong>(原优先权最高的进程)的执行，<strong>重新将处理机分配给新到的优先权最高的进程</strong>。</li><li>这种抢占式的优先权调度<a href="https://www.nowcoder.com/jump/super-jump/word?word=%E7%AE%97%E6%B3%95">算法</a>能更好地满足紧迫作业的要求，故而常用于要求比较严格的实时系统中，以及对性能要求较高的批处理和分时系统中</li></ul></li></ul><p>三. <strong>实时系统</strong></p><ul><li>实时系统要求一个请求在一个确定时间内得到响应。分为硬实时和软实时，前者必须满足绝对的截止时间，后者可以容忍一定的超时。</li></ul><h4 id="Q：有5个任务，每个任务权重15524，执行时间15534，如何用最短的时间执行完？"><a href="#Q：有5个任务，每个任务权重15524，执行时间15534，如何用最短的时间执行完？" class="headerlink" title="Q：有5个任务，每个任务权重15524，执行时间15534，如何用最短的时间执行完？"></a>Q：有5个任务，每个任务权重15524，执行时间15534，如何用最短的时间执行完？</h4><ul><li><strong>WARNING：这是我面试中遇到的问题，以下为我个人思考的答案，仅供参考</strong></li><li>可以采用**多级反馈队列调度<a href="https://www.nowcoder.com/jump/super-jump/word?word=%E7%AE%97%E6%B3%95">算法</a>**，可以看成时间片轮转调度和优先级调度的结合</li><li>最上面的队列，优先级最高，首先调度优先级高的队列中的进程。若高优先级中队列中已没有调度的进程，则调度次优先级队列中的进程</li><li><strong>如果它在一个时间片结束时尚未完成，调度程序便将该进程转入第二队列的末尾</strong>，若第二队列的时间片用完后作业还不能完成，一直进入下一级队列，直至完成</li><li>在低优先级的队列中的进程在运行时，又有新到达的作业，那么在运行完这个时间片后，CPU马上分配给新到达的作业即抢占式调度CPU</li></ul><h2 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a>进程和线程的区别</h2><ul><li>拥有资源：进程是资源分配的基本单位，但是线程不拥有资源，线程可以访问隶属进程的资源</li><li>调度：线程是独立调度的基本单位，在同一进程中，线程的切换不会引起进程切换，从一个进程中的线程切换到另一个进程中的线程时，会引起进程切换【一个进程有多个线程】</li><li>系统开销：由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间，I/O 设备等，所付出的开销远大于创建或撤销线程时的开销；类似地，在进行进程切换时，涉及当前执行进程 CPU 环境的保存及新调度进程 CPU 环境的设置，而线程切换时只需保存和设置少量寄存器内容，开销很小。</li><li>通信：线程间可以通过直接读写同一进程中的数据进行通信【线程共享进程内存空间】，但是进程通信需要借助 IPC</li></ul><h2 id="多进程-amp-多线程"><a href="#多进程-amp-多线程" class="headerlink" title="多进程 &amp; 多线程"></a>多进程 &amp; 多线程</h2><ul><li><p>进程</p><p>：</p><ul><li><strong>优点</strong>：1. 顺序程序的特点：具有封闭性和可再现性；2.<strong>程序的并发执行和资源共享</strong>。多道程序设计出现后，实现了程序的并发执行和资源共享，提高了系统的效率和系统的资源利用率。</li><li><strong>缺点</strong>：1. <strong>操作系统调度切换多个线程要比切换调度进程在速度上快的多</strong>。而且<strong>进程间内存无法共享</strong>，通讯也比较麻烦；2. 线程之间由于共享进程内存空间，所以交换数据非常方便；在创建或撤消进程时，由于系统都要为之分配和回收资源，导致系统的开销明显大于创建或撤消线程时的开销。</li></ul></li><li><p>线程</p><p>：</p><ul><li><strong>优点</strong>：</li></ul><ol><li>启动一个线程所花费的空间远远小于启动一个进程所花费的空间，而且，线程间彼此切换所需的时间也远远小于进程间切换所需要的时间（因为在Linux系统下，启动一个新的进程必须分配给它独立的地址空间，建立众多的数据表来维护它的代码段、堆栈段和数据段。<strong>线程之间却可以使用相同的地址空间，共享大部分数据</strong>）；</li><li><strong>线程间方便的通信机制</strong>，由于同一进程下的线程之间共享数据空间，所以一个线程的数据可以直接为其它线程所用，这不仅快捷，而且方便；</li><li>使多CPU系统更加有效。操作系统会保证当线程数不大于CPU数目时，不同的线程运行于不同的CPU上；</li></ol><ul><li><strong>缺点</strong>：<strong>调度时, 要保存线程状态</strong>，频繁调度, 需要占用大量的机时；程序设计上容易出错（<strong>线程同步问题</strong>）</li></ul></li><li><p>多进程</p><ul><li><strong>多进程优点</strong>：1. <strong>每个进程互相独立，不影响主程序的稳定性，子进程崩溃没关系</strong>；2. 通过增加CPU，就可以容易扩充性能；3. 可以<strong>尽量减少线程加锁/解锁的影响，极大提高性能</strong>，就算是线程运行的模块<a href="https://www.nowcoder.com/jump/super-jump/word?word=%E7%AE%97%E6%B3%95">算法</a>效率低也没关系；4. 每个子进程都有2GB地址空间和相关资源，总体能够达到的性能上限非常大。</li><li><strong>多进程缺点</strong>：1. 逻辑控制复杂，需要和主程序交互；2. 需要跨进程边界，如果有大数据量传送，就不太好，适合小数据量传送、密集运算；3. 多进程调度开销比较大。</li></ul></li><li><p>多线程</p><p>：</p><ul><li><strong>多线程的优点</strong>：1. 无需跨进程边界；2. 程序逻辑和控制方式简单；3. 所有线程可以直接共享内存和变量等；4. 线程方式消耗的总资源比进程方式好；</li><li><strong>多线程缺点</strong>：</li></ul><ol><li>每个线程与主程序共用地址空间，受限于2GB地址空间；</li><li><strong>线程之间的同步和加锁控制比较麻烦</strong>；</li><li>一个线程的崩溃可能影响到整个程序的稳定性；</li><li>到达一定的线程数程度后，即使再增加CPU也无法提高性能，例如Windows Server 2003，大约是1500个左右的线程数就快到极限了（线程堆栈设定为1M），如果设定线程堆栈为2M，还达不到1500个线程总数；</li><li><strong>线程能够提高的总性能有限</strong>，而且线程多了之后，线程本身的调度也是一个麻烦事儿，需要消耗较多的CPU</li></ol></li></ul><h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h2><ul><li><p>进程/线程/协程区别</p><ul><li><strong>进程拥有自己独立的堆和栈</strong>，<strong>既不共享堆，亦不共享栈</strong>，进程<strong>由操作系统调度</strong></li><li><strong>线程拥有自己独立的栈</strong>和<strong>共享的堆</strong>，共享堆，不共享栈，<strong>线程亦由操作系统调度</strong></li><li><strong>协程</strong>和线程一样<strong>共享堆，不共享栈</strong>，协<strong>程由程序员在协程的代码里显示调度</strong></li></ul></li><li><p>协程与线程区别</p><p>：</p><ul><li>一个线程可以多个协程，一个进程也可以单独拥有多个协程，这样python中则能使用多核CPU</li><li><strong>线程进程都是同步机制，而协程则是异步</strong></li><li>协程能保留上一次调用时的状态，每次过程重入时，就相当于进入上一次调用的状态</li><li><strong>协程避免了无意义的调度</strong>，由此可以提高性能，但也因此，<strong>程序员必须自己承担调度的责任</strong>，同时，<strong>协程也失去了标准线程使用多CPU的能力</strong></li></ul></li></ul><h3 id="Q：协程是如何更少占用资源的"><a href="#Q：协程是如何更少占用资源的" class="headerlink" title="Q：协程是如何更少占用资源的"></a>Q：协程是如何更少占用资源的</h3><ul><li>协程切换完全在用户空间进行，线程切换涉及用户态和内核态切换，需要在内核空间完成<ul><li>协程不依赖操作系统和其提供的线程</li><li><strong>协程之间的切换完全在用户态执行，在用户态没有时钟中断，系统调用等机制，因此效率高</strong>。<strong>协程切换只涉及基本的CPU上下文切换</strong>（寄存器保存 CPU运行任务所需要的信息），协程切换非常简单，就是把当前协程的 CPU 寄存器状态保存起来，然后将需要切换进来的协程的 CPU 寄存器状态加载的 CPU 寄存器上。</li><li>系统内核调度的对象是线程，<strong>线程的调度只有拥有最高权限的内核空间才可以完成，所以线程的切换涉及到用户空间和内核空间的切换</strong>，现代操作系统一般都采用抢占式调度，<strong>上下文切换一般发生在时钟中断和系统调用返回前</strong>，调度器计算当前线程的时间片，如果需要切换就从运行队列中选出一个目标线程，保存当前线程的环境，并且恢复目标线程的运行环境。</li></ul></li><li>协程占用内存少<ul><li>线程除了和协程相同基本的 CPU 上下文，还有线程私有的栈和寄存器等，上下文比协程多一些</li></ul></li></ul><h2 id="孤儿进程-amp-僵尸进程【怎么产生的？有什么危害？怎么去预防？】"><a href="#孤儿进程-amp-僵尸进程【怎么产生的？有什么危害？怎么去预防？】" class="headerlink" title="孤儿进程 &amp; 僵尸进程【怎么产生的？有什么危害？怎么去预防？】"></a>孤儿进程 &amp; 僵尸进程【怎么产生的？有什么危害？怎么去预防？】</h2><ul><li><p>一般进程，正常情况下：子进程由父进程创建，子进程再创建新的进程。父子进程是一个异步过程，父进程永远无法预测子进程的结束，所以，当子进程结束后，它的父进程会调用wait()或waitpid()取得子进程的终止状态，回收掉子进程的资源。</p></li><li><p><strong>孤儿进程</strong>：<strong>父进程结束了，而它的一个或多个子进程还在运行</strong>，那么这些子进程就成为孤儿进程(father died)。子进程的资源由init进程回收</p></li><li><p><strong>僵尸进程</strong>：<strong>子进程退出了，但是父进程没有用wait或waitpid去获取子进程的状态信息，子进程的进程描述符仍然保存在系统中</strong></p></li><li><p>危害</p><p>：</p><ul><li>如果父进程不调用wait或waitpid的话，那么保留的信息就不会被释放，其进程号就会被一直占用，但是系统所能使用的进程号是有限的，如果大量产生僵死进程，<strong>将因没有可用的进程号而导致系统无法产生新的进程</strong>，这就是僵尸进程的危害</li><li>孤儿进程是没有父进程的进程，它由init进程循环的wait()回收资源，init进程充当父进程。因此孤儿进程并没有什么危害</li></ul></li><li><p>预防/解决方法</p><p>：</p><ul><li>fork()两次，将子进程变成孤儿进程，从而其父进程变成init进程，通过init进程处理僵尸进程【fork函数的作用是从已经存在的进程中创建一个子进程，而原进程称为父进程】</li><li>通过信号机制，在处理函数中调用wait，回收资源</li></ul></li></ul><h3 id="同步-amp-异步"><a href="#同步-amp-异步" class="headerlink" title="同步 &amp; 异步"></a>同步 &amp; 异步</h3><ul><li><p>同步需要等待（阻塞），异步无需等待（不阻塞）</p></li><li><p>同步</p><p>：可以理解为在执行完一个函数或方法之后，一直等待系统返回值或消息，这时程序是出于阻塞的，只有接收到返回的值或消息后才往下执行其他的命令</p><ul><li>同步就是整个处理过程<strong>顺序执行</strong>，当各个过程都执行完毕，并返回结果。是一种<strong>线性执行的方式</strong>，<strong>执行的流程不能跨越</strong>。一般用于流程性比较强的程序，比如用户登录，需要对用户验证完成后才能登录系统。</li></ul></li><li><p>异步</p><p>：执行完函数或方法后，不必阻塞性地等待返回值或消息，只需要向系统委托一个异步过程，那么当系统接收到返回值或消息时，系统会自动触发委托的异步过程，从而完成一个完整的流程</p><ul><li><strong>异步</strong>则是只是发送了调用的指令，调用者无需等待被调用的方法完全执行完毕，而是继续执行下面的流程。<strong>是一种并行处理的方式</strong>，不必等待一个程序执行完，可以执行其它的任务，比如页面数据加载过程，不需要等所有数据获取后再显示页</li></ul></li></ul><h2 id="操作系统中的堆栈"><a href="#操作系统中的堆栈" class="headerlink" title="操作系统中的堆栈"></a>操作系统中的堆栈</h2><ul><li><p><strong>操作系统的堆和栈是指对内存进行操作和管理的一些方式</strong>这和数据结构中的堆和栈是有区别的</p></li><li><p>栈</p><p>：</p><ul><li>栈也可以称之为栈内存是一个具有动态内存区域，存储函数内部（包括main函数）的局部变量，方法调用及函数参数值</li><li><strong>由编译器/系统自动分配和释放</strong>。例如，声明在函数中一个局部变量，即int b，系统自动在栈中为变量b开辟空间</li><li>栈存放<strong>函数的参数值，局部变量的值</strong>等。其操作方式类似于数据结构中的栈，满足：“先进后出”的原则存取，也就是位于栈内的元素，必须等到其上面（对应的地址为较低的地址）的数据或函数执行完成后，弹出后才可以进行下面的元素的操作</li><li>栈是由系统自动分配的，一般速度较快（<strong>栈的速度高于堆的速度</strong>）</li><li>申请大小的限制：栈是向低地址扩展的，是一块连续的内存的区域。栈顶的地址和栈的最大容量<strong>是系统预先规定好的</strong>，栈的大小是2M（也有的说是1M，总之是一个编译时就确定的常数 ) ，<strong>如果申请的空间超过栈的剩余空间时，将提示overflow</strong>。因此，<strong>能从栈获得的空间较小</strong>。</li></ul></li><li><p>堆</p><p>：</p><ul><li>一般由程序员分配释放，并指明大小，堆被程序申请使用的内存在被主动释放前一直有效。堆需要由由程序员手动释放，<strong>不及时回收容易产生内存泄露</strong>。 程序结束时可能由操作系统回收。</li><li>栈是存放在一级缓存中的，而堆则是存放在二级缓存中的，<strong>堆的生命周期由虚拟机的垃圾回收<a href="https://www.nowcoder.com/jump/super-jump/word?word=%E7%AE%97%E6%B3%95">算法</a>来决定</strong>（并不是一旦成为孤儿对象就能被回收），所以调用这些对象的速度要相对来得低一些，故堆的速度慢于栈的速度</li><li>与数据结构中的堆是不同的，分配方式类似于<a href="https://www.nowcoder.com/jump/super-jump/word?word=%E9%93%BE%E8%A1%A8">链表</a>（空闲<a href="https://www.nowcoder.com/jump/super-jump/word?word=%E9%93%BE%E8%A1%A8">链表</a>法），<strong>堆是向高地址扩展的数据结构，是不连续的内存区域</strong>，这是由于系统是用<a href="https://www.nowcoder.com/jump/super-jump/word?word=%E9%93%BE%E8%A1%A8">链表</a>来存储空闲内存地址的，自然是不连续的，而<a href="https://www.nowcoder.com/jump/super-jump/word?word=%E9%93%BE%E8%A1%A8">链表</a>的遍历方向是由低地址向高地址。<strong>堆的大小受限于计算机系统中有效的虚拟内存</strong>。由此可见，堆获得的空间比较灵活，也比较大。</li></ul></li><li><p>区别</p><p>：</p><ul><li>空间分配：栈由操作系统自动分配释放；堆一般由程序员分配释放</li><li>申请效率对比：栈使用一级缓存，被调用时通常处于存储空间中，调用后被立即释放；.堆使用二级缓存，生命周期与虚拟机的GC<a href="https://www.nowcoder.com/jump/super-jump/word?word=%E7%AE%97%E6%B3%95">算法</a>有关，调用速度相对较低。</li><li>申请大小的限制：栈是向低地址扩展的数据结构，是一块连续的内存的区域；堆是向高地址扩展的数据结构，是不连续的内存区域</li></ul></li></ul><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p><a href="https://juejin.im/post/5c37577e6fb9a049fd100da8#heading-0">参考文章</a></p><ul><li>死锁是指<strong>多个进程</strong>在运行过程中因<strong>争夺资源</strong>而造成的一种僵局，当进程处于这种僵持状态时，若无外力作用，它们都将无法再向前推进</li></ul><h3 id="产生死锁的原因"><a href="#产生死锁的原因" class="headerlink" title="产生死锁的原因"></a>产生死锁的原因</h3><ul><li><strong>多个进程竞争资源</strong></li><li><strong>进程间推进顺序不当</strong></li></ul><h3 id="产生死锁的必要条件"><a href="#产生死锁的必要条件" class="headerlink" title="产生死锁的必要条件"></a>产生死锁的必要条件</h3><ul><li><strong>互斥</strong>条件，在任何时刻一个资源只能被一个进程使用</li><li><strong>拥有和请求</strong>（请求和保持条件），已经得到某个资源的进程可以再请求新的资源</li><li><strong>不可抢占</strong>（不剥夺条件），已经分配给进程的资源不能被抢占，而只能被显式释放</li><li><strong>循环等待</strong>（环路等待条件），系统中有两个或多个的进程组成一条循环，该循环中的每个进程都等待着另一个进程占有的资源</li></ul><h3 id="处理策略"><a href="#处理策略" class="headerlink" title="处理策略"></a>处理策略</h3><ol><li><p>解决死锁：【<strong>撤销进程法</strong>】</p></li><li><p>死锁预防</p><p>：破坏死锁产生的四个必要条件中的一个或多个，以避免发生死锁。【</p><p>资源有序分配法</p><p>】</p><ul><li>破坏互斥：不让资源被一个进程独占，可通过假脱机技术允许多个进程同时访问资源；</li><li>破坏拥有和请求：1. 已拥有资源的进程不能再去请求其他资源，要求进程在开始执行前请求需要的所有资源；2. 要求进程请求资源时，先暂时释放其当前拥有的所有资源，再尝试一次获取所需的全部资源</li><li>破坏不可抢占：有些资源可以通过虚拟化方式实现可抢占</li><li>破坏循环等待：1. 保证每个进程在任何时刻只能占用一个资源，如果要请求另一个资源，必须先释放第一个资源；是将所有资源进行统一编号，进程可以在任何时刻请求资源，但要求进程必须按照顺序请求资源</li></ul></li><li><p><strong>避免死锁</strong>：判断是否会出现死锁就是看是否能找到一个安全序列，使得进程按推进顺序为每个进程分配其所需资源，使每个进程都能顺序执行。例如：【**银行家<a href="https://www.nowcoder.com/jump/super-jump/word?word=%E7%AE%97%E6%B3%95">算法</a>**】</p></li><li><p><strong>检测死锁并恢复</strong>：资源分配图；从一个或多个进程中抢占资源分配给死锁进程；终止所有的死锁进程。【<strong>资源分配图化简法</strong>】</p></li></ol><h3 id="如何发现死锁？"><a href="#如何发现死锁？" class="headerlink" title="如何发现死锁？"></a>如何发现死锁？</h3><ul><li>通过死锁检测工具，例如通过jdk工具jps、jstack排查死锁问题</li></ul><ol><li><strong>使用jsp查找程序进行</strong>：jps是jdk提供的一个工具，可以查看到正在运行的java进程</li><li><strong>使用jstack查看线程堆栈信息</strong>：jstack：jdk提供的一个工具，可以查看java进程中线程堆栈信息，后面可以查看到具体在代码哪一行。</li><li>也通过jdk提供的工具<strong>jconsole排查死锁问题</strong>：jconsole是<strong>jdk提供的一个可视化的工具</strong>，方便排查程序的一些问题，如：程序内存溢出、死锁问题等等。</li></ol>]]></content>
      
      
      <categories>
          
          <category> operate </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络</title>
      <link href="2021/03/15/network/"/>
      <url>2021/03/15/network/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><h3 id="传输时延"><a href="#传输时延" class="headerlink" title="传输时延"></a>传输时延</h3><p><font color="green">时延指数据（一个报文或分组，甚至比特）从网络的一段传送到另一端所需的时间。</font></p><ul><li>$总时延=发送时延+传播时延+处理时延+排队时延$</li></ul><ol><li>发送时延</li></ol><p>主机或路由器发送数据帧所需要的时间。(从发送数据帧的第一个比特算起，到该帧的最后一个比特发送完毕所需要的时间)。</p><p>$ sendTime=length of data(bit) / velocity(bit/s)$</p><ol start="2"><li>传播时延</li></ol><p>信道中传输时间。</p><p>$propagate=length of channel(m) / electromagnetic wave velocity (m/s) $</p><ol start="3"><li>处理时延</li></ol><p>主机或路由器收到分组，分析分组的首部、从分组中提取数据部分、进行差错检验、寻找下一个路由器地址等。</p><ol start="4"><li>排队时延</li></ol><p>分组进入路由器在输入队列排队，在发送后输出队列排队发送。</p><p><img src="/2021/03/15/network/OSI%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B.PNG"></p><h3 id="网络性能指标"><a href="#网络性能指标" class="headerlink" title="网络性能指标"></a>网络性能指标</h3><ul><li><p>速率(bit/s)</p><p>1K=$10^3$ M G T P E Z Y</p><p><font color="red">电脑上显示的M指的是 按照存储格式讲的，存储计算机1024bit $k=2^{10}$  K M G T P E Z Y</font></p></li><li><p>带宽</p></li></ul><p>通信上讲的带宽，3.0Ghz ~3.4 Ghz  0.4  按照频率范围上讲的。</p><p>计算机网络中，带宽指的是信道传输的最大速率。</p><h3 id="ADSL-Asymmetric-Digital-Subscriber-Line"><a href="#ADSL-Asymmetric-Digital-Subscriber-Line" class="headerlink" title="ADSL (Asymmetric Digital Subscriber Line)"></a>ADSL (Asymmetric Digital Subscriber Line)</h3><p><img src="/2021/03/15/network/adsl.PNG" alt="adsl"></p><h3 id="HFC-Hybrid-Fiber-Coax-光纤同轴混合网"><a href="#HFC-Hybrid-Fiber-Coax-光纤同轴混合网" class="headerlink" title="HFC(Hybrid Fiber Coax)光纤同轴混合网"></a>HFC(Hybrid Fiber Coax)光纤同轴混合网</h3><p><img src="/2021/03/15/network/%E8%B0%83%E5%88%B6%E8%A7%A3%E8%B0%83%E5%99%A8.PNG" alt="调制解调器"></p><h4 id="FTTx技术"><a href="#FTTx技术" class="headerlink" title="FTTx技术"></a>FTTx技术</h4><p>光纤到户(FTTH)</p><h2 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h2><h3 id="1-点对点信道"><a href="#1-点对点信道" class="headerlink" title="1. 点对点信道"></a>1. 点对点信道</h3><p>链路：一个点到邻近结点的一条物理线路。数据链路是除了链路，还要有必要的通信协议进行传输，把所有这些协议的硬件和软件加到链路，叫做数据链路。</p><ol><li><p>结点A把网络层IP数据报添加首部和尾部。</p></li><li><p>结点A把封装好的数据发送给B的数据链路层。</p></li><li><p>B先进行差错检验，无错提取IP数据报，否则丢弃。</p></li></ol><p>a) <font color="green">封装成帧</font></p><p>添加首尾部。最大传输数据单元(Maximum Transfer Unit,MTU)，数据部分的最大长度上限。帧定界符 开始 SOH (00000001)  结束EOT(00000100)。</p><p>b) <font color="green">透明传输</font></p><p>数据部分是文本文件中的字符时，不可能和控制字符相同，任何内容都可以通过帧传过去，所以是透明传输。</p><p>当信息是图片时，可能会出现控制符一样的二进制位。</p><p><img src="/2021/03/15/network/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E9%80%8F%E6%98%8E%E4%BC%A0%E8%BE%93.png"></p><p>解决办法，插入转义字符ESC(00011011),接收端将数据发往网络层要删除所有的ESC。</p><p><img src="/2021/03/15/network/ESC%E8%BD%AC%E4%B9%89%E5%AD%97%E7%AC%A6.png"></p><p>c) <font color="green">差错检验</font></p><p>循环冗余检测(Cyclic Redundancy Check，CRC)。增加n位冗余码（除以n+1位除数）。</p><p>FCS(Frame Check Sequence)。</p><p>接收端，如果R（余数）算出来是0，则accept。否则，丢弃。</p><p>增加了帧编号、确认、重传机制。</p><h3 id="PPP-Point-to-Point-Protocal"><a href="#PPP-Point-to-Point-Protocal" class="headerlink" title="PPP(Point-to-Point Protocal)"></a>PPP(Point-to-Point Protocal)</h3><ol><li><font color="green">协议的组成</font></li></ol><p>a) 封装到链路的方法。</p><p>b) <strong>LCP链路控制协议</strong>，建立配置和测试链路连接。RFC1661定义了11种类型的LCP分组。</p><p>c) <strong>网络控制协议NCP</strong>。其中的每一个协议支持不同的网络层协议，如IP、OSI的网络层。</p><ol start="2"><li><font color="green">协议帧的格式</font></li></ol><p><img src="/2021/03/15/network/PPP%E5%8D%8F%E8%AE%AE%E5%B8%A7%E7%9A%84%E6%A0%BC%E5%BC%8F.png"></p><p>首部4个字段：7E PPP的定界符。FF 03 至今没给出定义。协议 是2字节协议字段， 0x0021时，PPP的信息是IP数据报，0xC021，是PPP协议的控制协议LCP的数据。</p><p>信息部分可变化，最长1500字节。</p><p>FCS冗余码。</p><ol start="3"><li><font color="green">零比特填充</font>（同步传输）</li></ol><p>5个连续1后面插入0。以此来保证透明传输。</p><p><img src="/2021/03/15/network/%E9%9B%B6%E6%AF%94%E7%89%B9%E5%A1%AB%E5%85%85.png"></p><ol start="4"><li><font color="green">协议的工作状态</font></li></ol><p><img src="/2021/03/15/network/PPP%E5%8D%8F%E8%AE%AE%E7%8A%B6%E6%80%81%E5%9B%BE.png"></p><p>PPP协议起始和终止都处于“链路静止”状态。之后用户向ISP拨号，与ISP建立物理链路，然后LCP链路开始进行协议协商，如果成功，则开始进行网络层协议（NCP）协商，如果是IP协议则是IPCP（IP控制协议），将IPCP封装成帧。网络层配置结束，数据链路开始工作（链路打开）。</p><p>图中可以看出PPP协议不是单纯的数据链路层协议，还包括物理层内容和网络层内容。</p><h3 id="2-使用广播信道的数据链路层（CSMA-CD"><a href="#2-使用广播信道的数据链路层（CSMA-CD" class="headerlink" title="2.使用广播信道的数据链路层（CSMA/CD)"></a>2.使用广播信道的数据链路层（CSMA/CD)</h3><p><img src="/2021/03/15/network/%E5%B1%80%E5%9F%9F%E7%BD%91%E6%8B%93%E6%89%91.png"></p><p><font color="green">1. 共享信道的两种划分方法</font></p><p>a) 静态划分信道</p><p>频分复用、时分复用、码分复用和波分复用等。开销较大。</p><p>b) 动态媒体接入控制</p><ul><li>随机接入</li></ul><p>用户根据自己的情况随机发送信息，可能产生碰撞，需要碰撞协议。</p><ul><li>受控接入</li></ul><p>不能随机发送，比如令牌环局域网和及集中控制的轮询和多点线路探询。</p><p><font color="green">2. 以太网的两个标准</font></p><p>IEEE 802委员会提出将数据链路层划分为 <strong>逻辑链路控制LLC</strong>（Logic Link Control) 和 <strong>媒体接入控制层MAC</strong>(Media Access Control)。</p><p><img src="/2021/03/15/network/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E5%88%92%E5%88%86.png"></p><p>LLC与传输媒体无关，MAC处理传输媒体有关的内容。</p><p>之后因为以太网的发展，局域网技术没落，目前大部分厂商只MAC协议，LLC作用已经消失。</p><p><font color="green">3. 适配器的作用</font></p><p>计算机和外界局域网连接需要<strong>适配器</strong>。适配器和计算机之间通过IO总线传输信息，适配器和局域网通过双绞线和电缆传输信息。</p><p>适配器功能不局限于数据链路层，适配器在接发各种帧时不使用CPU，当帧判断可用时，才会发出中断信息通知计算机，并交付协议栈中的网络层。</p><p><font color="green">4.CSMA/CD协议</font>(Carrier Sense Multiple Access with Collision Detection)<strong>载波监听多点接入/碰撞</strong></p><p>以太网发送数据都是用 <strong>曼彻斯特编码</strong>。变化频率变化了一倍，所以频率开销增大。</p><p><img src="/2021/03/15/network/%E6%9B%BC%E5%BD%BB%E6%96%AF%E7%89%B9%E7%BC%96%E7%A0%81.png"></p><ul><li>多点接入：多个计算机同时连接在一根总线上。</li><li>载波监听：使用电子技术检测总线上有没有其他计算机在发送数据。载波只是名词，就是检测信道，检测其他计算机发没发信息。</li><li>碰撞检测（冲突检测）：边发送边监听，适配器边发送边检测信道上的信号电压信号，以便于发送数据时监听其他计算机发没发数据。当两个计算机同时发送数据，则碰撞，随机等待一段时间再发送。</li><li><strong>电磁波在1km的电缆传播时延是5us。</strong></li><li>发送数据总有传播时延，当传播时延内另一个计算机发了数据，则碰撞。所以一个计算机最多消耗**两倍$2\tau$**的总线到端的传播时延。</li></ul><p><img src="/2021/03/15/network/%E4%BC%A0%E6%92%AD%E6%97%B6%E5%BB%B6%E5%AF%B9%E8%BD%BD%E6%B3%A2%E7%9B%91%E5%90%AC%E7%9A%84%E5%BD%B1%E5%93%8D.png"></p><p>可以看出，一个计算机只能半双工通信，图中看出每次计算机发送信号都不确定是否会碰撞，$2\tau$时延就是<strong>碰撞窗口</strong>（争用期）。</p><ul><li><strong>截断二进制指数退避</strong>(truncated binary exponential backoff)</li></ul><ol><li>$2\tau$协议规定为51.2us。对于10Mbit/s以太网，发送512bit。所以碰撞窗口期是发送512bit时间。</li><li>$k=min[重传次数…10]$ 从离散整数集合$[0,1,…,(2^k-1)]$ 选取整数即为重传次数，必须小于10。</li><li>重传大于16次，丢弃帧，向高层报告。</li></ol><ul><li>强化碰撞</li></ul><p>当发送数据后，还要继续发送32或48bit人为干扰信号，让所有用户都知道已经发生了碰撞。</p><p><img src="/2021/03/15/network/%E4%BA%BA%E4%B8%BA%E5%B9%B2%E6%89%B0%E4%BF%A1%E5%8F%B7.png"></p><ul><li>设定帧间最小间隔9.6us.给接收方96bit时间做准备处理下一次数据。</li></ul><p><img src="/2021/03/15/network/CSMA%E5%8D%8F%E8%AE%AE%E8%A6%81%E7%82%B9.png"></p><ul><li>集线器 局域网星型拓扑，可靠性很好，使用双绞线连接，出现802.3i 10BASE-T标准。10代表10Mbit/s数据。</li></ul><p>实际上还是抽象成总线形式，所以每个时间只允许一个站发送数据。</p><p><strong>集线器工作在物理层</strong>，每个端口仅仅转发信号。</p><h3 id="3-信道利用率"><a href="#3-信道利用率" class="headerlink" title="3. 信道利用率"></a>3. 信道利用率</h3><h3 id="4-mac-地址"><a href="#4-mac-地址" class="headerlink" title="4.mac 地址"></a>4.mac 地址</h3><p>每一个适配器都有一个MAC地址。固化在适配器ROM中的地址。</p><p>MAC的格式：</p><p><img src="/2021/03/15/network/MAC%E5%9C%B0%E5%9D%80.png"></p><p>前两个字段是目的地址和源地址，分别占6个字节。第三个字段是类型，表明数据部分使用的协议是什么。最后是冗余码(fcs crc)。</p><p>数据部分最小长度46，不满46就填充够46。</p><p>MAC帧前还有8个字节，前7字节是为了同步时钟频率，最后一个帧开始界定符。</p><h3 id="5-扩展以太网"><a href="#5-扩展以太网" class="headerlink" title="5. 扩展以太网"></a>5. 扩展以太网</h3><ol><li>物理层扩展</li></ol><p>增加解调器扩大物理链路交流区域。</p><p><img src="/2021/03/15/network/%E6%89%A9%E5%B1%95%E4%BB%A5%E5%A4%AA%E7%BD%91%E7%89%A9%E7%90%86%E5%B1%82.png"></p><ol start="2"><li>数据链路层扩展</li></ol><p>交换式集线器称为以太网交换机或者第二层交换机。实质上是多接口的网桥。其内部通过自学习算法存储帧交换表。</p><p>独占传输媒体，无碰撞地传输数据。</p><p>生成树协议STP，不改变网络拓扑，逻辑上没有闭环，防止兜圈子问题。</p><ol start="3"><li>虚拟局域网VLAN</li></ol><p><img src="/2021/03/15/network/%E8%99%9A%E6%8B%9F%E5%B1%80%E5%9F%9F%E7%BD%91VLAN.png"></p><p>可以防止广播风暴，A1发送信息只有A组能够看到。</p><p>帧格式：</p><p><img src="/2021/03/15/network/VLAN%E5%B8%A7%E6%A0%BC%E5%BC%8F.png"></p><p>在MAC帧中插入4字节VLAN标记，源地址后两位如果是0x8100时，表明后面加了VLAN。源地址的最后两个字节中，前3位是用户优先级字段，接着一位是规范格式符CFI，最后12位是虚拟局域网VLAN标识符VID，它标记了这个以太网帧属于哪个虚拟局域网。</p><h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><p>网络层只提供尽最大努力交付服务，可以减少路由器价格成本等，因为计算机本身具有很强的计算能力，差错检验能力很强。</p><h4 id="1-网络协议IP"><a href="#1-网络协议IP" class="headerlink" title="1.网络协议IP"></a>1.网络协议IP</h4><p>一般指的是第四个版本IPv4。一般和<strong>地址解析协议</strong>(Address Resolution Protocol,ARP)、<strong>网际控制报文协议ICMP</strong>(Internet Control Message Protocol)、<strong>网际组管理协议IGMP</strong>（Internet Group Management Protocol）。</p><p><img src="/2021/03/15/network/IP%E5%8F%8A%E5%85%B6%E9%85%8D%E5%A5%97%E5%8D%8F%E8%AE%AE.png"></p><p>2.网络互连的中间设备</p><ol><li><p>物理层使用的中间设备是<strong>转发器</strong>。</p></li><li><p>数据链路层使用的中间设备是<strong>网桥或桥接器</strong>。</p></li><li><p>网络层使用的中间设备是<strong>路由器</strong>。</p></li><li><p>网络层以上使用的中间设备叫<strong>网关</strong>。网关连接两个不兼容的系统需要在高层进行协议转换.</p><p>3.虚拟互联网络</p></li></ol><p>由于不同的计算机网络使用相同的IP协议。因此可以看做虚拟互连网络</p><p><strong>直接交付</strong>目的主机在本网络中不需要其他路由器转发。</p><p><strong>间接交付</strong>目的主机不在本网络。</p><h4 id="2-分类的IP地址"><a href="#2-分类的IP地址" class="headerlink" title="2.分类的IP地址"></a>2.分类的IP地址</h4><p>IP地址就是互联网上每一台主机的每一个接口分配一个在全世界范围内唯一的32位标识符。IP地址现在由<strong>互联网名字和数字分配机构ICANN</strong>（Internet Corporation for Assigned Names and Numbers)进行分配。</p><p>IP地址的<strong>第一个字段</strong>是网络号，标志主机所连接到的网络。一个网络号在整个互联网范围内是唯一的。<strong>第二个字段</strong>是主机号，它标志该主机</p><p><img src="/2021/03/15/network/IP%E7%BD%91%E7%BB%9C%E5%8F%B7%E5%AD%97%E6%AE%B5.png"></p><p>$ IP地址 :: = {&lt;网络号&gt;,&lt;主机号&gt;}$</p><ul><li>A类、B类和C类网络号字段数分别是1、2和3.网络号字段的最前面有1-3位是类别位，数值分别是0,10，110。</li><li>A类、B类和C类地址的主机号分别为3、2和1。</li><li>D类地址用于多播。</li><li>E类地址保留为以后使用。</li></ul><h4 id="3-常用的3类地址"><a href="#3-常用的3类地址" class="headerlink" title="3.常用的3类地址"></a>3.常用的3类地址</h4><ul><li>A类 主机号占3个字节，因此每个A类网络最大主机数是$2^{24}-2$。全0主机号字段表示“这个”，保留地址意思是“本网络”，例如某主机IP5.6.7.8那么其本地网络就是5.0.0.0。全1表示网络上所有的主机。A类共有$2^{31}$个地址。</li><li>B类 两个字节，前面两位固定，剩下14位分配网络号。14位不可能全0和全1。<strong>所以不需要减2</strong>。但是<strong>128.0.0.0</strong>是不指派的，B类最小网路地址是<strong>128.1.0.0</strong>。所以网络数是$2^{14}-1$。B类共$2^{30}$地址。</li><li>C类 三个字节网络号，110。网络号还有21位可以分配。<strong>192.0.0.0</strong>不指派，C类<strong>192.0.0.0</strong>不指派，可以使用的最小网络地址是<strong>192.0.1.0</strong>。这样C类地址可以指派的网络总数是$2^{21}-1$。共$2^{29}$地址。</li></ul><p><img src="/2021/03/15/network/IP%E5%88%86%E9%85%8D%E8%8C%83%E5%9B%B4.png"></p><h4 id="4-IP地址和硬件地址"><a href="#4-IP地址和硬件地址" class="headerlink" title="4.IP地址和硬件地址"></a>4.IP地址和硬件地址</h4><p><img src="/2021/03/15/network/ip%E5%9C%B0%E5%9D%80%E4%B8%8E%E7%A1%AC%E4%BB%B6%E5%9C%B0%E5%9D%80.png"></p><p>数据从高层向底层传输。网络层和网络层以上使用IP地址，数据链路层及其以下的使用硬件地址。</p><p><img src="/2021/03/15/network/%E4%B8%8D%E5%90%8C%E5%B1%82%E6%AC%A1%E7%9A%84%E5%9C%B0%E5%9D%801.png"></p><p><img src="/2021/03/15/network/%E4%B8%8D%E5%90%8C%E5%B1%82%E6%AC%A1%E7%9A%84%E5%9C%B0%E5%9D%80.png"></p><ol><li>路由器只根据目的站的IP地址的网络号进行选择。</li><li>局域网链路层只看到MAC帧。IP数据报被封装在MAC帧中，MAC帧在不同网络上传送时，其MAC帧首部中的源地址和目的地址发生变化。图中可以看出，MAC从H1到R1传送，源地址和目的地址是HA1和HA3，R1收到帧后，重新添加源地址和目的地址HA4和HA4。</li></ol><h4 id="5-地址解析协议ARP"><a href="#5-地址解析协议ARP" class="headerlink" title="5.地址解析协议ARP"></a>5.地址解析协议ARP</h4><p><strong>知道了IP地址，如何找到其对应的MAC地址呢？</strong></p><p><img src="/2021/03/15/network/ARP%E5%8D%8F%E8%AE%AE%E7%9A%84%E4%BD%9C%E7%94%A8.png"></p><p>还有一个RARP逆地址解析协议，现在的DHCP协议包含了RARP，不需要再讲。</p><ul><li><strong>ARP解决</strong>这个问题的方法是在主机ARP高速缓存中存放一个从<strong>IP地址到硬件地址的映射表</strong>，并且这个映射表还经常动态更新（新增或超时删除）。</li></ul><p>A向B发数据报，先在ARP高速缓存中查看B的IP地址，如果有再找ARP映射表，找到硬件地址就放到MAC帧中。如果B刚刚加入网络，找不到B硬件地址，则：</p><p><img src="/2021/03/15/network/ARP%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.png"></p><ul><li>ARP找硬件地址步骤：</li></ul><ol><li>A发送ARP请求广播。</li><li>网络上所有主机收到广播信息。</li><li>B收到请求，向A发送自己地址。（B可以收到A的所有ARP缓存信息，方便以后和本网络（局域网）中所有主机通信）。</li><li>A收到B地址更新ARP高速缓存。</li></ol><ul><li><strong>生存时间</strong>：10~20min。超时就剔除那个硬件地址。（防止某个时刻B的硬件更换导致硬件地址变化）。</li><li><strong>实际是按照硬件地址通信的</strong>，那么为什么还要有IP呢？</li></ul><p>全世界不同网络使用不同的硬件地址，这些网络互相通信就必须做硬件地址转换工作，会使网络十分复杂。IP就屏蔽了这个问题。</p><h4 id="6-IP数据报格式"><a href="#6-IP数据报格式" class="headerlink" title="6.IP数据报格式"></a>6.IP数据报格式</h4><p>TCP/IP中各种数据格式常常以32位（4字节）描述。</p><p><img src="/2021/03/15/network/IP%E6%95%B0%E6%8D%AE%E6%8A%A5%E6%A0%BC%E5%BC%8F.png"></p><ol><li>首部。</li></ol><p>5个4字节描述（共20字节，每个4*8=32位）。</p><ul><li><strong>版本</strong> 4位，IP协议的版本，双方通信的IP版本必须一致。</li><li><strong>首部长度</strong> 4位，可表示最大十进制数是15。一般是0101（5,5*4=20），当首部长度为最大值1111，则60字节（15*4）。</li><li><strong>区分服务</strong> 占8位，用来获得更好的服务。这个字段在旧的标准叫做服务类型。实际一直没用过。</li><li><strong>总长度</strong> 总长度指首部和数据之和的长度，单位为字节。总长度为16位，数据报最大长度为$2^{16}-1$字节。<strong>MTU</strong>(Maximum Transfer Unit)。当一个IP数据报封装成链路层的帧时，此数据报的总长度一定不能超过下面数据链路层规定的MTU值。当超过就要分片。</li><li><strong>标识</strong> 占16位，IP软件有一个计数器，产生一个数据报计数器加1，赋给标识字段，解决IP数据报不是按序接收的问题。</li><li><strong>标志</strong> 占3位，目前只有两位有意义。最低位MF=1，表示后面还有分片，MF=0表示最后数据分片中最后一个。中间一位DF=1表示不能分片，DF=0允许分片。</li><li><strong>片偏移</strong> 占13位。较长的分组在分片后，某片在原分组中的相对位置，相对用户数据字段的起点。片偏移以8个字节为偏移单位，每个分片长度一定是8字节的整数倍。</li><li><strong>生存时间</strong> 8位，TTL(Time To Live)，表明这是数据报在网络中的寿命。发出数据报的源点设置这个字段。其目的是防止无法交付的数据报无限制地在互联网兜圈子。现在TTL指传几跳路由器，经过一个路由器就减一。初始TTL=1只能在本地局域网络传送。</li><li><strong>协议</strong> 占8位，协议字段指出数据报携带的数据是使用何种协议，以便使目的主机的IP层知道应将数据部分交给上层哪个协议处理。</li><li><strong>首部检验和</strong> 16位，只检验数据报的首部，不检验数据部分可以减少工作量。检验方法如图：</li></ul><p><img src="/2021/03/15/network/ip%E6%A3%80%E9%AA%8C%E9%A6%96%E9%83%A8%E5%92%8C.png"></p><p><strong>发送方</strong>将所有首部划分为16位序列，所有16位相加计算反码写入检验和字段。</p><p><strong>接收方</strong>收到数据报后将首部的所有16位再使用反码算数相加，得到的和计算反码和数据报中的检验和字段相加，结果必为0，否则出错。</p><ul><li><p><strong>源地址</strong> 32位。</p></li><li><p><strong>目的地址</strong> 32位。</p></li><li><p><strong>可变部分</strong> 可变从1-40字节不等。用来支持排错、测量以及安全等措施。实际上很少使用（增加计算开销）。</p></li><li><p>路由表中主要信息：</p></li></ul><p>$(目的网络地址，下一跳地址)$</p><p><img src="/2021/03/15/network/ip%E8%B7%AF%E7%94%B1%E8%A1%A8%E4%BF%A1%E6%81%AF.png"></p><ol start="2"><li>默认路由</li></ol><p><img src="/2021/03/15/network/%E9%BB%98%E8%AE%A4%E8%B7%AF%E7%94%B1.png"></p><p>主机发送IP数据报时要查找路由表，如果一台主机连接在一个小网络上，这个网络只用一台路由器连接，那么使用默认路由。</p><ol start="3"><li>分组转发</li></ol><p>路由器收到数据报，从路由表知道下一跳IP地址后，利用ARP将IP地址转换为硬件地址放入MAC帧首部，从而送给下一跳路由器或主机。</p><h4 id="7-划分子网"><a href="#7-划分子网" class="headerlink" title="7.划分子网"></a>7.划分子网</h4><ol><li>从两级IP地址到三级IP地址</li></ol><p>两级IP地址（网络号+主机号）问题：</p><ul><li><p>浪费。A类主机数超过1000万，B类超过6万。很多公司宁愿申请A和B类也不想要C。造成IP资源浪费。</p></li><li><p>每一个物理网络分配网络号使得路由表太大，网络性能变差。</p></li></ul><p><strong>三级IP</strong>增加子网号字段：<strong>划分子网</strong>。</p><p>$ IP地址 ::={&lt;网络号&gt;，&lt;子网号&gt;，&lt;主机号&gt;}$</p><ul><li>其他网络发给本单位的IP数据报，根据网络号找到本单位网络，本网络收到后，按照子网号找到目的子网。</li></ul><p><img src="/2021/03/15/network/%E5%88%92%E5%88%86%E5%AD%90%E7%BD%91.png"></p><p><img src="/2021/03/15/network/%E5%88%92%E5%88%86%E5%AD%90%E7%BD%911.png"></p><ol start="2"><li>子网掩码</li></ol><p>使用子网掩码找到子网中的目的主机。</p><p><img src="/2021/03/15/network/%E5%AD%90%E7%BD%91%E6%8E%A9%E7%A0%81.png"></p><p>不管网络有没有划分子网，只要把子网掩码和IP地址进行按位与，就能得到网络地址。</p><p>如果网络没有划分子网，路由器就默认使用<strong>默认子网掩码</strong>。</p><p><img src="/2021/03/15/network/%E9%BB%98%E8%AE%A4%E5%AD%90%E7%BD%91%E6%8E%A9%E7%A0%81.png"></p><p>路由器现在交换信息，必须把自己的子网掩码告诉相邻路由器，这样路由表还给出了每个网络的子网掩码。</p><ul><li>减少了可用主机数。</li><li><strong>划分子网的分组转发</strong>：</li></ul><p>$(目的网络地址，下一跳地址，子网掩码)$</p><ol><li>收到的数据报提取IP地址D。</li><li>判断直接交付。子网掩码与D按位与，得到网络号和<strong>本网络</strong>不匹配间接交付执行3，匹配直接交付。</li><li>路由表有D特定主机路由，则根据路由表IP发送下一跳，否则4。</li><li>对路由表每一行按位与得到结果N。若N与某行网络地址匹配，则发给下一跳，否则5。</li><li>发送默认路由，否则6。</li><li>分组出错。</li></ol><p><img src="/2021/03/15/network/%E5%AD%90%E7%BD%91%E5%88%86%E7%BB%84%E8%BD%AC%E5%8F%91.png"></p><p><img src="/2021/03/15/network/%E5%AD%90%E7%BD%91%E4%BA%A4%E4%BB%98%E8%BF%87%E7%A8%8B.png"></p><h4 id="8-构造超网-（CIDR"><a href="#8-构造超网-（CIDR" class="headerlink" title="8.构造超网 （CIDR)"></a>8.构造超网 （CIDR)</h4><p><strong>无分类域间路由选择CIDR</strong>(Class Inter-Domain Routing)。</p><p>1）消除了传统的A类、B类和C类地址以及划分子网概念。把32位地址划分前后两个部分，前面的部分是<strong>网络前缀</strong>，后面的部分指明主机。</p><p>$IP地址 ::={&lt;网络前缀&gt;，&lt;主机号&gt;}$</p><p>在IP地址后面加上斜线“/”写上网络前缀所占的位数。例如：206.0.64.0/18</p><p>2）网络前缀都相同的连续IP组成一个“CIDR地址块”。只要知道CIDR地址块中的任何一个地址，就可以知道地址块的起始地址（最小地址）和最大地址。使用<strong>32位地址掩码</strong>。</p><p>3）最长前缀匹配。超网路由，网络前缀和下一跳地址组成。每次匹配可能会有多条匹配结果，选取匹配前缀最长的。</p><p>4）使用<strong>二叉线索</strong>查找路由表。</p><p><img src="/2021/03/15/network/%E4%BA%8C%E5%8F%89%E7%BA%BF%E7%B4%A2%E6%90%9C%E7%B4%A2%E6%A0%91.png"></p><h4 id="9-网际控制报文协议ICMP"><a href="#9-网际控制报文协议ICMP" class="headerlink" title="9.网际控制报文协议ICMP"></a>9.网际控制报文协议ICMP</h4><p><img src="/2021/03/15/network/ICMP%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F.png"></p><ul><li>有<strong>ICMP差错报告报文</strong>和<strong>ICMP询问报文</strong> 两类。</li></ul><p><img src="/2021/03/15/network/ICMP%E6%8A%A5%E6%96%87%E6%95%B0%E6%8D%AE.png"></p><p>1）终点不可达。 当路由器或主机不能交付数据报时就向源点发送终点不可达报文。</p><p>2）时间超过 当数据报的生存时间为0，丢弃该数据包，还要向源点发送时间超过报文。<strong>或</strong>终点在预定时间内不能收到数据报的全部数据片，就将数据报片丢弃，并向源点发送时间超过报文。</p><p>3）参数问题 数据报首部中有字段的值不正确时，丢弃该数据报，并向IP发送参数问题报文。</p><p>4）改变路由（重定向） 路由器把改变报文发送给主机，让主机知道下次应该发给另外的路由器。</p><p>5）回送请求和回答 由主机或路由向特定目的主机发出询问。收到此报文的主机向源主机或路由器发送ICMP回送回答报文。主要来测试目的站是否可达以及了解相关状态。</p><p>6）时间戳请求和回答。 I请求某台主机回答当前日期和时间。可用于时钟同步和时间测量。</p><ul><li><p>应用</p><p><strong>PING</strong>测试两主机连通性。</p><p><strong>traceroute（unix，windows 是tracert）</strong> 跟踪从源点到终点的路径。</p></li></ul><h3 id="10-路由选择协议"><a href="#10-路由选择协议" class="headerlink" title="10. 路由选择协议"></a>10. 路由选择协议</h3><ol><li>分层次的路由选择协议。</li></ol><p>1）互联网的规模非常大。路由器如果要知所有网络路径，路由表非常大处理费时。</p><p>2）许多单位不愿意外界了解自己的布局细节但是还想连接到互联网上。</p><p>所以，分成很多自治系统（Autonomous System ,AS），一个AS对其他AS表现出的是一个单一的和一致的路由选择策略。</p><p>选择协议分为两类：<strong>内部网关协议IGP（Interior Gateway Protocol）</strong>和<strong>外部网关协议EGP（External Gateway Protocol）</strong>。</p><p>IGP：自治系统内部使用的路由选择协议，与其他自治系统选择什么路由协议无关。如RIP和OSPF。<strong>域内路由选择</strong>。</p><p>EGP：不同的自治系统间的协议。例如BGP版本4（BGP-4）。<strong>域间路由选择</strong>。</p><ol start="2"><li><strong>RIP</strong>（Routing Information Protocol）</li></ol><p>基于距离向量的路由选择协议。距离定义：每经过一跳路由器就+1。例如直连路由是1。所以RIP适用于（小型网络）。</p><ul><li>RIP不能在两个主机间同时使用多个路由，RIP选择一条最少路由器的路由，哪怕还存在另一条高速但路由器较多的路由。</li><li>仅和相邻路由交换信息。</li><li><strong>距离选择算法</strong></li></ul><p>1）对地址为X的相邻路由发来的RIP报文，把“下一跳”字段中的地址改为X，并把所有“距离”加1。每一个项目都有三个关键数据：目的网络N，距离d，下一跳路由器X。</p><p>2）对修改后的RIP报文每一个项目：</p><p>若原来路由表<strong>没有</strong>目的网络N，则把该项目添加到路由表中。</p><p>否则（有N）：</p><p>若下一跳路由器是X，则把收到的项目替换为原来的路由表中的项目。</p><p>否则（到目的网络N的下一跳不是X）：</p><p>收到的项目中的距离d小于路由表中的距离，则进行更新。否则什么也不做。</p><p>3）3分钟还没有收到相邻路由器的更新路由表，则把相邻路由器记为不可达的路由器，即距离设置为<strong>16</strong>。</p><p>4）返回。</p><p>这个算法基础是<strong>Bellman-Ford算法</strong>。（求A到B最短路径）</p><p>例题<strong>直接看书P155页 例题</strong>，看一眼如何更新表就懂了。</p><ul><li>RIP协议的报文格式</li></ul><p><img src="/2021/03/15/network/Rip%E5%8D%8F%E8%AE%AE%E6%A0%BC%E5%BC%8F.png"></p><p>一个RIP报文最多携带25个路由，所以最大长度4+20*25=504字节。<strong>使用UDP传送</strong>。</p><p>RIP的首部占4个字节，其中命令字段指出报文的意义。例如1表示请求路由信息，2表示请求路由信息的响应或未被请求而发出的路由更新报文。首部后面的必为0为了4字节对齐。</p><ul><li>RIP协议存在的问题</li></ul><p>当网络出现故障时，要经过较长时间才能将此信息传送到所有路由器。<strong>好消息传得快，坏消息传的慢</strong>。例子：</p><p><img src="/2021/03/15/network/Rip%E5%8D%8F%E8%AE%AE%E7%9A%84%E9%99%90%E5%88%B6.png"></p><p>图中“1,1，直接“指到网络1,1跳，直接交付。 网络1出现了故障，R1无法到达网1。于是路由器R1把到网1的距离改为16。但是，很可能经过30秒钟后R1才把更新信息发送给R2。R2可能已经先把自己的路由表发给R1，其中有”1,2，R1“这一项。</p><p>R1收到R2的更新报文后，把1,2，R1更新为1,3，R2。之后会再把更新后的信息发给R2。R2又更新自己的路由表为1，4，R1。如此往复直到加到16。</p><ol start="3"><li><strong>OSPF</strong> 开放最短路径优先(Open Shortest Path First)</li></ol><p>它是为克服RIP的缺点在1989年开发出来的。</p><p>使用了Dijkstra提出的<strong>最短路径算法SPF</strong>。</p><p>特点：</p><p>1）向本自治系统中所有路由器发送信息。使用<strong>洪泛法</strong>。路由器通过所有输出端口向所有相邻路由器发送信息。而每一个相邻路由器又再将此信息发往所有相邻路由器。</p><p>2）发送的信息就是<strong>本路由器相邻的所有路由器的链路状态</strong>。<strong>度量</strong>表示费用、距离、时延、带宽等等，这些都是网络管理人员决定的，较为灵活。</p><p>3）只有链路发生变化时才会向所有路由器用洪泛法发送此信息。</p><p>OSPF将一个自治系统再划分为若干个更小的范围，叫做区域。图4-34就表示一个自治系统划分为4个区域。</p><p><img src="/2021/03/15/network/OSPF%E5%8C%BA%E5%9F%9F.png"></p><p>这样洪泛法就作用于每个区域内。上层叫<strong>主干区域</strong>，R3、R4和R7是<strong>区域边界路由器</strong>。R6是<strong>自治系统边界路由器</strong>。（和其他自治系统连接）</p><p><img src="/2021/03/15/network/OSPF%E6%A0%BC%E5%BC%8F.png"></p><p>使用24字节的首部长度：</p><p>1）版本。当前版本为2。</p><p>2）类型。5种类型中的一种。</p><p>3）分组长度。包括OSPF首部在内的分组长度。</p><p>4）路由器标识符。发送改分组的路由器接口的IP地址。</p><p>5）区域标识符。分组属于区域的标识符。</p><p>6）检验和。用来检验分组中的差错。</p><p>7）鉴别类型。0（不用）1（口令）。</p><p>8）鉴别。 鉴别类型为0填0。鉴别类型1填8个字符的口令。</p><h3 id="11-外部网关协议BGP"><a href="#11-外部网关协议BGP" class="headerlink" title="11.外部网关协议BGP"></a>11.外部网关协议BGP</h3><p>边界网关协议（BGP）</p><p>不同自治区域使用BGP的原因有：</p><ol><li><p>互联网规模太大。路由表维持开销太大。</p></li><li><p>不同自治区域用的协议可能不同。而且有的自治区域不喜欢让别的自治区域流量通过本区域。</p></li></ol><p>BGP采用<strong>路径向量路由选择协议</strong>，满足管理员的条件下，选择比较好的路径，并非找一条最佳路径。</p><p>一个BGP发言人与其他AS的BGP发言人要交换信息，首先建立TCP连接，端口号179，然后在此连接上交换BGP报文以建立BGP会话。</p><p><img src="/2021/03/15/network/BGP%E5%92%8CAS%E7%9A%84%E5%85%B3%E7%B3%BB.png"></p><p>有了BGP会使得路由表简化很多，BGP协议交换路由信息的结点数量级是自治系统个数的量级，这要比网络数小很多，只要找对正确的BGP发言人，就可以发送数据报，简化路由表信息。</p><ul><li>BGP-4的4种报文</li></ul><p>1）OPEN（打开）报文，用来和相邻的另一个BGP发言人建立关系，使通信初始化。</p><p>2）UPDATE（更新）报文，用来通告某一路由信息，以及列出要撤销的多条路由。</p><p>3）KEEPALIVE（保活），用来周期性地证实邻站的连通性。</p><p>4）NOTIFICATION（通知）报文，用来发送检测到的差错。</p><ul><li>BGP路由表包括目的网络前缀，下一跳路由以及到达该网络经过的自治系统序列。（如果一个BGP收到了其他BGP的路径通知，检查本自治系统是否在路径序列中，防止兜圈子）。</li></ul><p><img src="/2021/03/15/network/BGP%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F.png"></p><ul><li><p>标记用来鉴别BGP报文，不使用鉴别，标记全部置1。长度字段指出包括通用首部在内的整个BGP报文长度，最小19，最大4096。类型1-4，上述BGP报文中的一种。</p></li><li><p>OPEN报文共有6个字段，即版本</p></li></ul><h3 id="12-IPV6"><a href="#12-IPV6" class="headerlink" title="12.IPV6"></a>12.IPV6</h3><p>IPV6将地址空间增大到128位，相当于IPV4的$2^{96}$倍。</p><p><img src="/2021/03/15/network/IPV6%E6%A0%BC%E5%BC%8F.png"></p><ul><li>首部固定40字节。</li><li><strong>版本</strong> 占4位。协议的版本，IPV6是6.</li><li><strong>通信量类</strong> 占8位，为了区分不同的IPV6数据类型和优先级。</li><li><strong>流标号</strong> 占20位。<strong>流</strong>指的是从特定源点到特定终点的一系列数据报，流所经过的路径上路由器都保证指明的服务质量。属于同一个流的数据报都有一样的流标号。</li><li><strong>有效载荷长度</strong> 占16位。IPV6数据报除基本首部以外的字节数。这个字段的最大值是64KB。</li><li><strong>下一个首部</strong> 占8位。</li></ul><p>1）IPv6没有扩展首部时，指明后面的数据应该交付IP层哪一个协议。</p><p>2）出现扩展首部时，下一个字段的值标识第一个扩展首部的类型。</p><ul><li><strong>跳数限制</strong> 占8位。防止数据报在网络中无限期存在。最大255跳。</li><li><strong>源地址</strong> 128位。发送数据报的IP地址。</li><li><strong>目的地址</strong> 128位。接收数据报的IP地址。</li></ul><ol><li><strong>IPV6地址</strong></li></ol><p>1）<strong>单播</strong> 传统的点对点通信。</p><p>2）<strong>多播</strong> 一点对多点通信。</p><p>3）<strong>任播</strong> 终点是一组计算机，数据报只交付其中一个，通常是距离较近的那个。</p><p>2.<strong>冒号十六进制法</strong></p><p><img src="/2021/03/15/network/%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6%E5%86%92%E5%8F%B7%E6%B3%95.png"></p><p><img src="/2021/03/15/network/v6%E5%8E%8B%E7%BC%A9.png"></p><p>CIDR无分类网络地址同样可以适用。直接在后面加上/。</p><p><img src="/2021/03/15/network/IPV6%E6%97%A0%E5%88%86%E7%B1%BB.png"></p><ul><li>地址分类</li></ul><p><img src="/2021/03/15/network/IPV6%E5%9C%B0%E5%9D%80%E5%88%86%E7%B1%BB.png"></p><p>1） 未指明地址。16字节全0地址。只能为某个主机当源地址适用，使用条件是这个主机还未分配IP地址。仅此一个。</p><p>2）环回地址。功能和V4一样。仅此一个。</p><p>3）多播地址。功能和V4一样。1/256个。</p><p>4）本地链路多播地址。有些主机没有连接到互联网上，占1/1024。</p><p>5）全球单播地址。 如图。</p><ol start="3"><li><strong>从IPV4向IPV6过渡</strong></li></ol><p>1）<strong>双协议栈</strong></p><p>一部分主机装有IPV4和IPV6两个协议栈。这样这个主机可以两种类型的网络数据通信。使用<strong>DNS</strong>查询目的主机使用的是那种协议。</p><p><img src="/2021/03/15/network/%E5%8F%8C%E5%8D%8F%E8%AE%AE%E6%A0%88.png"></p><p>2）<strong>隧道技术</strong></p><p>IPv6数据报进入IPv4网络时，使用IPv4数据报封装IPv6。这样就可以在IPv4网络中传播。在离开v4网络时，只交付数据部分（即v6）。双协议栈的主机想知道封装的是一个v6数据报，v4首部协议字段置为41。</p><ol start="4"><li><strong>ICMPv6</strong></li></ol><p>也需要使用类似ICMP反馈差错信息。</p><p><img src="/2021/03/15/network/ICMPv6%E5%88%86%E7%B1%BB.png"></p><h3 id="13-IP多播"><a href="#13-IP多播" class="headerlink" title="13.IP多播"></a>13.IP多播</h3><ul><li>一对多通信。一个源点发送给很多终点。</li></ul><p><img src="/2021/03/15/network/%E5%8D%95%E6%92%AD%E4%B8%8E%E5%A4%9A%E6%92%AD%E6%AF%94%E8%BE%83.png"></p><ul><li>多播实际上是IP地址中D类地址。只能用于目的地址，不能用于源地址。没有ICMP差错报文。</li><li>协议。IGMP网际组管理协议。</li></ul><p><img src="/2021/03/15/network/IGMP.png"></p><p>IGMP让连接在本地局域网上的多播路由器知道本局域网上是否有主机参与或退出了某个多播组。</p><p>配合<strong>多播路由选择协议</strong>一起工作，</p><p><img src="/2021/03/15/network/%E5%A4%9A%E6%92%AD%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9%E5%8D%8F%E8%AE%AE.png"></p><ul><li>IGMP两个工作阶段</li></ul><p>1）加入。某台主机加入多播组时，该主机应向多播组的多播地址发送一个IGMP报文，声明自己要成为该组的成员。本地多播路由器收到IGMP报文后，还要利用多播路由选择协议把这种组成员关系发给其他多播路由器。</p><p>2）删除。本地多播路由器周期性探询主机，查询这些主机是否还是组的成员。只要有一台主机对某个组响应，那么多播路由器就认为这个组是活跃的。只要几次探询后没有一个主机响应，那么就不会再把这个组的成员关系转发给其他转播路由器。</p><ul><li>多播路由选则协议</li></ul><p>多播路由选择协议尚未标准化。（此部分学习了解一下即可）</p><p>多播路由选择实际上要找出以源主机为根节点的多播转发树。转发数据报使用如下方法：</p><p>1）<strong>洪泛与剪除</strong></p><p>这种方法适用于较小的多播组，所有组成员接入的局域网也都是相邻接的。使用的是<strong>反向路径广播</strong>（RPB）。</p><p>洪泛就是广播，剪除就是。</p><p>洪泛与剪除示例：</p><p><img src="/2021/03/15/network/%E6%B4%AA%E6%B3%9B%E4%B8%8E%E5%89%AA%E9%99%A4.png"></p><p>如果多播转发树上的某个路由器发现它的下游树枝没有多播组成员，则下游树枝一起<strong>剪除</strong>。图中虚线椭圆就是剪除。当有新成员增加，再加回多播转发树。</p><p>2）<strong>隧道技术</strong></p><p>适用于多播组位置在地理上分布很分散。</p><p>路由器R1和R2不支持多播，那么R1和R2需要对多播数据报封装，再加上普通数据报首部，使之成为向单一目的站发送的单播数据报，然后“隧道”一样从R1发到R2。</p><p><img src="/2021/03/15/network/IP%E5%A4%9A%E6%92%AD%E9%9A%A7%E9%81%93%E6%8A%80%E6%9C%AF.png"></p><p>3）<strong>基于核心的发现技术</strong></p><p>对每一个多播组G指定一个核心路由器，给出它的IP单播地址。核心路由器按照前面的方法创建出多播组G的转发树。如果有一个路由器R1向核心路由器发送数据报，那么它途中经过的每一个路由器都要检查其内容。</p><p>书上没讲明白（P184）。了解一下算了。</p><h3 id="14-虚拟专用网和网络地址转换NAT"><a href="#14-虚拟专用网和网络地址转换NAT" class="headerlink" title="14 虚拟专用网和网络地址转换NAT"></a>14 虚拟专用网和网络地址转换NAT</h3><ol><li><strong>虚拟专用网</strong></li></ol><p>IPv4中有内部网络专用地址（为了防止和公网地址重叠，产生二义性问题）：</p><p>1）<code>10.0.0.0</code> 到 <code>10.255.255.255</code>(10.0.0.0/8，24位块)对应A类地址</p><p>2）<code>172.16.0.0</code>到<code>172.31.255.255</code>(172.16.0.0/12它又称为20位块) 对应B类</p><p>3）<code>192.168.0.0</code>到<code>196.168.255.255</code>（192.168.0.0/16，16位块）对应C类</p><p>这样的IP地址叫<strong>专用互联网</strong>或<strong>本地互联网</strong>。</p><ul><li>利用公用的作为本机构专用网之间的通信载体，这种专用网叫<strong>虚拟专用网VPN(Virtual Private Network)<strong>，用于机构的内部通信。所有经过互联网传输的</strong>数据要加密</strong>。</li><li>IP隧道技术</li></ul><p>隧道技术就是封装（把原来数据放到新的数据报，以方便通信）。</p><p><img src="/2021/03/15/network/%E8%99%9A%E6%8B%9F%E4%B8%93%E7%94%A8%E7%BD%91%E7%A4%BA%E4%BE%8B.png"></p><p>从X到Y，源地址X、目的地址Y+真实数据报。A发到了R1，R1会对所有数据加密封装，发给R2.R2在解密，就知道发给Y。</p><p>逻辑上看起来就是一个从R1到R2的直接路径（实际上经过了很多路由器传输），所以叫隧道。</p><ol start="2"><li><strong>网络地址转换NAT</strong></li></ol><p>分到了本地专用地址（内部网络专用地址），但是需要和外网通信咋办？<strong>公网IPv4地址太少啦。</strong></p><p>NAT就出来解决这个问题，一个NAT软件至少有一个有效的公网IP地址，使用NAT地址转换表来对应公网IP地址。</p><p><img src="/2021/03/15/network/NAT%E8%B7%AF%E7%94%B1%E8%A1%A8.png"></p><p><img src="/2021/03/15/network/NAT%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.png"></p><p>比如主机A向主机B发送信息，NAT路由器会将其地址<code>192.168.0.3</code>映射成<code>172.38.1.5</code>。B看到的A的地址实际上就是NAT的这个地址。B不知道A的实际地址是什么。B发给A信息目的地址就写NAT的IP就行。收到B的信息，NAT路由器根据NAT转换表转成A的<code>192.168.0.3</code>。</p><p>有一个问题来了，我们家庭的路由器，实际就一个IP地址，为什么那么多设备都能访问外网？</p><p>虽然只有一个公网IP地址，但是发明了<strong>端口号</strong>（运输层）啊！！！</p><p><img src="/2021/03/15/network/NAT%E7%AB%AF%E5%8F%A3%E5%8F%B7.png"></p><p>这个新的表叫<strong>网络地址与端口号转换NAPT</strong>。实际上现在很多人还是叫NAT转换表。</p><h3 id="15-多协议标记交换-MPLS-MultiProtocol-Label-Switching"><a href="#15-多协议标记交换-MPLS-MultiProtocol-Label-Switching" class="headerlink" title="15. 多协议标记交换 MPLS(MultiProtocol Label Switching)"></a>15. 多协议标记交换 MPLS(MultiProtocol Label Switching)</h3><p>增强IP功能的协议。采用面向连接的技术，每个分组携带一个叫做标记的小整数。当分组到达交换机时，交换机读取分组的标记，并采用标记值来检索分组标记，</p><ul><li>基本工作过程</li></ul><p>在传统的IP路由器查找路由表时，需要找最长匹配的前缀，耗时很大。MPLS对这个进行了优化。</p><p>在MPLS入口处，给每一个IP数据报打上固定长度的标记，然后对打上标记的IP数据报用硬件转发，速度大大加快。</p><p>使用硬件技术对打上标记的IP数据报进行转发成为标记交换，根据标记在数据链路层（硬件）上直接转发。</p><p><img src="/2021/03/15/network/MPLS%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.png"></p><p>MPLS的基本工作流程书中没细讲，主要有：（了解一下）</p><p>1）MPLS域指各LSR（标记交换路由器）使用专门的<strong>标记分配协议LDP</strong>交换报文，并找出特定标记相对应的路径，即<strong>标记交换路径LSP</strong>，如图中的ABCD。各LSR根据路径构造<strong>转发表</strong>。</p><p>2）IP数据报进入MPLS就给它打标记，按照转发表发给下一个LSR。</p><p><img src="/2021/03/15/network/LDP%E5%8D%8F%E8%AE%AE.png"></p><p>3）一个标记仅仅在两个标记交换路由器LSR之间才有意义。每经过一个LSR，LSR就要更换新的标记并转发，即把入标记换位出标记，这叫标记交换。</p><p>如图中B从入口0收到标记为3的分组，要将出接口换为1并且标记重新打1。</p><p>4）数据离开MPLS时，MPLS的出口结点就把MPLS标记删除，交付非MPLS路由器，按照普通的转发规则继续传递。</p><ul><li>MPLS中的重要概念 <strong>FEC转发等价类</strong></li></ul><p>转发等价类就是路由器按照同样方式对待的IP数据报的集合，即同样的接口转发到同样的下一跳地址，具有同样的服务类别和同样的丢弃优先级等。</p><p><img src="/2021/03/15/network/FEC%E7%9A%84%E4%BE%8B%E5%AD%90.png"></p><p>划分FEC的方法不受限制，只接受管理员控制。图中是FEC用于负载平衡的例子。传统的路由选择H1和H2分别向H3和H4发送信息，都只能选择最短路径ABC，导致过载。FEC可以指定H2选择ADEC。</p><ul><li>MPLS的首部位置和协议格式</li></ul><p><img src="/2021/03/15/network/MPLS%E9%A6%96%E9%83%A8%E4%BD%8D%E7%BD%AE.png"></p><p>IP数据报首部之间插入4字节的MPLS首部。把加上MPLS的IP数据报封装成帧时，以太网字段单播时为$8847_{16}$和$8848_{16}$这样来判断是否使用MPLS。</p><p><img src="/2021/03/15/network/MPLS%E9%A6%96%E9%83%A8%E6%A0%BC%E5%BC%8F.png"></p><p>1）标记值。 最大$2^{20}$。在设置MPLS标记时可以使用所有的20位。</p><p>2）试验。 3位，目前保留用于试验。</p><p>3）栈S 。1位，“标记栈”时使用。</p><p>4）生存时间TTL。 8位，防止MPLS在MPLS兜圈子。</p><h2 id="运输层"><a href="#运输层" class="headerlink" title="运输层"></a>运输层</h2><h3 id="1-运输层协议概述"><a href="#1-运输层协议概述" class="headerlink" title="1. 运输层协议概述"></a>1. 运输层协议概述</h3><p>端到端的通信实际上是两个主机中的应用进程之间的通信。</p><p>运输层“复用”和“分用”。复用指的是发送方不同的应用进程都可以使用同一个运输层协议传送数据，而“分用”是指接收方的运输层在剥去报文的首部后能够把这些数据正确交付目的应用进程。</p><p><img src="/2021/03/15/network/%E8%BF%90%E8%BE%93%E5%B1%82.png"></p><p>运输层的两个主要协议：UDP(User Datagram Protocol)和TCP(Transmission Control Protocol)。</p><p><img src="/2021/03/15/network/%E8%BF%90%E8%BE%93%E5%B1%82%E4%B8%A4%E4%B8%AA%E5%8D%8F%E8%AE%AE.png"></p><p>按照OSI的术语，两个对等运输实体在通信时传送的数据单位叫<strong>运输协议数据单元</strong>。</p><p><img src="/2021/03/15/network/%E4%BD%BF%E7%94%A8UDP%E5%92%8CTCP%E7%9A%84%E4%B8%8D%E5%90%8C%E5%8D%8F%E8%AE%AE.png"></p><p><strong>协议端口号</strong>通常又称为<strong>端口</strong>，虽然通信的终点是应用进程，但只要把所传送的报文交到目的主机的某个合适的目的端口，剩下的工作交由TCP或UDP来完成。（这里的端口主义和交换机或路由器上的端口区分，那个是硬件端口，这个是软件端口）。</p><p>TCP/IP运输层用一个16位（<strong>共65535个</strong>）的端口号来标志一个端口。端口号只具有本地意义，它只是标记本计算机应用层中的各个进程在运输层交互时的层间接口。</p><p>通信时，<strong>不仅要知道对方的IP地址，还要知道对方的端口号</strong>。</p><ul><li><strong>服务端</strong>使用的端口号。</li></ul><p>1）熟知端口号或系统端口号</p><p>数值 0~1023。</p><p><img src="/2021/03/15/network/%E7%86%9F%E7%9F%A5%E7%AB%AF%E5%8F%A3%E5%8F%B7.png"></p><p>2）登记端口号。数值 1024~49151。这类端口号为了没有熟知端口号的应用程序使用的。</p><ul><li><strong>客户端</strong>使用的端口号</li></ul><p>数值为49152~65535。这类端口号仅在客户进程运行时才动态选择，因此又叫<strong>短暂端口号</strong>。</p><h3 id="2-UDP-用户数据报协议"><a href="#2-UDP-用户数据报协议" class="headerlink" title="2. UDP 用户数据报协议"></a>2. UDP 用户数据报协议</h3><p>UDP(User Datagram Protocol)只在IP的数据报服务上增加了很少的一点功能。</p><p>1）无连接的。发送数据之前不需要建立连接，减少开销和发送数据之前的时延。</p><p>2）尽最大努力 交付。不需要维护复杂的连接状况。</p><p>3）面向报文的。发送方的UDP对应用程序交下来的报文，在添加首部后交付IP层。<strong>UDP一次交付一个完整的报文</strong>。如果报文太长，IP会对其进行分片，降低IP层的效率。</p><p><img src="/2021/03/15/network/UDP%E9%9D%A2%E5%90%91%E6%8A%A5%E6%96%87.png"></p><p>4）没有拥塞控制。网络出现的拥塞不会使源主机发送速率降低。这对实时应用很重要。</p><p>5）UDP支持一对一，一对多，多对一，多对多的交互通信。</p><p>6）UDP的首部开销少，只有8个字节，比TCP的20字节要短。</p><h3 id="3-UDP的首部格式"><a href="#3-UDP的首部格式" class="headerlink" title="3.UDP的首部格式"></a>3.UDP的首部格式</h3><p><img src="/2021/03/15/network/UDP%E7%9A%84%E9%A6%96%E9%83%A8%E6%A0%BC%E5%BC%8F.png"></p><p>数据字段和首部字段。首部字段中划分的每个字段<strong>都是两个字节</strong>。</p><p>1）源端口 源端口号。在需要对方回信时选用，不需要时全用0。</p><p>2）目的端口 目的端口号。终点交付时必须使用。</p><p>3）长度 UDP用户数据报的长度，最小值8（仅有首部）。</p><p>4） 检验和 检测UDP用户数据报在传输时是否有错。有错就丢弃。</p><p>UDP基于端口的复用：</p><p><img src="/2021/03/15/network/UDP%E5%9F%BA%E4%BA%8E%E7%AB%AF%E5%8F%A3%E7%9A%84%E5%A4%8D%E7%94%A8.png"></p><p>比如UDP发现端口号不正确，丢弃该报文，由ICMP发送端口不可达差错报文给发送方。</p><p>UDP计算检验和，UDP要在用户数据报之前加上<strong>12个字节的伪首部</strong>。计算检验和时<strong>临时</strong>加在数据报前，得到临时的UDP数据报。检验和就是按照这个临时的UDP用户数据包来进行计算。<strong>伪首部不向上传递也不想下传递</strong>，只是为了计算检验和。</p><p>UDP的检验和是把首部和数据部分一起检验（和IP只检验首部不同）。</p><p><img src="/2021/03/15/network/%E8%AE%A1%E7%AE%97UDP%E6%A3%80%E9%AA%8C%E5%92%8C.png"></p><p>发送方把检验和字段记为0。伪首部以及UDP数据报看成许多16位子串。若UDP数据部分不是偶数字节，需要填入一个全零字节，按照<strong>二进制反码</strong>计算出16位字的和。将此二进制反码写入检验和字段，发送给目的主机。</p><p>接收方收到UDP，按二进制反码求16位字的和，无差错其结果应全为1。否则就表明差错出现。</p><p>差错检验能力并不强，但简单快速。</p><h3 id="4-传输控制协议TCP"><a href="#4-传输控制协议TCP" class="headerlink" title="4.传输控制协议TCP"></a>4.传输控制协议TCP</h3><p>1） 面向连接。打电话一样，通信之前需要拨号建立连接，结束时需要挂断结束连接。</p><p>2）TCP只能<strong>点对点</strong>。 端点对端点。</p><p>3）TCP提供<strong>可靠交付</strong>的服务。 可以检查传送的数据无差错、不丢失、不重复并且按序到达。</p><p>4）全双工通信。通信双方的应用进程在任何时候都可以发送数据。</p><p>5）面向字节流。 流 指的是流入进程或者从进程流出的字节序列。虽然应用进程和TCP的交互是一次一个数据块，但是TCP把这些数据看成是一连串的无结构的字节流。TCP并不知道所传送的字节流的含义。TCP只保证收到的字节流和发送的字节流一样。</p><p><img src="/2021/03/15/network/TCP%E5%AD%97%E8%8A%82%E6%B5%81.png"></p><ul><li>TCP的连接</li></ul><p>$套接字 socket=(IP地址 : 端口号)$ </p><p>TCP连接 : :=${socket_1,socket_2}={(IP_1 : port_1),(IP_2,port_2)} $</p><ul><li>可靠传输原理</li></ul><p>1） 停止等待协议</p><p><img src="/2021/03/15/network/%E5%81%9C%E6%AD%A2%E7%AD%89%E5%BE%85%E5%8D%8F%E8%AE%AE.png"></p><p>正常情况下，A发送M1，B收到发送确认M1，A收到确认继续发送。</p><p>超时情况下，A发送的M1可能丢失或者错误，B没收到或者收到错误的会没有任何响应。A一段时间没收到确认需要重发。</p><p>所以，需要注意的要点是：</p><p>1）A发送后必须保留发送数据的副本，以备重传。</p><p>2）分组和确认分组都需要编号，确认哪个没收到哪个收到。</p><p>3）合理的超时重传时间十分重要。</p><ul><li>确认丢失和确认迟到</li></ul><p><img src="/2021/03/15/network/%E7%A1%AE%E8%AE%A4%E4%B8%A2%E5%A4%B1%E5%92%8C%E8%BF%9F%E5%88%B0.png"></p><p>图中a的情况：</p><p>1）B的确认丢失，A重发，B又收到M1，需要将M1扔掉。</p><p>2）B需要重发M1确认报文，A发了两次M1说明没收到确认。</p><p>图中b的情况：</p><p>B的确认报文因为第一次的报文迟到了，所以A要丢弃一个确认报文。</p><p><img src="/2021/03/15/network/TCP%E4%BF%A1%E9%81%93%E5%88%A9%E7%94%A8%E7%8E%871.png"></p><p><img src="/2021/03/15/network/TCP%E4%BF%A1%E9%81%93%E5%88%A9%E7%94%A8%E7%8E%87.png"></p><p>U表示信道利用率。A发送分组时间是$T_D$，收到确认时间是$T_A$。可以发现这样信道利用率比较低，很长时间才能发送下一个数据，发明了流水线发送：（ARQ协议或滑动窗口协议）</p><p><img src="/2021/03/15/network/TCP%E6%B5%81%E6%B0%B4%E7%BA%BF%E5%8F%91%E9%80%81.png"></p><ul><li>连续ARQ协议。</li></ul><p><img src="/2021/03/15/network/%E8%BF%9E%E7%BB%ADARQ%E5%8D%8F%E8%AE%AE.png"></p><p>发送窗口，一下子发送5个分组。收到一个确认，窗口就向前滑动一个。</p><p><strong>累积确认方式，按序到达的最后一个分组确认</strong>。例如，12345中的3丢了，会收到2的确认报文，因为只有12是有序的，这里就要重新发345。</p><ul><li><strong>首部报文格式</strong></li></ul><p><img src="/2021/03/15/network/TCP%E7%9A%84%E9%A6%96%E9%83%A8%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F.png"></p><p>首部固定20字节，可选40字节，首部最长60字节。</p><ul><li><p>源端口 目的端口 。如字面意思。</p></li><li><p>序号。 4字节，$[0,2^{32}-1]$，序号增加到$2^{32}-1$后重新从0开始发。每一个字节都按顺序编号，当前发了301-400字节，那么下一个报文的序号是401。</p></li><li><p>确认。 <strong>期望收到对方下一个报文段的第一个数据字节的序号</strong>。比如B收到了A发送过来的501-600的数据。则发送601确认。若确认号等于N，则N-1个字节都收到了。</p></li><li><p>数据偏移。 占4位。记录数据的起始字段距离TCP报文起始距离多远。数据偏移的单位是32位字（以4字节作为基本单位），所以最大这个字段占4位最大15，15*4=60字节。所以TCP的首部长度最大60字节。</p></li><li><p>保留。 占6位，保留今后使用。</p></li><li><p>紧急URG。 URG=1时，紧急数据应该不能排队直接优先发送分组。</p></li><li><p>确认ACK。 连接建立后所有传送的报文段都为1。</p></li><li><p>推送PSH。 接收方收到PSH=1时，不能等缓冲区满才交付上层，要直接交付，事情紧急。</p></li><li><p>复位RST。 RST=1表示TCP发生严重错误，要释放连接。RST=1还可拒绝一个非法报文段。</p></li><li><p>同步SYN。 在建立连接时来同步序号。当SYN=1而ACK=0时，表明这是一个连接请求报文段。对方若同意建立连接，则应在响应的报文段中使SYN=1和ACK=1。因此SYN置1就表示这是一个连接请求或连接接受报文。</p></li><li><p>结束FIN。 用来释放一个连接。当FIN=1时，表明报文段发送方的数据已发送完毕，并要求释放运输连接。</p></li><li><p>窗口。 2字节。窗口值是[0,$2^{16}-1$]之间的整数。窗口指的是发送报文段的一方的接收窗口。窗口值告诉对方，从本报文段首部中的确认号算起，接收方目前允许对方发送的数据量，这是因为接收方的数据缓存空间是有限的。窗口值作为接收方让发送方设置其发送窗口的依据。</p></li><li><p>检验和。 占2字节。检验和字段检验的范围包括首部和数据两部分。</p></li><li><p>紧急指针。 占2字节。仅在URG=1时有意义。指出本报文段中紧急数据的字节数。紧急指针指出了紧急数据的末尾在报文段中的位置</p></li><li><p>选项。最长可达40字节。当没有选项时，TCP的首部是20字节。</p></li></ul><h3 id="5-TCP可靠传输的实现"><a href="#5-TCP可靠传输的实现" class="headerlink" title="5. TCP可靠传输的实现"></a>5. TCP可靠传输的实现</h3><ol><li>以字节为单位的滑动窗口</li></ol><p><img src="/2021/03/15/network/%E6%9E%84%E9%80%A0%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3.png"></p><p>发送方A的发送窗口，发送窗口表示在没有收到B确认的情况下，A可以连续把窗口内的数据都发出去。凡是发过的数据都要暂时备份，以便超时重传。</p><p>TCP标准不同意窗口前沿向后收缩，因为有可能已经发送过，收缩后表示没法送这些数据，会产生错误。</p><p><img src="/2021/03/15/network/%E5%8F%91%E9%80%81%E7%AA%97%E5%8F%A3.png"></p><p>p3-p1 发送窗口</p><p>P2-P1 已发送但未收到确认。</p><p>P3-P2 允许发送但未发送（可用窗口或有效窗口）</p><p>详细的窗口滑动距离可以参考书 P 222。只要明白确认号是有序序列的下一个，都能说对。</p><p><img src="/2021/03/15/network/TCP%E7%BC%93%E5%AD%98%E5%92%8C%E7%AA%97%E5%8F%A3%E7%9A%84%E5%85%B3%E7%B3%BB.png"></p><p>发送方：</p><p>发送窗口只是发送缓存的一部分。已确认的数据应该从缓存删除，因此发送窗口和缓存的后沿是重合的。</p><p>接收方：</p><p>缓存存放按序到达、但尚未被应用程序读取的数据。未按序到达的数据。</p><p>要点：</p><p>1）A的发送窗口是根据B的接收窗口设置的，但同一时刻A的发送窗口并不和B的接收窗口一样大（网络传送窗口值需要经历一定的时间滞后）。A可能还要根据网络拥塞情况控制发送窗口的数值。</p><p>2）接收方都是累积确认。但是不应该过分推迟发送确认，否则会导致发送方不必要的重传。</p><ol start="2"><li>超时重传时间选择</li></ol><p>使用<strong>自适应算法</strong>设置重传时间。</p><p>记录报文发出的时间，以及收到相应的确认时间，时间差就是<strong>报文段的往返时间RTT</strong>。TCP保留RTT的加权平均往返时间。</p><p><img src="/2021/03/15/network/TCP%E5%BE%80%E8%BF%94%E6%97%B6%E9%97%B4.png"></p><p>建议$\alpha$=1/8。确认重传时间RTO：</p><p><img src="/2021/03/15/network/TCP%E8%B6%85%E6%97%B6%E9%87%8D%E4%BC%A0%E6%97%B6%E9%97%B4.png"></p><p>$新的RTT_{D}=（1-\beta)\times(旧的RTT_{D})+\beta \times |RTT_{s}-新的RTT样本|$</p><p>$\beta=0.25$</p><p><img src="/2021/03/15/network/TCP%E9%87%8D%E4%BC%A0%E6%97%B6%E9%97%B4%E7%A4%BA%E4%BE%8B.png"></p><p>正常的RTO按照上面公式计算即可。对于需要重传的数据，每次重传一次，就直接把RTO=2*RTO。两倍的原来的RTO就行。</p><ol start="3"><li>选择确认SACK</li></ol><p><img src="/2021/03/15/network/SACK%E5%AD%97%E8%8A%82%E6%B5%81%E4%B8%8D%E8%BF%9E%E7%BB%AD.png"></p><p><strong>为了减少不必要的重传</strong>。每一个字节块都有两个边界，例如图中的L1和R1来标记接收方收到的字节。首部可变选项长度最大40字节，选项中先加上“允许SACK”。一个边界使用32位（4字节），所以一个标记需要8字节（L和R），还需要两个字节，一个指明使用SACK，一个指明这个选项占用多少字节。（书上也没讲清楚，看看得了）</p><h3 id="6-TCP流量控制"><a href="#6-TCP流量控制" class="headerlink" title="6.TCP流量控制"></a>6.TCP流量控制</h3><p>流量控制指的是<strong>发送方发送数据不要太快，接收方来得及接收</strong>。</p><p><img src="/2021/03/15/network/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%BA%E5%88%B6%E8%BF%9B%E8%A1%8C%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6.png"></p><p>接收方B进行了流量控制，告诉A应该发多少。当rwnd=0 A只能等待不能发送。直到B发回新的ACK。</p><p>有一种特殊情况，如果最后rwnd=0后，B有了新的缓存空间，给A发了新的确认和窗口，但是这个消息丢了，会导致A和B互相等待死锁。为了解决这种情况，设置持续计时器，持续计时器到时，A就发送<strong>零窗口探测报文段</strong>，对方就在这个探测报文段给出新的窗口值。</p><ol><li>TCP的传输效率</li></ol><p>缓存只管把当前窗口内的数据交付TCP，发送的数据直接由TCP去处理。</p><p><strong>例子1</strong>：TCP何时发送数据关乎网络利用率。如果用户每次只发1个字节，那么加上头部40个字节（iP20+TCP20)共41字节。接收方发送确认信息40字节。这么一个字节就传送81个字节，利用率很低。</p><p>书中提到两个方法：</p><p>1）Nagle方法：应用程序把要发送的数据缓存到发送缓存，TCP先发送第一个数据字节，缓存后面到达的数据，收到确认后，把缓存区所有数据装成一个TCP报文一起发送，同时对后续的数据继续缓存，收到前一个确认再继续发送。Nagle规定，数据达到发送窗口一半或报文段的最大长度（MSS)就立即发送一个报文段。<strong>差不多是控制发送方接收窗口大小</strong>。</p><p>2）糊涂窗口：糊涂窗口就是指例子1的情况，不断地发送1个字节，网络利用率很低。为了解决问题，规定让接收方等一段时间，接收缓存有足够空间或接收缓存有了一半空间。这两种情况下才让发送方发送一个长TCP。<strong>差不多是控制接收方窗口大小，不要有一点空间就着急告诉发送方</strong></p><p>这两种方法可配合使用，达到效果。</p><h3 id="7-TCP的拥塞控制"><a href="#7-TCP的拥塞控制" class="headerlink" title="7.TCP的拥塞控制"></a>7.TCP的拥塞控制</h3><p>拥塞控制就是防止过多的数据注入网络，这样可以使网络中的路由器或链路不至于过载。网络能够承受现有的网络负荷。拥塞控制是一个全局的过程，涉及所有的主机和路由器。</p><p>简单地将处理机速率提高，可能会把瓶颈移到其他地方。比如某个结点缓存太小，我就给它弄成无限缓存，结果缓存排队的数据太多了，很多信息又全部重传，我这还没发出去你就又来一轮，越来越慢。<strong>拥塞控制是个全局的控制，所以说拥塞不能只看某一个地方，需要全局把控</strong>。</p><p>流量控制是点对点通信量的控制。</p><p><img src="/2021/03/15/network/%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E6%89%80%E8%B5%B7%E7%9A%84%E4%BD%9C%E7%94%A8.png"></p><p>从控制理论的角度看拥塞控制，分为<strong>开环控制</strong>和<strong>闭环控制</strong>两种方法。</p><p>开环控制就是设计网络时事先将有关发生的拥塞因素考虑周到，力求网络在工作时不产生拥塞。但一旦整个系统运行起来，就不再中途进行改正了。</p><p>闭环控制基于反馈环路的概念，主要有：</p><p>1）检测网络系统以便检测到拥塞在何时发生、何处发生。</p><p>2）把拥塞发生的信息传送到可采取行动的地方。</p><p>3）调整网络系统的运行以解决出现的问题。</p><ul><li>TCP的拥塞控制</li></ul><p>1）慢开始和拥塞避免</p><p>基于窗口的拥塞控制。发送方维持一个叫做拥塞窗口cwnd的状态变量。拥塞窗口的大小取决于网络的拥塞程度，并且动态地变化。<strong>发送方让自己的发送窗口等于拥塞窗口。</strong></p><p>原则：只要网络没有出现拥塞，拥塞窗口可以再增大一些，以便发送更多分组，提高网路利用率。但只要出现拥塞，就把拥塞窗口减小。</p><p>只要发送的报文出现了丢失（需要重传）就判断为拥塞。</p><p><strong>慢开始</strong>算法：当主机开始发送数据时，由于并不清楚网络状况，由小到大逐渐增大发送窗口，也就是由小到大逐渐增大拥塞窗口数值。</p><p>刚开始cwnd设置为不超过2至4个SMSS（Sender Maximum Segment Size）最大报文段的数值。</p><p>若SMSS&gt;2190字节，则设置初始拥塞窗口cwnd=2*SMSS。且不超过2个报文段。</p><p>若SMSS&gt;1095字节且SMSS&lt;2190字节，则设置初始拥塞窗口cwnd=3*SMSS字节，且不超过3个报文段。</p><p>若SMSS&lt;=1095字节，则cwnd=4*SMSS字节，不超过4个报文段。</p><p>以此限制初始窗口的拥塞字节数。每收到一个对新的报文段确认后，拥塞窗口增加最多一个SMSS数值。</p><p>$拥塞窗口cwnd每次的增加量=min(N,SMSS)$</p><p>N是原先未被确认的，现在刚收到的确认报文段所确认的字节数。</p><p>不难看出，当N&lt;SMSS时，拥塞窗口每次的增加量要小于SMSS。</p><p><img src="/2021/03/15/network/%E5%8F%91%E9%80%81%E6%96%B9wend%E7%9A%84%E6%83%85%E5%86%B5.png"></p><p>使用慢开始算法，收到确认号就根据确认号扩大窗口，可以看到窗口是成倍增加的。例如：第一次发送的收到了（窗口内是1）2。那么窗口就是（2,3）期望收到4，变为4，下次（4,5,6,7），期望收到8，变为8。</p><p><strong>拥塞避免</strong>算法不像慢开始算法成倍，它只加1（1指的是一个MSS最大数据报文段），<strong>更加缓慢地增大</strong>。</p><p>为了防止拥塞cwnd增长过大，设置慢开始门限。慢开始门限ssthresh：</p><p>当cwnd&lt;ssthresh时，使用上述慢开始算法。</p><p>当cwnd&gt;sshthresh时，停止使用慢开始算法而改用拥塞避免算法。</p><p>当=时，即可使用慢开始算法，也可使用拥塞避免算法。</p><p><img src="/2021/03/15/network/TCP%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E5%8F%98%E5%8C%96%E6%83%85%E5%86%B5.png"></p><p>这幅图中讲了拥塞控制的例子，具体看书中P234。</p><p><img src="/2021/03/15/network/%E5%BF%AB%E9%87%8D%E4%BC%A0.png"></p><p><strong>快速重传算法</strong>可以让发送方<strong>尽快知道报文发生了丢失</strong>。图中M3丢了要不停地发确认M2，只要<strong>一连收到3个重复确认</strong>，发送方就知道应立即重传。</p><p>图中发现了丢失个别报文段，于是采用<strong>快恢复算法</strong>，调整门限值<code>cwnd=ssthresh=cwnd/2</code>，并开始执行拥塞避免算法。</p><p>在拥塞避免阶段，拥塞窗口是<strong>线性增大</strong>，称为**加法增大AI(Additive Increase)<strong>。而一旦出现超时或3个重复的确认，就要把门限值设为当前拥塞窗口的一半，并且大大减少拥塞窗口的数值，称为</strong>“乘法减小”MD（Multiplicative Decrease)**。二者合并一起就是AIMD算法</p><p>可归纳为如下流程图：</p><p><img src="/2021/03/15/network/%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E6%B5%81%E7%A8%8B%E5%9B%BE.png"></p><p>以上讨论全是假设接收方窗口无限大。接收方窗口称为通知窗口，实际运行中发送方的窗口一定不能超过对方给出的接收方窗口值rwnd。</p><p>所以$发送方窗口的上限值=Min[rwnd,cwnd]$</p><ul><li>主动队列管理（AQM,Active Queue Management）</li></ul><p>路由器缓存都有限制，如果数据报文太多，路由器队列缓存尾部会丢弃报文，导致一连串的报文丢失，重传导致判定网络拥塞。很多TCP会同时进入慢开始状态，使得全网的通信量突然下降，网络恢复正常后，这些TCP又同时信息量增大。</p><p>为了避免这种全局同步现象，提出了主动队列管理(AQM)，不要等到路由器队列长度最大值了才丢弃分组，而是当长度达到某个值时主动丢弃分组，提醒发送方放慢发送速率。</p><h3 id="8-TCP的运输连接管理"><a href="#8-TCP的运输连接管理" class="headerlink" title="8.TCP的运输连接管理"></a>8.TCP的运输连接管理</h3><ul><li><strong>三次握手</strong>：</li></ul><p><img src="/2021/03/15/network/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png"></p><p>最初两台主机都处于关闭状态，A要主动连接，叫主动打开，B是被动打开连接。A和B都有传输控制模块TCB，这个模块用来发起请求。</p><p>A打算建立TCP连接时，向B发出连接请求报文段，这时首部中的同步位SYN=1，同时选择初始序号seq=x。SYN报文段不能携带数据，但要消耗一个序号。这时A主机进入SYN-SENT（同步已发送）状态。</p><p>B收到连接请求报文段后，如同意建立连接，则向A发送确认。把SYN和ACK都置为1，<code>ack = x+1</code>。选择一个初始序号<code>seq = y</code>，并消耗一个序号。服务器B进入SYN-RCVD（同步收到）状态。</p><p>TCP客户进程收到B的确认后，向B发送确认。确认报文段的ACK置1，确认号<code>ack=y+1</code>，而自己的序号<code>seq=x+1</code>。ACK报文段可以携带数据，但如果不携带数据则不消耗序号，下一个数据报文段的序号仍是seq=x+1。这时建立了连接A进入ESTABLISHED（已建立连接）状态。</p><p><strong>问题：为什么A还要最后发一次确认呢？</strong></p><p>主要是为了防止已失效的连接请求报文段突然又传到了B。本来是一个失效的报文段，如果没有确认，B会立马同意连接，这情况如果多了，B主机岂不是卡死。</p><ul><li>TCP连接释放</li></ul><p>数据传输完毕后，通信双方要释放连接。A和B处于ESTABLISHED状态时，A的应用发出连接释放报文段，停止发送数据，关闭TCP连接。</p><p>A把控制位FIN置为1，其序号<code>seq = u</code>，等于前面已经传送过来数据最后一个字节加1。A进入FIN-WAIT-1(终止等待1)状态，等待B的确认。注意FIN报文段即使不携带数据，也要消耗一个序号。</p><p><img src="/2021/03/15/network/TCP%E8%BF%9E%E6%8E%A5%E9%87%8A%E6%94%BE%E8%BF%87%E7%A8%8B.png"></p><p>B收到连接释放报文发出确认，确认号是<code>ack = u+1</code>，而这个报文段自己的序号是v，等于B前面已经发送的数据最后一个字节加1。B进入CLOSE-WAIT（关闭等待）状态。TCP处于<strong>半关闭</strong>状态。</p><p>A收到B的确认后，进入FIN-WAIT-2（终止等待2）状态，等待B发出的连接释放报文段。</p><p>B如果没有向A发送的数据，发送FIN=1，假定B现在的序号是w（可能B向A发了一些数据，如果没发，那序号是u+1），但B还是继续重复上次发过的确认号则<code>ACK = u+1</code>。B进入LAST-ACK（最后确认状态），等待A的确认。</p><p>A在收到对此发出确认。ACK置为1，<code>ack =</code>W+1`，而自己的序号是 seq = u+1。进入TIME-WAIT(时间等待)状态。经过**时间等待计时器（Maximum Segment Lifetime)**设置的2MSL后，A进入CLOSED状态。</p><p><strong>为什么A需要等待2MSL时间？</strong></p><p>1）为了保证A发送的最后ACK报文段到达B。这个ACK报文段可能丢失，B收不到对重传FIN+ACK报文段的确认，B会在一定时间内重传，A就能够2MSL时间内等到B的信息。A重传，并且重新启动2MSL计时器。直到A和B都进入CLOSED状态。</p><p>2）防止“已失效的连接请求报文段”出现在本连接中。A发送完最后ACK后，再经过2MSL，可使本连接持续的时间内所产生的所有报文段从网络中消失，这样就可以使下一个新的连接不会出现旧的报文请求文段。</p><p>注意，以为2MSL的存在，B结束TCP的时间比A早一些。</p><p>TCP还有<strong>保活计时器（keepalive timeer）</strong>如果某个client和服务器建立连接但突然故障，服务器一直等待，不能总是等啊。若服务器两个小时还没有收到客户数据，服务器就开始发送探测报文段，并且每隔75秒发送一次，若连续发送10个探测报文段client无响应，服务器认为client故障，关闭连接。</p><ul><li>TCP的有限状态机（相当于总体流程图）</li></ul><p><img src="/2021/03/15/network/TCP%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA.png"></p><h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><h3 id="1-域名系统DNS"><a href="#1-域名系统DNS" class="headerlink" title="1. 域名系统DNS"></a>1. 域名系统DNS</h3><p>DNS(Domain Name System)是用来将机器名字转换为IP地址。互联网的命名系统中使用了很多的“域”，域是名字空间中一个可被管理的划分，还可被划分子域，出现了顶级域、二级域、三级域等等，因此就出现了“域名”这个名词。</p><p>DNS现在设计成了分布式系统，大部分解析在本地进行，少量解析在互联网上通信，DNS效率很高。</p><p>域名到IP地址的解析是由许多<strong>域名服务器程序</strong>共同完成，运行域名服务器程序的机器叫<strong>域名服务器</strong>。</p><p>解析要点：当某一个应用进程把主机名解析成IP地址时，该应用进程就要调用解析程序，并成为DNS的一个客户，把待解析的域名放在DNS请求报文中，以<strong>UDP</strong>的形式发送本地域名服务器。本地域名服务器查找后，把对应的IP地址放在回答报文中返回。若本地域名服务器不能找到地址，则此域名服务器暂时成为DNS中的另一个客户，并向其他应服务器请求，直到找到回答。</p><p><img src="/2021/03/15/network/%E5%9F%9F%E5%90%8D.png"></p><p>域名标号由英文字母和数字组成，<strong>每一个标号不超过63个字符</strong>，也<strong>不区分大小写字母</strong>，标号中除了连字符-外不能使用其他标点符号。级别最低的域名写在左边，级别高的写在右边。<strong>由多个标号组成的完整域名不可超过255个字符</strong>。</p><p>最高的顶级域名由ICANN管理，域名可使每一个域名在全互联网内都是唯一的。</p><p>2012年顶级域名共分为3大类：</p><p>1）国家顶级域名nTLD。cn表示中国，us表示美国，uk表示英国等。国家顶级域名达到296个。</p><p>2）通用顶级域名gTLD。com（公司企业）aero（航空运输业）asia（亚太地区）。。。等。</p><p>3）基础结构域名。只有一个arpa，用于反向域名解析，也叫<strong>反向域名</strong>。</p><p><img src="/2021/03/15/network/%E5%9F%9F%E5%90%8D%E5%B1%82%E6%AC%A1.png"></p><p>我国把二级域名划分为“<strong>类别域名</strong>和<strong>行政区域名</strong>两大类：</p><p>“类别域名”共7个，分别为：ac（科研机构），com（工、商、金融等企业），edu（中国的教育机构），gov（中国的政府机构），mil（中国的国防机构），net（提供互联网网络服务机构），org（非营利性组织）。</p><p>行政域名共34个，适用于我国的各省、自治区、直辖市例如：bj（北京），js（江苏）</p><ul><li>域名服务器</li></ul><p><img src="/2021/03/15/network/DNS%E5%88%92%E5%88%86%E5%8C%BA.png"></p><p>一个服务器所管辖的范围叫区，每一个区有权限域名服务器。区小于等于域，但不能大于域。</p><p><img src="/2021/03/15/network/%E5%9F%9F%E5%90%8D%E5%8C%BA%E8%A7%A3%E9%87%8A.png"></p><p>1）根域名服务器：知道所有顶级域名服务器域名和IP地址。本地域名服务器只要无法解析某个域名，就要请求根域名服务器。某个客户请求根域名服务，就找最近的根域名服务器地址发查询。根域名服务器会告诉本地域名服务器下一步找哪个顶级域名服务器。</p><p>2）顶级域名服务器：负责管理在该顶级域名服务器注册的所有二级域名。</p><p>3）权限域名服务器：负责一个区的域名服务器，当权限服务器不能给出最后的查询回答时，就会告诉DNS客户下一步找哪个权限域名服务器。</p><p>4）本地域名服务器：本地域名服务器不属于图6-3中的层次结构。每一个互联网服务提供者ISP，或者一个大学都可以拥有一个本地域名服务器，也叫默认域名服务器。本地域名服务器离客户很近。</p><p>主机向本地域名服务器的查询都是<strong>递归查询</strong>。如果本地域名服务器不知道IP地址，就以DNS客户身份向其他根域名服务器发起请求，递归查询结果。</p><p>本地域名服务器向根域名查询是<strong>迭代查询</strong>。当根域名服务器收到本地域名服务器发出的迭代查询请求报文时，要么给出IP地址，要么告诉本地域名服务器“下一步应该向哪个域名服务器查询（把自己知道的顶级域名服务器地址）”，然后本地域名服务器查询顶级域名服务器，查到就结束，没查到顶级域名服务器告诉它查询哪个权限域名服务器值，直到查到。</p><p><img src="/2021/03/15/network/DNS%E6%9F%A5%E8%AF%A2%E4%B8%BE%E4%BE%8B.png"></p><p> 每个服务器（本地、根、顶级等）都有高速缓存，保存最近查询过的域名地址，减少网络通信量。</p><h3 id="2-FTP文件传送协议"><a href="#2-FTP文件传送协议" class="headerlink" title="2.FTP文件传送协议"></a>2.FTP文件传送协议</h3><p>FTP使用TCP可靠传输服务。</p><p>FTP由两大部分组成：<strong>主进程</strong>，负责接受新的请求。<strong>从属进程</strong>，负责处理单个请求。</p><p>主进程工作步骤：</p><p>1）打开熟知端口（端口号21），使客户进程能够连接上。</p><p>2）等待客户进程发出连接请求。</p><p>3）启动从属进程处理客户进程发来的请求。从属进程对客户进程的请求处理完毕后终止，但从属进程可能在运行期间根据需要创建一些其他子进程。</p><p>4）回到等待状态，继续接受其他客户进程发来的请求。主进程和从属进程的处理是并行进行的。</p><p><img src="/2021/03/15/network/FTP%E8%BF%9E%E6%8E%A5.png"></p><p>进行文件传输时，FTP客户和服务器之间要建立两个并行的TCP连接：“控制连接”和”数据连接“。控制连接在整个会话期间一直保持打开，FTP客户发出传送请求，通过控制连接发送给服务端的控制进程。实际传输文件的是数据连接，服务端控制进程收到FTP客户文件传输请求后就创建数据传送进程和数据连接。</p><p>网络文件系统NFS和FTP不同，NFS允许应用进程远程打开一个远地文件，并且能在该文件的某一个特定的位置上开始读写数据。</p><ul><li>简单文件传送协议TFTP</li></ul><p>TCP/IP协议族中还有一个简单文件传送协议TFTP，<strong>使用UDP数据报</strong>，因此TFTP需要有自己的差错改正措施。TFTP只支持文件传输而不支持交互。</p><p>TFTP可用于UDP环境。TFTP代码所占内存小。</p><p>1）它每次传送512字节数据，但最后一次不足512。</p><p>2）数据报文按序编号，从1开始。</p><p>3）支持ASCII码或二进制传送。</p><p>4）可对文件进行读写。</p><p>5）使用很简单的首部。</p><h3 id="3-WWW万维网"><a href="#3-WWW万维网" class="headerlink" title="3. WWW万维网"></a>3. WWW万维网</h3><ul><li>URL统一资源定位符</li></ul><p>用来表示从互联网上得到的资源位置和访问这些资源的方法。URL给出资源的位置提供一种抽象的识别方法，并用这种方法给资源定位。</p><p><img src="/2021/03/15/network/URL%E5%BD%A2%E5%BC%8F.png"></p><p>URL左边第一部分是协议，这里的协议是指什么协议获取该万维网文档。最常用的是http，其次是ftp。</p><p>协议后面加” ://“是规定的格式。右边是第二部分主机，指出这个万维网文档在哪一台主机上。主机指的是该主机在互联网上的域名。再后面是端口和路径，有时可以省略。</p><p>现在的浏览器为了方便用户，可以把前面的http://甚至www省略，浏览器会自动填充。</p><ul><li>使用HTTP的URL</li></ul><p><img src="/2021/03/15/network/HTTP%E7%9A%84URL.png"></p><p>HTTP默认端口号是80。</p><ul><li>超文本传输协议HTTP （<strong>hyper transport text protocol</strong>）</li></ul><p>HTTP定义了浏览器怎样向万维网服务器请求万维网文档，以及服务器怎样把文档传送给浏览器。从层次的角度看，HTTP是面向事务的应用层协议，它是万维网上能够可靠地交换文件的重要基础。</p><p><img src="/2021/03/15/network/%E4%B8%87%E7%BB%B4%E7%BD%91%E7%9A%84%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B.png"></p><p>服务器进程监听TCP的端口80，发现请求即建立请求，一旦监听连接建立，浏览器就向万维网服务器发出浏览某个页面的请求，服务器接着就返回所请求页面作为响应。最后TCP连接释放。</p><p>HTTP规定HTTP客户和服务器之间的每次交互，都由一个ASCII码串构成的请求和一个类似的通用互联网扩充，即“MIME(MIME-like)”的响应组成。HTTP报文都是用TCP连接传送。</p><p><img src="/2021/03/15/network/HTTP%E8%AF%B7%E6%B1%82%E6%97%B6%E9%97%B4.png"></p><p>HTTP1.0版本是<strong>非持续连接</strong>。每次同一个客户的新请求都建立新的TCP连接。不仅耗时而且导致服务器负担过重。</p><p>HTTP1.1协议较好地解决了这个问题，它使用<strong>持续连接</strong>，万维网服务器在发送响应之后仍然在一段时间内保持这条连接，使同一个客户和该服务器可以继续在这条连接上传送后续的HTTP请求报文和响应报文。</p><p>1.1协议持续连接有两种方式：<strong>非流水线方式</strong>和<strong>流水线方式</strong>。</p><p>非流水线：客户收到前一个响应后才能发出下一个请求。因此客户没访问以此对象都要用去一个RTT往返时间。</p><p>流水线方式：客户收到HTTP的响应报文之前就能够接着发送新的请求报文。于是一个个请求报文到达服务器后，服务器就可连续发回响应报文。使用流水线方式，客户访问<strong>所有对象</strong>只需花费一个RTT时间。使得TCP连接中的空闲时间减少，提高了下载文档效率。</p><ul><li>HTTP的报文结构</li></ul><p>HTTP有两类报文：</p><p>1）请求报文——从客户向服务器发送请求报文。</p><p>2）响应报文——从服务器到客户的回答。</p><p><img src="/2021/03/15/network/HTTP%E6%8A%A5%E6%96%87%E7%BB%93%E6%9E%84.png"></p><p>1）开始行，用于区分是请求报文还是响应报文。在请求报文中的开始行叫做请求行，而在响应报文中的开始行叫做状态行。开始行的三个字段之间都以空格分隔开，最后的“CR”和“LF”分别代表回车和换行。</p><p>2）首部行。说明浏览器、服务器或报文主体的一些信息。首部可以有好几行，但可以不使用。每一行中都有首部字段名和它的值，每一行在结束的地方都要有回车和换行。整个首部行结束时，还有一空行将首部和后面的实体主体分开。</p><p>3）实体主体，在请求报文中一般都不用这个字段，而在响应报文中也可能没有这个字段。</p><p><img src="/2021/03/15/network/HTTP%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95.PNG"></p><p><img src="/2021/03/15/network/HTTP%E6%96%B9%E6%B3%95.png"></p><p><img src="/2021/03/15/network/HTTP%E6%8A%A5%E6%96%87%E8%AF%B7%E6%B1%82%E4%BE%8B%E5%AD%90.png"></p><p>相应报文经常见到的状态行：</p><p>HTTP/1.1 202 Accepted {接受}</p><p>HTTP/1.1 400 Bad Request {错误的请求}</p><p>HTTP/1.1 404 Not Found {找不到}</p><ul><li>服务器上存放用户信息</li></ul><p>万维网网站点可以使用Cookie来跟踪用户。当用户A浏览某个Cookie网站时，该网站的服务器就为A产生一个唯一的识别码，并以此作为索引在服务器的后端数据库中产生一个项目。接着给A的HTTP响应报文中添加一个叫做Set-cookie的首部行。这里的首部字段名就是Set-cookie，而后面的“值”就是赋予该用户的“识别码”。</p><p>当A收到这个响应时，其浏览器就在它管理的特定Cookie文件中添加一行，其中包括这个服务器的主机名和Set-cookie后面给出的识别码。</p><ul><li>超文本标记语言HTML</li></ul><p>对HTML学习过，这里可以不用看。</p><ul><li>动态文档</li></ul><p>动态文档是指文档的内容在浏览器访问万维网服务器时才由应用程序动态创建。当浏览器请求到达时，万维网服务器要运行另一个应用程序，并把控制转移到此应用程序。应用程序对HTTP报文处理输出HTTP格式的文档，万维网服务器把应用程序的输出作为对浏览器的响应。</p><ul><li>活动万维网文档</li></ul><p>动态文档一旦建立，内容就固定下来无法刷新。所以为了解决这个问题，设计了活动万维网文档。</p><p>两种技术可用于浏览器屏幕显示的连续更新。<strong>服务器推送</strong>，这种技术是将所有工作都交给服务器。服务器不断地运行与动态文档相关联的应用程序，定期更新信息，并发送更新过的文档。</p><p><strong>活动文档</strong>，这种技术把所有工作交给浏览器，每当请求一个活动文档，服务器就返回一段活动文档的副本，使该程序副本在浏览器端运行。这时活动文档可与用户直接交互。</p><ul><li>万维网的信息检索系统</li></ul><p>搜索引擎分为两类：<strong>全文检索搜索引擎</strong>和<strong>分类目录搜索引擎</strong>。</p><p>全文搜索引擎是一种纯技术型的检索工具。它的工作原理是通过搜索软件（爬虫）到互联网上的各网站收集信息，找到一个网站后可以从这个网站再链接到另一个网站，按照一定规则建立一个很大的在线索引数据库供用户查询。用户输入关键字从已经建立的索引数据库里进行查询。（google）</p><p>分类目录搜索利用各网站向搜索引擎提交网站信息时填写的关键词和网站描述等信息，经过人工审核后，输入分类目录数据库中，供网上用户查询。因此分类目录搜索叫分类网站搜索。</p><p><img src="/2021/03/15/network/%E4%B8%A4%E7%A7%8D%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E7%9A%84%E5%8C%BA%E5%88%AB.png"></p><h3 id="4-电子邮件"><a href="#4-电子邮件" class="headerlink" title="4.电子邮件"></a>4.电子邮件</h3><p>简单邮件传送协议SMTP(Simple Mail Transfer Protocol)和互联网文本报文格式。</p><p>邮件系统构件：用户代理、邮件服务器以及邮件发送协议(SMTP)和邮件读取协议（POP3)</p><p><img src="/2021/03/15/network/%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6%E7%9A%84%E4%B8%BB%E8%A6%81%E6%9E%84%E4%BB%B6.png"></p><p>POP3是邮局协议（版本3）。</p><p>SMTP和POP3都是使用TCP来作为传输协议的。</p><h4 id="SMTP协议"><a href="#SMTP协议" class="headerlink" title="SMTP协议"></a>SMTP协议</h4><p>规定了两个相互通信的SMTP进程之间如何交换信息。邮件内部格式，邮件如何存储，以及邮件系统应以多快的速度来发送邮件，SMTP也都<strong>未</strong>做出规定。</p><p>SMTP规定了14条命令和21种应答信息。每条命令用几个字母组成，而每一种应答信息一般都只有一行信息，由一个3位数字的代码开始，后面附上（也可以不附上）很简单的文字说明。</p><p>1）连接建立。</p><p>发件人的邮件发送到发送方的邮件服务器邮件缓存后，SMTP客户每隔一段时间对邮件缓存扫描一次。如发现有邮件，使用SMTP熟知端口25与接收方邮件服务器的SMTP服务器建立TCP连接。建立连接后，接收方SMTP服务器发出“220 Service ready”（服务就绪）应答。然后客户向SMTP服务器发送HELO命令，附上发送方的主机名。SMTP服务器若有能力接收邮件，则回答：“250 OK”，表示已准备好接收。若SMTP服务器不可用，则回答“421 Service not available”（服务不可用）。</p><p>若一定时间内（比如三天）发送不了邮件，邮件服务器就会把情况通知发件人。</p><p>SMTP不使用中间的邮件服务器，TCP连接总是点对点。</p><p>2）邮件发送</p><p><code>MAIN</code>命令开始，如：“<code>MAIL FROM</code>：<a href="mailto:xiexiren@tsinghua.org.cn">xiexiren@tsinghua.org.cn</a>”。若SMTP服务器已准备好接收邮件，则回答“250 OK”。否则返回代码指出原因：</p><p><img src="/2021/03/15/network/SMTP%E8%BF%94%E5%9B%9E%E4%BB%A3%E7%A0%81.png"></p><p>后面跟着一个或多个RCPT命令（发送一个还是多个收件人），RCPT格式：<code>RCPT TO:&lt;收件人地址&gt;</code>。RCPT是recipient（收件人）的缩写。每发送一个RCPT命令，都应当有相应的信息从SMTP服务器返回，如：“250 OK”，表明指明的邮箱在接收方的系统中，或“550 No such user here”,即不存在此邮箱。</p><p>RCPT命令的作用就是：先弄清楚接收方系统是否已做好接收邮件的准备，然后才发送邮件。</p><p>3）连接释放</p><p>邮件发送完毕后，SMTP客户应发送QUIT命令。SMTP服务器返回的信息是“221（服务关闭）”，表示SMTP同意释放TCP连接。邮件传送的全部过程结束。</p><h4 id="电子邮件的信息格式"><a href="#电子邮件的信息格式" class="headerlink" title="电子邮件的信息格式"></a>电子邮件的信息格式</h4><p>一封电子邮件分为<strong>信封</strong>和<strong>内容</strong>两大部分。</p><p><code>To</code>：后面填入一个或多个收件人的电子邮件地址。在电子邮件软件中，用户把经常通信的对象姓名和电子邮件地址写到<strong>地址簿</strong>。</p><p><code>Subject</code>：是邮件的<strong>主题</strong>。</p><h4 id="邮件读取协议POP3和IMAP"><a href="#邮件读取协议POP3和IMAP" class="headerlink" title="邮件读取协议POP3和IMAP"></a>邮件读取协议POP3和IMAP</h4><p>邮局协议POP3和IMAP网际报文存取协议(Internet Message Access Protocol)。</p><p>POP3协议的一个特点就是只要用户从POP3服务器读取了邮件，POP3服务器就该把邮件删除。</p><p>IMAP比POP3复杂很多，IMAP和POP都按照客户服务器方式工作，但它们有很大区别。用户可以在不同的地方使用不同的计算机，随时处理自己的邮件服务。使用IMAP时，在用户的计算机上运行IMAP客户程序，然后与接收方的邮件服务器上的IMAP建立TCP连接。用户在自己的计算机上就可以操纵邮件服务器的邮箱，就像本地操纵一样，IMAP是一个联机协议。</p><p><img src="/2021/03/15/network/IMAP%E5%92%8CPOP3.png"></p><ul><li>通用互联网邮件扩充MIME</li></ul><p><img src="/2021/03/15/network/MIME%E5%92%8CSMTP%E7%9A%84%E5%85%B3%E7%B3%BB.png"></p><p>MIME主要包括以下三部分：</p><p>1）5个新的邮件首部字段，它们可以包含在原来的邮件首部中。这些字段提供了有关邮件主体的信息。</p><p>2）定义了许多邮件内容的格式，对多媒体电子邮件的表示方法进行了标准化。</p><p>3）定义了传送编码，可对任何内容格式进行转换，而不会被邮件系统改变。</p><p><img src="/2021/03/15/network/MIME%E9%A6%96%E9%83%A8%E6%A0%BC%E5%BC%8F.png"></p><p>其中，4）内容传送编码。MEME对ACSII码构成的邮件不进行任何转换。另一种编码方式是quoted-printable，这种编码方式等号“=”和不可打印的ACSII码，除特殊字符等号“=”外，都不可改变。（<font color="red">这个地方在介绍其他编码方式，可以不用看</font>）</p><p>5)内容类型</p><p>内容类型必须有两个标识符，即“内容类型”和“子类型”，中间用“/“分开。</p><p><img src="/2021/03/15/network/MIME%E5%86%85%E5%AE%B9%E7%B1%BB%E5%9E%8B.png"></p><p><img src="/2021/03/15/network/MIME%E5%86%85%E5%AE%B9%E7%B1%BB%E5%9E%8B1.png"></p><h3 id="5-动态主机控制协议DHCP"><a href="#5-动态主机控制协议DHCP" class="headerlink" title="5.动态主机控制协议DHCP"></a>5.动态主机控制协议DHCP</h3><p>协议软件参数化，让很多不同的计算机有可能使用同一个经过编译后的二进制代码。一台计算机需求不同，可以通过参数对代码行为进行控制。</p><p>协议软件中给这些参数赋值的动作叫做<strong>协议配置</strong>。一个协议软件在使用之前必须是正确配置的。协议软件配置的项目如下：</p><ul><li>IP地址</li><li>子网掩码</li><li>默认路由器的IP地址</li><li>域名服务器的IP地址</li></ul><p>因为IP地址中还包括网络号，如果一个主机生产出来后就固定一个IP是不行的。</p><p>现在广泛使用的是**动态主机配置协议DHCP(Dynamic Host Configuration Protocol)**，它提供了即插即用联网机制。</p><p>DHCP使用客户服务器方式。需要IP地址的主机在启动时就向DHCP服务器广播发送<strong>发现报文</strong>(将目的IP地址置为全1，即255.255.255.255)，，本机地址设置为0.0.0.0（本机还不知道，只能这么设置）。这个报文只有DHCP服务器能够进行回答。DHCP服务器现在其数据库中查找该计算机的配置信息，若找到，则返回信息。若找不到，则从服务器的IP地址池中取一个地址分配给该计算机。DHCP服务器回答报文叫<strong>提供报文</strong>，表示“提供”了IP地址等配置信息。</p><p>为了防止DHCP服务器太多，每个网络至少有一个DHCP中继代理，通常是一台路由器，它配置了DHCP服务器的IP地址信息。当DHCP中继代理收到主机A以广播形式发送的报文后，就以单播的形式向DHCP服务器发送此报文，等待回答。</p><p><img src="/2021/03/15/network/DHCP%E4%B8%AD%E7%BA%A7%E4%BB%A3%E7%90%86.png"></p><p>DHCP服务器分配给DHCP客户的IP的地址是临时的，因此DHCP客户只能在一段有限时间内使用这个IP地址，这个时间叫<strong>租用期</strong>。DHCP协议规定租用期用4字节表示，单位是秒。因此租用期范围是1秒到136年。DHCP客户也可在自己发送的报文中提出对租用期的要求。</p><p>DHCP客户使用<strong>UDP</strong>端口68，服务器使用67。</p><p><img src="/2021/03/15/network/DHCP%E7%9A%84%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B.png"></p><p>工作协议的解释详情看P297。</p><h3 id="6-简单网络管理协议SNMP"><a href="#6-简单网络管理协议SNMP" class="headerlink" title="6. 简单网络管理协议SNMP"></a>6. 简单网络管理协议SNMP</h3><p>管理站又称为管理器，是整个网络系统的核心。它通常是个有良好图形界面的高性能工作站，并由网络管理员直接操作和控制。</p><p>SNMP中的管理程序和代理程序按客户服务器方式工作。在被管理对象上运行的SNMP服务器程序不停地监听来自客户程序的请求，一旦发现就返回所需要的信息，或者执行某个动作。</p><p>网络管理有一个基本<strong>原理</strong>：若要管理某个对象，就必然会给该对象添加一些软件或硬件，但这种“添加”对原有对象的影响必须尽量小些。</p><p>SNMP网络管理由三个部分组成，即SNMP本身、管理信息结构SMI和管理信息库MIB。</p><ul><li>管理信息结构SMI</li></ul><p>SMI是SNMP的重要组成部分。SMI的功能有：</p><p>1）被管对象如何命名。</p><p>2）用来存储被管对象的数据类型有哪些。</p><p>3）在网络上传送的管理数据应如何编码。</p><ol><li>被管对象的命名。</li></ol><p>SMI规定，所有的被管对象都必须处在对象命名树上。</p><p><img src="/2021/03/15/network/SMI%E5%AF%B9%E8%B1%A1%E5%91%BD%E5%90%8D%E6%A0%91.png"></p><p>对象命名树的根没有名字，它下面有三个顶级对象，都是世界上著名的标准指定单位，即ITU-T，ISO以及这两个组织的联合体。internet节点下面的标号为2的节点是mgmt（管理）。再下面是mib-2，包含了所有被SNMP管理的对象。</p><ol start="2"><li>被管对象的数据类型</li></ol><p>SMI使用基本的抽象语法记法1（即ISO制定的ASN.1)来定义数据类型。这里的ISO ASN.1不用管，它只是描述数据的结构形式。</p><p>SMI把数据类型分为两大类：<strong>简单类型</strong>和<strong>结构化类型</strong>。简单类型是最基本的、直接使用ASN.1定义的类型。</p><p><img src="/2021/03/15/network/SMI%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.png"></p><ol start="3"><li>编码方法</li></ol><p>使用**基本编码规则BER(Basic Encoding Rule)**进行数据的编码。BER指明了每种数据的类型和值。ASN.1把所有数据元素都表示为T-L-V三个字段组成的序列。T字段定义数据的类型，L字段定义V字段的长度，而V字段定义数据的值。</p><p><img src="/2021/03/15/network/TLV%E6%96%B9%E6%B3%95.png"></p><p>T字段叫做<strong>标记字段</strong>。占1字节。T字段比较复杂，因为他要定义数据类型较多。T字段又分为以下三个子字段：</p><p>1）类别（2位）共四种：通用类（00），即ASN.1定义的类型。应用类（01）即SMI定义的类型。上下文类（10），即上下文所定义的类型；专用类（11），保留为特定厂商定义的类型。</p><p>2）格式（1位）共两种，指出数据类型的种类：简单数据类型（0）、结构化数据类型（1）。</p><p>3）编号（5位），共两种，标志不同的数据类型。编号的范围是0-30。当编号大于30时，T字段就要扩展多个字节。</p><p>L字段又叫做长度字段。L字段为单字节时，其最高位为0，后面的7位定义V字段的长度。当L字段为多个字节时，其最高位为1，而后面的7位定义后续字节的字节数。</p><p><img src="/2021/03/15/network/L%E5%AD%97%E6%AE%B5%E7%9A%84%E6%A0%BC%E5%BC%8F.png"></p><p>V字段又叫值字段，用于定义数据元素的值。</p><ul><li>管理信息库MIB</li></ul><p>管理信息指互联网的网管框架中被管对象的集合。被管对象构成了一个虚拟的信息存储器，所以才称为管理信息库MIB。管理程序就使用MIB中的这些信息对网络进行管理。只有在MIB中的对象才是SNMP所能够管理的。</p><p>MIB的意义：节点<code>ip</code>下面有个名为<code>ipInReceives</code>的MIB变量，表示收到的IP数据报数量。在图6-22中，这个变量的标号是3，变量的名字是:<code>iso.org.dod.internet.mgmt.mib.ip.ipInReceives</code>，而相应的数值表示是1.3.6.1.2.1.4.3。</p><ul><li>SNMP的协议数据单元和报文</li></ul><p>1）<strong>“读”</strong>操作，用Get报文来检测各被管对象的状况。</p><p>2）<strong>”写“</strong>操作，用Set报文来改变各被管对象的状况。</p><p>SNMP的这些功能通过探询操作来实现，即SNMP管理进程定时向被管理设备周期性地发送探询信息。上述时间间隔可通过SNMP的管理信息库MIB来建立。探询的好处是：第一，可使系统相对简单。第二，能限制通过网络所产生的管理信息的通信量。</p><p>SNMP同时不是完全的探寻协议，它不允许不经过询问就能发送某些信息。这种信息称为陷阱，表示它能够捕捉“事件”。但这种陷阱信息的参数是受限制的。</p><p><strong>使用无连接的UDP</strong>。服务器端使用161来接收Get或Set报文和发送响应报文，但运行管理程序的客户端则使用熟知端口162来接收来自各代理的trap报文。</p><p><img src="/2021/03/15/network/SNMP%E7%9A%84%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F.png"></p><p>SNMP报文没有固定的字段，共分为以下四个部分：</p><p>1）版本</p><p>2）首部</p><p>3）安全参数</p><p>4）数据部分</p><h3 id="7-应用进程跨越网络的通信"><a href="#7-应用进程跨越网络的通信" class="headerlink" title="7. 应用进程跨越网络的通信"></a>7. 应用进程跨越网络的通信</h3><p>实际上应用程序调用系统接口。此接口把控制权交给操作系统，操作系统执行完成后，在返回给应用进程。系统调用接口实际上就是应用进程的控制权和操作系统的控制权进行转换的一个接口。</p><p>书中后面在讲开发的Socket套接字接口例子(套接字现在已经成为操作系统内核的一部分），熟悉编程了这东西比书上懂得多多了。</p><p><img src="/2021/03/15/network/%E5%A5%97%E6%8E%A5%E5%AD%97.png"></p><p>常用的系统调用（TCP服务）</p><p>1） 连接建立阶段。</p><p>套接字创建后，它的端口号和IP地址都是空的，因此应用进程要调用bind（绑定）来指明套接字的本地地址（本地端口号和本地IP地址）。</p><p>服务器调用bind后，还必须调用listen（监听）把套接字设置为被动方式，以便随时接受客户的服务请求。UDP服务器由于只是提供无连接服务，不使用listen系统调用。</p><p>然后调用accept（接受），能够处理多个连接（并发）。</p><p>客户请求连接后，服务器把套接字的标识符返回给发起连接的客户方。</p><p>2）数据传送阶段</p><p>send系统调用传送数据，使用recv系统调用接收数据。</p><p>通常send调用把数据复制到操作系统内核的缓存种，若系统的缓存已经满了，send就暂时阻塞，直到缓存有空间存放新的数据。</p><p>3）连接释放</p><p>close调用释放连接和撤销套接字。</p><p><img src="/2021/03/15/network/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E4%BD%BF%E7%94%A8%E9%A1%BA%E5%BA%8F.png"></p>]]></content>
      
      
      <categories>
          
          <category> network </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
